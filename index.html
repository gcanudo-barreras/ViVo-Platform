<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ViVo: In Vivo Metrics</title>
    <link rel="stylesheet" href="css/styles.css">
    <script src="js/intelligent_outlier_detector.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>

<body>
    <div class="container">
        <header>
            <div class="logo-container">
                <img src="https://raw.githubusercontent.com/gcanudo-barreras/vivo-platform/main/assets/ViVo.png" alt="ViVo Logo" style="width: 256px; height: 256px;">
            </div>
        </header>

        <div class="debug-panel" id="debugPanel">
            <h3>Debug Mode Activated</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <button class="btn small" onclick="testFileLoad()">
                    <span>Test Load</span>
                </button>
                <button class="btn small" onclick="checkLibraries()">
                    <span>Check Libs</span>
                </button>
            </div>
            <div id="debugConsole"
                style="background: #000; color: #00ff00; padding: 1rem; border-radius: 5px; margin-top: 1rem; font-family: monospace; font-size: 0.8rem; height: 200px; overflow-y: auto;">
            </div>
        </div>

        <div class="control-panel">
            <div class="control-group">
                <label for="fileInput" style="color: #4facfe; font-weight: 600; margin-bottom: 0.5rem; display: block;">CSV Data File</label>
                <div class="file-input-wrapper" style="position: relative; display: inline-block; width: 100%;">
                    <input type="file" id="fileInput" accept=".csv,.txt" style="position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer;" />
                    <div class="file-input-label" id="fileLabel" style="
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        padding: 1.5rem; 
                        background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1)); 
                        border: 2px dashed rgba(79, 172, 254, 0.5); 
                        border-radius: 12px; 
                        color: #e0e0e0; 
                        cursor: pointer; 
                        transition: all 0.3s ease;
                        min-height: 80px;
                        text-align: center;
                        font-size: 1rem;
                    ">
                        Drag your CSV file here or click to select
                        <br><small style="color: #a0a0a0; padding-left: 5px; margin-top: 2px;">Accepted formats: .csv, .txt</small>
                    </div>
                </div>
                <div style="margin: 8px 0 0 0; color: #a0a0a0; font-size: 0.9rem; line-height: 1.4;">
                    <p style="margin: 0 0 8px 0;"><strong>Required structure:</strong> <i>Animal</i>, <i>Group</i>, Day columns (<i>0</i>, <i>2</i>, <i>4</i>, <i>7</i>, <i>10</i>...), <i>Tumor_Weight</i> (optional)</p>
                    <p style="margin: 0;"><strong>Templates available:</strong></p>
                    <ul style="margin: 4px 0 0 20px; padding: 0;">
                        <li><strong><a href="templates/ViVo_basic_dataset_template.csv" download="templates/basic_dataset_template.csv" style="color: #4facfe; text-decoration: underline; cursor: pointer;">Basic</a>:</strong> BLI data format (C1, C2, C3, T1, T2, T3...)</li>
                        <li><strong><a href="templates/ViVo_dataset_with_weights_template.csv" download="dataset_with_weights_template.csv" style="color: #4facfe; text-decoration: underline; cursor: pointer;">With Weights</a>:</strong> BLI + Tumor_Weight column for auto-detection</li>
                        <li><strong><a href="templates/ViVo_tumor_weights_template.csv" download="tumor_weights_template.csv" style="color: #4facfe; text-decoration: underline; cursor: pointer;">Weights Only</a>:</strong> Separate file for batch predictions</li>
                    </ul>
                </div>
            </div>

            <div class="control-group">
                <label for="dataType">Data Type</label>
                <select id="dataType">
                    <option value="volume">Tumor Volume (mm³)</option>
                    <option value="bli">BLI (Bioluminescence)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="r2Threshold">R² Threshold (fit quality)</label>
                <input type="number" id="r2Threshold" step="0.01" min="0" max="1" value="0.8" />
            </div>

            <div class="control-group">
                <label for="outlierConfig">Outlier Detection Configuration</label>
                <select id="outlierConfig" onchange="updateOutlierConfig()">
                    <option value="auto" selected>Auto (adjusts to sample size)</option>
                    <option value="ultraConservative">Ultra-Conservative (pilot studies, n&lt;5)</option>
                    <option value="conservative">Conservative (standard studies, n=5-10)</option>
                    <option value="moderate">Moderate (large studies, n&gt;10)</option>
                </select>
                <small style="color: #a0a0a0; font-size: 0.85rem; margin-top: 5px; display: block;">
                    Auto mode automatically adjusts sensitivity based on loaded sample size.
                </small>
            </div>

            <div class="control-group">
                <label for="outlierFiltering">Anomaly Filtering Level</label>
                <select id="outlierFiltering">
                    <option value="critical">Critical Only (default)</option>
                    <option value="criticalAndHigh" selected>Critical + High (recommended)</option>
                    <option value="all">All Anomalies (very strict)</option>
                </select>
                <small style="color: #a0a0a0; font-size: 0.85rem; margin-top: 5px; display: block;">
                    Determines which level of anomalies are automatically excluded from analysis.
                </small>
            </div>

            <div class="button-grid">
                <button class="btn" onclick="analyzeData()">
                    Analyze Data
                </button>
                <button class="btn outlier" onclick="showOutlierAnalysisOnly()">
                    Analyze Outliers
                </button>
                <button class="btn secondary" onclick="exportEnhancedCSV()">
                    Export CSV
                </button>
                <button class="btn tertiary" onclick="togglePredictionForm()">
                    Predictions
                </button>
                <button class="btn quaternary" onclick="generateGrowthMatrices()">
                    Growth Matrices
                </button>
                <button class="btn secondary" onclick="generateReport()">
                    Generate Report
                </button>
            </div>
        </div>

        <div id="results" class="results-section"></div>
    </div>

    <script>
        // Global variables
        let rawData = [];
        let processedData = {};
        let animalModels = {};
        let dayColumns = [];
        let growthMatrices = {};
        let globalMin = Infinity;
        let globalMax = -Infinity;
        let controlGroup = null;
        let optimizedColorRange = { min: 0, max: 0 };
        let customColorRange = null;
        window.normalizedChartData = null;
        let currentFileName = ''; // Store current CSV filename

        //Outliers detection
        let outlierDetector = null;
        let outlierAnalysis = null;
        let useFilteredData = false;
        let usePointFiltering = false;
        let currentState = 0;

        const states = [
            {
                text: "All data",
                style: "background: linear-gradient(45deg, #4facfe, #00f2fe);",
                action: () => {
                    if (!outlierAnalysis) {
                        showNotification('First run the outlier analysis', 'warning');
                        return;
                    }

                    // Reset filters
                    useFilteredData = false;
                    usePointFiltering = false;

                    // Use complete data
                    const dataToUse = outlierAnalysis.dualAnalysis.complete.animals;
                    reprocessDataWithOutlierSelection(dataToUse);

                    showNotification('Using all data without filtering', 'info');
                }
            },
            {
                text: "Filtered Animals",
                style: "background: linear-gradient(45deg, #ff6b6b, #ee5a52);",
                action: () => {
                    if (!outlierAnalysis) {
                        showNotification('First run the outlier analysis', 'warning');
                        return;
                    }

                    // Activate animal filter, deactivate point filter
                    useFilteredData = true;
                    usePointFiltering = false;

                    // Use data with filtered animals
                    const dataToUse = outlierAnalysis.dualAnalysis.filtered.animals;
                    reprocessDataWithOutlierSelection(dataToUse);

                    const excludedCount = outlierAnalysis.dualAnalysis.impact.animalsExcluded;
                    showNotification(`Excluded ${excludedCount} animal(s) with severe outliers`, 'info');
                }
            },
            {
                text: "Filtered Points",
                style: "background: linear-gradient(45deg, #a55eea, #26de81);",
                action: () => {
                    if (!outlierAnalysis) {
                        showNotification('First run the outlier analysis', 'warning');
                        return;
                    }

                    // Activate point filter, use complete data as base
                    useFilteredData = false;
                    usePointFiltering = true;

                    // Get or generate point filtering analysis
                    let dataToUse;
                    if (!outlierAnalysis.pointFilteringAnalysis) {
                        showNotification('Running point filtering analysis...', 'info');
                        outlierAnalysis.pointFilteringAnalysis = outlierDetector.performPointFilteringAnalysis(
                            outlierAnalysis.dualAnalysis.complete.animals
                        );
                    }
                    dataToUse = outlierAnalysis.pointFilteringAnalysis.animals;

                    // Reprocess with new data
                    reprocessDataWithOutlierSelection(dataToUse);

                    const excludedPoints = outlierAnalysis.pointFilteringAnalysis.excludedPoints;
                    showNotification(`Excluded ${excludedPoints} specific anomalous point(s)`, 'success');
                }
            }
        ];

        // Configurations for different study types
        const OUTLIER_CONFIGS = {
            auto: {
                name: 'Auto (automatic adjustment)'
            },
            ultraConservative: {
                name: 'Ultra-Conservative (pilot studies, n<5)',
                maxGrowthRate: Math.log(50),          // 5000%/day
                maxDeclineRate: Math.log(10),         // 90% reduction/day
                iqrSensitivity: 4.0,                  // Extremely permissive
                requireMultipleFlags: true,           // Requires 2+ indicators
                minGroupSizeForIQR: 8,               // Almost never apply IQR
                biologicalChangeThreshold: Math.log(20)  // 2000%/day
            },
            conservative: {
                name: 'Conservative (standard studies, n=5-10)',
                maxGrowthRate: Math.log(20),          // 2000%/day
                maxDeclineRate: Math.log(5),          // 80% reduction/day
                iqrSensitivity: 3.0,                  // Very permissive
                requireMultipleFlags: true,           // Multiple confirmation
                minGroupSizeForIQR: 5,               // Apply with caution
                biologicalChangeThreshold: Math.log(10)  // 1000%/day
            },
            moderate: {
                name: 'Moderate (large studies, n>10)',
                maxGrowthRate: Math.log(10),          // 1000%/day
                maxDeclineRate: Math.log(3),          // 67% reduction/day
                iqrSensitivity: 2.0,                  // Moderately permissive
                requireMultipleFlags: false,          // Single flag sufficient
                minGroupSizeForIQR: 4,               // Apply normally
                biologicalChangeThreshold: Math.log(5)   // 500%/day
            }
        };

        // Types of detectable anomalies
        const FLAG_TYPES = {
            IMPOSSIBLE_VALUE: { severity: 'critical', name: 'Impossible Value', color: '#dc3545' },
            EXTREME_GROWTH: { severity: 'critical', name: 'Extreme Growth', color: '#dc3545' },
            EXTREME_DECLINE: { severity: 'critical', name: 'Extreme Decline', color: '#dc3545' },
            INTRA_OUTLIER: { severity: 'high', name: 'Intra-Animal Outlier', color: '#fd7e14' },
            GROUP_OUTLIER: { severity: 'medium', name: 'Group Outlier', color: '#ffc107' },
            LAST_DAY_DROP: { severity: 'medium', name: 'Last Day Drop', color: '#ffc107' }
        };

        // Console override for debug mode
        const originalConsoleLog = console.log;
        console.log = function (...args) {
            const debugPanel = document.getElementById('debugPanel');
            debugPanel.style.display = debugMode ? 'block' : 'none';

            originalConsoleLog.apply(console, arguments);
            if (debugMode) {
                const debugConsole = document.getElementById('debugConsole');
                if (debugConsole) {
                    debugConsole.innerHTML += args.join(' ') + '\n';
                    debugConsole.scrollTop = debugConsole.scrollHeight;
                }
            }
        };

        // URL DEBUG SYSTEM - Add at script start
        // Function to detect URL parameters
        function getURLParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        // Function to check if debug mode is active
        function isDebugMode() {
            return getURLParameter('debug') === 'true';
        }

        // Global variable to control debug mode
        let debugMode = isDebugMode();

        function initializeDebugMode() {
            if (debugMode) {

                // Show debug active notification
                showNotification('Debug Mode Activated', 'info');

                // Add visual indicator in the interface
                addDebugIndicator();

                // Show additional information in console
            }
        }

        // Function to add visual debug indicator
        function addDebugIndicator() {
            // Create discrete visual indicator
            const debugIndicator = document.createElement('div');
            debugIndicator.id = 'debugIndicator';
            debugIndicator.innerHTML = '🐛 DEBUG';
            debugIndicator.style.cssText = `
                position: fixed;
                top: 10px;
                left: 10px;
                background: rgba(231, 76, 60, 0.9);
                color: white;
                padding: 5px 10px;
                border-radius: 15px;
                font-size: 0.8em;
                font-weight: bold;
                z-index: 9999;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                cursor: pointer;
                transition: all 0.3s ease;
            `;

            debugIndicator.title = 'Debug Mode Active\nClick to view logs in console\nRemove ?debug=true from URL to deactivate';

            // Click to show additional information
            debugIndicator.addEventListener('click', () => {
                console.group('DEBUG INFORMATION');
                console.groupEnd();

                showNotification('Debug information displayed in console', 'info');
            });

            document.body.appendChild(debugIndicator);
        }

        // Función de log condicional para debug
        function debugLog(message, data = null) {
            if (debugMode) {
                if (data) {
                } else {
                }
            }
        }

        // Function to show detailed errors in debug mode
        function debugError(message, error = null) {
            if (debugMode) {
                console.error(`🚨 DEBUG ERROR: ${message}`, error);
                showNotification(`🚨 Error: ${message}`, 'error');
            }
        }

        // Función para medir tiempos de ejecución en debug
        function debugTime(label) {
            if (debugMode) {
                console.time(`⏱️ ${label}`);
            }
        }

        function debugTimeEnd(label) {
            if (debugMode) {
                console.timeEnd(`⏱️ ${label}`);
            }
        }

        function calculateOptimizedGrowthMatricesWithDebug() {
            debugTime('Matrix calculation');
            debugLog('Starting optimized matrix calculation');

            try {
                // ... your existing code ...

                debugLog('Matrices calculated successfully', {
                    groups: Object.keys(growthMatrices),
                    colorRange: optimizedColorRange
                });

                debugTimeEnd('Matrix calculation');

            } catch (error) {
                debugError('Error in matrix calculation', error);
                debugTimeEnd('Matrix calculation');
                throw error;
            }
        }

        // In the displayMainChart() function - ADD THESE LOGS
        function displayMainChartWithDebug() {
            debugTime('Main chart rendering');
            debugLog('Starting main chart rendering');

            try {
                // ... your existing Plotly code ...

                debugLog('Main chart rendered successfully');
                debugTimeEnd('Main chart rendering');

            } catch (error) {
                debugError('Error in chart rendering', error);
                debugTimeEnd('Main chart rendering');
            }
        }

        function monitorURLChanges() {
            // Detect URL changes to activate/deactivate debug dynamically
            window.addEventListener('popstate', () => {
                const newDebugState = isDebugMode();
                if (newDebugState !== debugMode) {
                    debugMode = newDebugState;
                    if (debugMode) {
                        addDebugIndicator();
                        showNotification('Debug Mode Activated', 'info');
                    } else {
                        const indicator = document.getElementById('debugIndicator');
                        if (indicator) indicator.remove();
                        showNotification('Debug Mode Deactivated', 'info');
                    }
                }
            });
        }

        // INITIALIZATION - CALL WHEN LOADING THE PAGE
        document.addEventListener('DOMContentLoaded', () => {
            initializeDebugMode();
            monitorURLChanges(); // Optional: for dynamic changes
        });


        // Function to show notifications
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 500);
            }, 4000);
        }

        function checkLibraries() {
            debugLog('=== CHECKING LIBRARIES ===');

            const results = {
                Papa: typeof Papa !== 'undefined',
                Plotly: typeof Plotly !== 'undefined'
            };
            debugLog('PapaParse available:', results.Papa);
            debugLog('Plotly available:', results.Plotly);

            if (results.Papa && results.Plotly) {
                showNotification('All libraries are loaded', 'success');
            } else {
                showNotification('Missing libraries to load', 'error');
            }
        }

        // Function to clear all results and reset the application state
        function clearAllResults() {
            debugLog('Clearing all previous results and data...');
            
            // Clear all data variables
            rawData = [];
            processedData = {};
            animalModels = {};
            growthMatrices = {};
            dayColumns = [];
            globalMin = Infinity;
            globalMax = -Infinity;
            controlGroup = null;
            optimizedColorRange = { min: 0, max: 0 };
            customColorRange = null;
            window.normalizedChartData = null;
            outlierAnalysis = null;
            currentFileName = '';
            
            // Reset outlier detection
            if (outlierDetector) {
                outlierDetector.reset();
            }
            useFilteredData = false;
            usePointFiltering = false;
            currentState = 0;
            
            // Clear all visual results from DOM
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) {
                // Remove all result cards
                const resultCards = resultsDiv.querySelectorAll('.result-card');
                resultCards.forEach(card => card.remove());
                
                // Remove any remaining matrix containers
                const matrixContainers = resultsDiv.querySelectorAll('.matrices-container, .matrix-group');
                matrixContainers.forEach(container => container.remove());
                
                // Clear any remaining content
                resultsDiv.innerHTML = '';
            }
            
            // Reset file label
            const fileLabel = document.getElementById('fileLabel');
            if (fileLabel) {
                fileLabel.textContent = 'No file selected';
                fileLabel.classList.remove('file-loaded');
            }
            
            // Clear any Plotly charts if they exist
            const plotlyCharts = ['mainChart', 'normalizedChart'];
            plotlyCharts.forEach(chartId => {
                const chartElement = document.getElementById(chartId);
                if (chartElement && typeof Plotly !== 'undefined') {
                    Plotly.purge(chartId);
                }
            });
            
            // Clear any other canvas elements if they exist
            const chartElements = document.querySelectorAll('canvas');
            chartElements.forEach(canvas => {
                const context = canvas.getContext('2d');
                if (context) {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                }
            });
            
            debugLog('All results cleared successfully');
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            const fileLabel = document.getElementById('fileLabel');
            
            if (!file) {
                debugLog('No file selected');
                fileLabel.innerHTML = `
                    Drag your CSV file here or click to select
                    <br><small style="color: #a0a0a0; margin-top: 8px;">Accepted formats: .csv, .txt</small>
                `;
                fileLabel.style.borderColor = 'rgba(79, 172, 254, 0.5)';
                fileLabel.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1))';
                return;
            }

            debugLog('File selected:', {
                name: file.name,
                size: file.size,
                type: file.type,
                lastModified: new Date(file.lastModified)
            });

            // Clear all previous results and data when loading new dataset
            clearAllResults();

            // Store filename for use in reports
            currentFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension

            // Show loading state
            fileLabel.innerHTML = `
                📄 ${file.name} (Loading...)
                <br><small style="color: #a0a0a0; margin-top: 8px;">Processing file...</small>
            `;
            fileLabel.style.borderColor = 'rgba(79, 172, 254, 0.8)';
            fileLabel.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.2), rgba(0, 153, 204, 0.2))';
            fileLabel.classList.add('file-loaded');

            if (typeof Papa === 'undefined') {
                debugError('PapaParse is not available');
                showNotification('Error: PapaParse is not loaded', 'error');
                return;
            }
            debugLog('Starting parsing with PapaParse...');

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function (results) {
                    debugLog('Parsing completed:', results);

                    if (results.errors && results.errors.length > 0) {
                        debugError('Parsing errors:', results.errors);
                        showNotification(`Warning: ${results.errors.length} errors in CSV`, 'warning');
                    }

                    rawData = results.data.filter(row => row && Object.keys(row).length > 0);
                    debugLog('Data processed:', rawData.length, 'rows');

                    if (rawData.length === 0) {
                        debugError('No valid data');
                        const fileLabel = document.getElementById('fileLabel');
                        fileLabel.innerHTML = `
                            ${file.name} (Empty or invalid)
                            <br><small style="color: #ff6b6b; padding-left: 5px; margin-top: 2px;">No valid data found</small>
                        `;
                        fileLabel.style.borderColor = 'rgba(255, 107, 107, 0.8)';
                        fileLabel.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(220, 53, 69, 0.1))';
                        showNotification('CSV file is empty or has no valid data', 'error');
                        return;
                    }

                    // Success state
                    const fileLabel = document.getElementById('fileLabel');
                    fileLabel.innerHTML = `
                        ${file.name} loaded successfully
                        <br><small style="color: #84D288; padding-left: 5px; margin-top: 2px;">${rawData.length} data rows processed</small>
                    `;
                    fileLabel.style.borderColor = 'rgba(132, 210, 136, 0.8)';
                    fileLabel.style.background = 'linear-gradient(135deg, rgba(132, 210, 136, 0.1), rgba(40, 167, 69, 0.1))';
                    showNotification(`File loaded: ${rawData.length} rows processed`, 'success');
                    debugLog('Data preview:', rawData.slice(0, 3));
                    debugLog('Detected columns:', Object.keys(rawData[0]));

                    // Auto-adjust outlier configuration based on sample size
                    const configSelect = document.getElementById('outlierConfig');
                    if (rawData.length < 5) {
                        configSelect.value = 'ultraConservative';
                    } else if (rawData.length <= 10) {
                        configSelect.value = 'conservative';
                    } else {
                        configSelect.value = 'moderate';
                    }
                    showNotification(`Outlier configuration automatically adjusted`, 'info');
                },
                error: function (error) {
                    const fileLabel = document.getElementById('fileLabel');
                    debugError('Parsing error:', error);
                    fileLabel.innerHTML = `
                        ❌ ${file.name} (Error)
                        <br><small style="color: #ff6b6b; margin-top: 8px;">Failed to load file</small>
                    `;
                    fileLabel.style.borderColor = 'rgba(255, 107, 107, 0.8)';
                    fileLabel.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(220, 53, 69, 0.1))';
                    showNotification('Error loading file: ' + error.message, 'error');
                }
            });
        }

        function testFileLoad() {

            const fileInput = document.getElementById('fileInput');

            if (fileInput.files.length === 0) {
                showNotification('Please select a file first', 'warning');
                return;
            }

            const file = fileInput.files[0];
            console.log('File details:', {
                name: file.name,
                size: file.size,
                type: file.type,
                lastModified: new Date(file.lastModified)
            });

            const reader = new FileReader();
            reader.onload = function (e) {
                const content = e.target.result;

                const lines = content.split('\n').filter(line => line.trim().length > 0);

                if (lines.length > 0) {
                    if (lines.length > 1) {
                        console.log('Second line (data):', lines[1]);
                    }
                }

                showNotification(`Test OK: ${lines.length} lines detected`, 'success');
            };

            reader.onerror = function () {
                console.error('Error reading file');
                showNotification('Error reading file', 'error');
            };

            reader.readAsText(file);
        }

        //OUTLIERS
        function initializeOutlierDetector() {
            const totalAnimals = rawData.length;
            const configSelect = document.getElementById('outlierConfig');
            const userConfig = configSelect.value;

            let config;
            if (userConfig === 'auto') {
                if (totalAnimals < 5) {
                    config = 'ultraConservative';
                } else if (totalAnimals <= 10) {
                    config = 'conservative';
                } else {
                    config = 'moderate';
                }

                // Update the select to show the auto-selected configuration
                const autoText = `Auto → ${OUTLIER_CONFIGS[config].name}`;
                const autoOption = configSelect.querySelector('option[value="auto"]');
                if (autoOption) {
                    autoOption.textContent = autoText;
                }

                debugLog(`Auto configuration selected: ${config} for ${totalAnimals} animals`);
            } else {
                // User manual configuration
                config = userConfig;
                debugLog(`Manual configuration: ${config} for ${totalAnimals} animals`);
            }

            outlierDetector = new IntelligentOutlierDetector(config);
            return outlierDetector;
        }

        function parseAnimalData(rawData) {
            const dayCols = Object.keys(rawData[0])
                .filter(k => !isNaN(parseFloat(k)))
                .map(Number)
                .sort((a, b) => a - b);

            const animals = rawData.map((row, i) => {
                const id = row.Animal || row.ID || `Animal_${i + 1}`;
                const group = row.Group || row.Grupo || 'No group';
                const tp = [], ms = [];
                dayCols.forEach(day => {
                    const val = parseFloat(row[day]);
                    if (!isNaN(val) && val > 0) {
                        tp.push(day);
                        ms.push(val);
                    }
                });
                return tp.length >= 3 ? { id, group, timePoints: tp, measurements: ms } : null;
            }).filter(Boolean);

            return { animals, dayCols };
        }

        function showOutlierAnalysisOnly() {
            if (rawData.length === 0) {
                showNotification('Please load a CSV file first', 'warning');
                return;
            }

            showNotification('Running outlier analysis...', 'info');

            const dataType = document.getElementById('dataType').value;

            const parsed = parseAnimalData(rawData);
            const animalsForOutlierAnalysis = parsed.animals;
            dayColumns = parsed.dayColumns;

            // Execute outlier analysis
            if (!outlierDetector) {
                initializeOutlierDetector();
            }

            outlierAnalysis = outlierDetector.analyzeDataset(animalsForOutlierAnalysis, dataType);

            // Show only the outlier panel
            displayOutlierPanel();
            initializeActiveBox();

            showNotification('Outlier analysis completed', 'success');
        }

        function displayOutlierPanel() {
            if (!outlierAnalysis) return;

            const resultsDiv = document.getElementById('results');

            // Remover panel anterior si existe
            const existingPanel = document.getElementById('outlierCard');
            if (existingPanel) existingPanel.remove();

            const card = document.createElement('div');
            card.className = 'result-card';
            card.id = 'outlierCard';

            const summary = outlierAnalysis.summary;
            const dualAnalysis = outlierAnalysis.dualAnalysis;

            let html = `
                <h2>Intelligent Outlier Analysis</h2>
<div class="outlier-panel">
    <div class="outlier-summary">
        <div class="outlier-stat">
            <div class="outlier-stat-value" style="color: #2196f3;">${summary.totalFlags}</div>
            <div class="outlier-stat-label">Detected Anomalies</div>
        </div>
        <div class="outlier-stat">
            <div class="outlier-stat-value" style="color: #f44336;">${summary.severityCounts.critical}</div>
            <div class="outlier-stat-label">Critical</div>
        </div>
        <div class="outlier-stat">
            <div class="outlier-stat-value" style="color: #ff9800;">${summary.severityCounts.high}</div>
            <div class="outlier-stat-label">High</div>
        </div>
        <div class="outlier-stat">
            <div class="outlier-stat-value" style="color: #4caf50;">${dualAnalysis.filtered.count}</div>
            <div class="outlier-stat-label">Animals Post-Filter</div>
        </div>
    </div>
    
    <div style="text-align: center; margin: 15px 0;">
        <span style="background: rgba(76, 175, 80, 0.2); padding: 5px 10px; border-radius: 15px; color: #4caf50; font-weight: 500; font-size: 0.9rem;">
            ${summary.configUsed}
        </span>
    </div>
</div>

<div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; margin: 15px 0;">
    <h3 style="margin: 0 0 15px 0; color: #4facfe;">Dual Analysis: Complete vs Filtered Data</h3>
    
    <div class="dual-analysis">
        <div class="analysis-box complete-analysis">
            <h4>All Data</h4>
            <p>Animals: <strong>${dualAnalysis.complete.count}</strong></p>
            <p>Measurements: <strong>${dualAnalysis.complete.totalMeasurements}</strong></p>
        </div>
        <div class="analysis-box filtered-analysis">
            <h4>Filtered Animals</h4>
            <p>Animals: <strong>${dualAnalysis.filtered.count}</strong></p>
            <p>Measurements: <strong>${dualAnalysis.filtered.totalMeasurements}</strong></p>
            <p>Excluded: <strong>${dualAnalysis.impact.animalsExcluded} animals</strong></p>
        </div>
        <div class="analysis-box points-filtered-analysis">
            <h4>Filtered Points</h4>
            <p>Animals: <strong>${outlierAnalysis.pointFilteringAnalysis.animals.length}</strong></p>
            <p>Measurements: <strong>${outlierAnalysis.pointFilteringAnalysis.totalPointsFiltered}</strong></p>
            <p>Excluded: <strong>${outlierAnalysis.pointFilteringAnalysis.excludedPoints} points</strong></p>
        </div>
    </div>
         
    <div style="text-align: center; margin: 20px 0;">
        <button
            id="cyclicBtn"
            class="btn"
            onclick="cycleThroughStates()"
            style="background: linear-gradient(45deg, #4facfe, #00f2fe); margin-right: 10px;"
        >
            Complete Data
        </button>
        <button
            class="btn secondary"
            onclick="showOutlierDetails()"
        >
            View Details
        </button>
    </div>

    <div style="background: rgba(33, 150, 243, 0.1); padding: 12px; border-radius: 8px; margin: 10px 0; font-size: 0.9rem;">
        <strong>Point Filtering:</strong> Excludes problematic individual measurements without removing complete animals from analysis.
        <br><strong>Animal Filtering:</strong> Excludes complete animals that do not meet quality criteria.
    </div>
    
    ${dualAnalysis.impact.animalsExcluded > 0 || dualAnalysis.impact.measurementsExcluded > 0 ? `
    <div style="background: rgba(255, 193, 7, 0.2); padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107;">
        <strong>Filtering Impact:</strong><br>
        ${dualAnalysis.impact.animalsExcluded > 0 ? `• ${dualAnalysis.impact.animalsExcluded} excluded animals<br>` : ''}
        ${dualAnalysis.impact.measurementsExcluded > 0 ? `• ${dualAnalysis.impact.measurementsExcluded} problematic measurements<br>` : ''}
    </div>
    ` : ''}
</div>
            `;

            // Recomendaciones
            // Recomendaciones específicas
            if (outlierAnalysis.specificRecommendations && outlierAnalysis.specificRecommendations.length > 0) {
                html += '<div style="margin: 15px 0;"><h3 style="color: #4facfe;">Specific Recommendations</h3>';

                outlierAnalysis.specificRecommendations.forEach((rec, index) => {
                    let bgColor, borderColor, icon;

                    switch (rec.type) {
                        case 'warning':
                            bgColor = 'rgba(255, 193, 7, 0.1)';
                            borderColor = '#ffc107';
                            icon = '⚠️';
                            break;
                        case 'info':
                            bgColor = 'rgba(33, 150, 243, 0.1)';
                            borderColor = '#2196f3';
                            icon = 'ℹ️';
                            break;
                        default:
                            bgColor = 'rgba(76, 175, 80, 0.1)';
                            borderColor = '#4caf50';
                            icon = '✅';
                    }

                    html += `
                        <div style="background: ${bgColor}; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid ${borderColor};">
                            <div style="display: flex; align-items: flex-start; gap: 10px;">
                                <span style="font-size: 1.2rem;">${icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; margin-bottom: 5px; color: ${borderColor};">
                                        ${rec.title} (${rec.category})
                                    </div>
                                    <div style="margin-bottom: 8px; font-size: 0.95rem;">
                                        ${rec.message}
                                    </div>
                                    <div style="font-style: italic; color: white; font-size: 0.95rem; background: rgba(255,255,255,0.1); padding: 8px; border-radius: 4px;">
                                        <strong>Recommendation:</strong> ${rec.recommendation}
                                    </div>
                                    ${rec.affectedAnimals && rec.affectedAnimals.length > 0 ? `
                                        <div style="margin-top: 8px; font-size: 0.95rem; color: #f8f8f8;">
                                            <strong>Affected animals:</strong> ${rec.affectedAnimals.slice(0, 5).join(', ')}${rec.affectedAnimals.length > 5 ? ` (+${rec.affectedAnimals.length - 5} más)` : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            if (outlierAnalysis.recommendations.length > 0) {
                html += '<div style="margin: 15px 0;"><h3 style="color: #4facfe;">Recommendations</h3>';
                outlierAnalysis.recommendations.forEach(rec => {
                    const bgColor = rec.type === 'success' ? 'rgba(76, 175, 80, 0.1)' :
                        rec.type === 'warning' ? 'rgba(255, 193, 7, 0.1)' :
                            'rgba(33, 150, 243, 0.1)';
                    const borderColor = rec.type === 'success' ? '#4caf50' :
                        rec.type === 'warning' ? '#ffc107' : '#2196f3';

                    html += `
                        <div style="background: ${bgColor}; padding: 12px; border-radius: 8px; margin: 8px 0; border-left: 4px solid ${borderColor};">
                            <strong>${rec.title}:</strong> ${rec.message}
                        </div>
                    `;
                });
                html += '</div>';
            }

            card.innerHTML = html;

            // Insertar al principio de los resultados
            resultsDiv.insertBefore(card, resultsDiv.firstChild);
        }

        function showOutlierDetails() {
            if (!outlierAnalysis) return;

            const modal = document.createElement('div');
            modal.id = 'outlierModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
                box-sizing: border-box;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 30px;
                max-width: 90vw;
                max-height: 85vh;
                overflow-y: auto;
                position: relative;
                color: #333;
            `;

            let detailsHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #f0f0f0; padding-bottom: 15px;">
                    <h2 style="margin: 0; color: #2c3e50;">Complete Outlier Details</h2>
                    <button onclick="closeOutlierModal()" style="background: #e74c3c; color: white; border: none; border-radius: 50%; width: 35px; height: 35px; cursor: pointer; font-size: 18px;">×</button>
                </div>
            `;

            if (outlierAnalysis.flags.length > 0) {
                detailsHTML += `
                    <h3 style="color: #34495e; margin-bottom: 15px;">Detected Anomalies (${outlierAnalysis.flags.length})</h3>
                    <div style="overflow-x: auto; margin-bottom: 25px;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                            <thead>
                                <tr style="background: #34495e; color: white;">
                                    <th style="padding: 12px; text-align: center;">Animal</th>
                                    <th style="padding: 12px; text-align: center;">Group</th>
                                    <th style="padding: 12px; text-align: center;">Day</th>
                                    <th style="padding: 12px; text-align: center;">Value</th>
                                    <th style="padding: 12px; text-align: center;">Type</th>
                                    <th style="padding: 12px; text-align: center;">Severity</th>
                                    <th style="padding: 12px; text-align: center;">Description</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                outlierAnalysis.flags.forEach((flag, index) => {
                    const flagInfo = FLAG_TYPES[flag.type];
                    const rowColor = index % 2 === 0 ? '#f8f9fa' : 'white';

                    detailsHTML += `
                        <tr style="background: ${rowColor};">
                            <td style="padding: 10px; border-bottom: 1px solid #dee2e6; font-weight: 500;">${flag.animalId}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #dee2e6;">${flag.group}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #dee2e6; text-align: center;">${flag.day}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #dee2e6; text-align: right; font-family: monospace;">
                                ${typeof flag.value === 'number' ? 
                                (flag.value >= 10000 ? flag.value.toExponential(2) : flag.value.toFixed(2)) : 
                                flag.value}
                                </td>
                            <td style="padding: 10px; border-bottom: 1px solid #dee2e6;">
                                <span style="background: ${flagInfo.color}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 0.8rem; font-weight: 500;">
                                    ${flagInfo.name}
                                </span>
                            </td>
                            <td style="padding: 10px; border-bottom: 1px solid #dee2e6; text-transform: capitalize; font-weight: 500;">${flagInfo.severity}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #dee2e6; font-size: 0.85rem;">${flag.message}</td>
                        </tr>
                    `;
                });

                detailsHTML += `
                            </tbody>
                        </table>
                    </div>
                `;
            } else {
                detailsHTML += `
                    <div style="background: #d4edda; color: #155724; padding: 15px; border-radius: 8px; margin: 15px 0; border: 1px solid #c3e6cb;">
                        <strong>Excellent data quality:</strong> No significant anomalies detected.
                    </div>
                `;
            }

            detailsHTML += `
                <div style="text-align: center; margin-top: 25px; padding-top: 20px; border-top: 1px solid #dee2e6;">
                    <button onclick="exportOutlierReport()" style="background: #17a2b8; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin-right: 10px;">
                        📄 Export Report
                    </button>
                    <button onclick="closeOutlierModal()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;

            modalContent.innerHTML = detailsHTML;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Cerrar modal al hacer click fuera
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeOutlierModal();
            });
        }

        function closeOutlierModal() {
            const modal = document.getElementById('outlierModal');
            if (modal) modal.remove();
        }

        function exportOutlierReport() {
            if (!outlierAnalysis) return;

            let report = `# Outlier Analysis Report - ViVo\n`;
            report += `Date: ${new Date().toLocaleString('en-US')}\n`;
            report += `Configuration: ${outlierAnalysis.summary.configUsed}\n\n`;

            report += `## Executive Summary\n`;
            report += `- Total detected anomalies: ${outlierAnalysis.summary.totalFlags}\n`;
            report += `- Critical anomalies: ${outlierAnalysis.summary.severityCounts.critical}\n`;
            report += `- High severity anomalies: ${outlierAnalysis.summary.severityCounts.high}\n`;
            report += `- Animals in complete analysis: ${outlierAnalysis.dualAnalysis.complete.count}\n`;
            report += `- Animals after filtering: ${outlierAnalysis.dualAnalysis.filtered.count}\n\n`;

            if (outlierAnalysis.flags.length > 0) {
                report += `## Anomaly Details\n`;
                outlierAnalysis.flags.forEach((flag, index) => {
                    const flagInfo = FLAG_TYPES[flag.type];
                    report += `${index + 1}. ${flag.animalId} (${flag.group}) - Day ${flag.day}\n`;
                    report += `   Type: ${flagInfo.name} (${flagInfo.severity})\n`;
                    report += `   Value: ${flag.value}\n`;
                    report += `   Description: ${flag.message}\n\n`;
                });
            }

            report += `## Recommendations\n`;
            outlierAnalysis.recommendations.forEach((rec, index) => {
                report += `${index + 1}. ${rec.title}: ${rec.message}\n`;
            });

            // Download file
            const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `outlier_report_${new Date().toISOString().slice(0, 10)}.txt`;
            link.click();

            showNotification('Outlier report exported', 'success');
        }

        function updateOutlierConfig() {
            const configSelect = document.getElementById('outlierConfig');
            const selectedConfig = configSelect.value;

            if (selectedConfig === 'auto') {
                // If auto is selected, recalculate based on current data
                if (rawData.length > 0) {
                    initializeOutlierDetector();
                    showNotification(`Auto configuration updated based on ${rawData.length} animals`, 'info');
                } else {
                    showNotification('Auto configuration: load data first for automatic adjustment', 'info');
                }
            } else {
                // Manual configuration
                outlierDetector = new IntelligentOutlierDetector(selectedConfig);
                showNotification(`Configuration updated: ${OUTLIER_CONFIGS[selectedConfig].name}`, 'info');
            }
        }
        //********

        //UI functions
        function cycleThroughStates() {
            const button = document.getElementById('cyclicBtn');

            // Avanzar al siguiente estado
            currentState = (currentState + 1) % states.length;

            // Actualizar el botón (texto estático)
            const state = states[currentState];
            button.innerHTML = state.text;
            button.style.cssText = state.style + " margin-right: 10px;";

            // Ejecutar la acción correspondiente
            state.action();

            // Actualizar el box activo
            setTimeout(() => updateActiveAnalysisBox(), 100);
        }

        function updateActiveAnalysisBox() {
            // Remover clase 'active' de todos los boxes
            document.querySelectorAll('.analysis-box').forEach(box => {
                box.classList.remove('active');
            });

            // Determinar qué box debe estar activo basado en currentState
            let activeBoxClass;
            switch (currentState) {
                case 0:
                    activeBoxClass = '.complete-analysis';
                    break;
                case 1:
                    activeBoxClass = '.filtered-analysis';
                    break;
                case 2:
                    activeBoxClass = '.points-filtered-analysis';
                    break;
                default:
                    activeBoxClass = '.complete-analysis';
            }

            // Add 'active' class to corresponding box
            const activeBox = document.querySelector(activeBoxClass);
            if (activeBox) {
                activeBox.classList.add('active');
            }
        }

        function initializeActiveBox() {
            // Establecer el box inicial como activo (estado 0 por defecto)
            updateActiveAnalysisBox();
        }

        function getStateText(stateIndex) {
            if (!outlierAnalysis) {
                // Textos por defecto cuando no hay análisis
                const defaultTexts = [
                    "All data",
                    "Filtered animals",
                    "Filtered points"
                ];
                return defaultTexts[stateIndex];
            }

            // Textos con contadores cuando hay análisis disponible
            switch (stateIndex) {
                case 0:
                    const totalAnimals = outlierAnalysis.dualAnalysis.complete.count;
                    const totalPoints = outlierAnalysis.dualAnalysis.complete.totalMeasurements;
                    return `All data (${totalAnimals} animals, ${totalPoints} points)`;

                case 1:
                    const excludedAnimals = outlierAnalysis.dualAnalysis.impact.animalsExcluded;
                    const remainingAnimals = outlierAnalysis.dualAnalysis.filtered.count;
                    const remainingPoints = outlierAnalysis.dualAnalysis.filtered.totalMeasurements;
                    return `Filtered animals (-${excludedAnimals} animals | ${remainingAnimals} remaining, ${remainingPoints} points)`;

                case 2:
                    // Asegurar que el análisis de puntos existe
                    if (!outlierAnalysis.pointFilteringAnalysis) {
                        outlierAnalysis.pointFilteringAnalysis = outlierDetector.performPointFilteringAnalysis(
                            outlierAnalysis.dualAnalysis.complete.animals
                        );
                    }
                    const excludedPoints = outlierAnalysis.pointFilteringAnalysis.excludedPoints;
                    const remainingPointsFiltered = outlierAnalysis.pointFilteringAnalysis.totalPointsFiltered;
                    const totalAnimalsInPoints = outlierAnalysis.pointFilteringAnalysis.animals.length;
                    return `Filtered points (-${excludedPoints} points | ${totalAnimalsInPoints} animals, ${remainingPointsFiltered} points)`;

                default:
                    return "Unknown state";
            }
        }

        function reprocessDataWithOutlierSelection(selectedAnimals) {
            debugLog('Reprocessing data with outlier selection');
            // Reset variables
            animalModels = {};
            processedData = {
                validAnimals: [],
                invalidAnimals: [],
                groupStats: {},
                dataType: processedData.dataType
            };

            const threshold = parseFloat(document.getElementById('r2Threshold').value);

            // Procesar animales seleccionados
            let validCount = 0;
            let invalidCount = 0;

            selectedAnimals.forEach(animal => {
                if (animal.timePoints.length >= 3) {
                    const model = fitExponentialModel(animal.timePoints, animal.measurements);
                    const animalData = {
                        id: animal.id,
                        group: animal.group,
                        timePoints: animal.timePoints,
                        measurements: animal.measurements,
                        model: model,
                        dataType: processedData.dataType
                    };

                    if (model.r2 >= threshold) {
                        animalModels[animal.id] = animalData;
                        processedData.validAnimals.push(animalData);
                        validCount++;
                    } else {
                        processedData.invalidAnimals.push(animalData);
                        invalidCount++;
                    }
                }
            });

            // Recalcular estadísticas de grupo
            calculateGroupStats();

            // Actualizar visualización
            updateResultsAfterOutlierProcessing();
        }

        function updateResultsAfterOutlierProcessing() {
            // Eliminar resultados anteriores (excepto el panel de outliers)
            const resultsDiv = document.getElementById('results');
            const existingCards = resultsDiv.querySelectorAll('.result-card:not(#outlierCard)');
            existingCards.forEach(card => card.remove());

            // Regenerar resultados
            if (processedData.validAnimals.length > 0) {
                createSummaryCard();
                createGroupStatsCard();
                createParameterTable();
                createStatisticalComparisonCard();
                createMainChart();
                createNormalizedGrowthChart();
            }
        }
        //**********************

        // Function to show data preview
        function showDataPreview() {
            if (rawData.length === 0) {
                showNotification('No data loaded to display', 'warning');
                return;
            }

            const resultsDiv = document.getElementById('results');

            let previewCard = document.getElementById('previewCard');
            if (!previewCard) {
                previewCard = document.createElement('div');
                previewCard.id = 'previewCard';
                previewCard.className = 'result-card';
                resultsDiv.appendChild(previewCard);
            }

            const columns = Object.keys(rawData[0]);
            const preview = rawData.slice(0, 5);

            let html = '<h2>Loaded Data Preview</h2>';
            html += `<p><strong>Total rows:</strong> ${rawData.length}</p>`;
            html += `<p><strong>Total columns:</strong> ${columns.length}</p>`;
            html += '<h3>First 5 rows:</h3>';
            html += '<table><thead><tr>';

            columns.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '</tr></thead><tbody>';

            preview.forEach((row, idx) => {
                html += `<tr>`;
                columns.forEach(col => {
                    html += `<td>${row[col] || ''}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';

            previewCard.innerHTML = html;
            showNotification('Data preview displayed', 'success');
        }

        // Función para análisis completo de datos
        function analyzeData() {
            if (rawData.length === 0) {
                showNotification('Please load a CSV file first', 'warning');
                return;
            }

            showNotification('Analyzing data...', 'info');

            const threshold = parseFloat(document.getElementById('r2Threshold').value);
            const dataType = document.getElementById('dataType').value;

            // Reset data
            animalModels = {};
            processedData = {
                validAnimals: [],
                invalidAnimals: [],
                groupStats: {},
                dataType: dataType
            };

            const parsed = parseAnimalData(rawData);
            const animalsForOutlierAnalysis = parsed.animals;
            dayColumns = parsed.dayColumns;


            // PASO 2: Ejecutar análisis de outliers PRIMERO
            if (!outlierDetector) {
                initializeOutlierDetector();
            }

            outlierAnalysis = outlierDetector.analyzeDataset(animalsForOutlierAnalysis, dataType);

            // STEP 3: Decide which data to use based on current configuration
            let dataToProcess;

            if (usePointFiltering) {
                // Use individual point filtering
                if (!outlierAnalysis.pointFilteringAnalysis) {
                    outlierAnalysis.pointFilteringAnalysis = outlierDetector.performPointFilteringAnalysis(
                        outlierAnalysis.dualAnalysis.complete.animals
                    );
                }
                dataToProcess = outlierAnalysis.pointFilteringAnalysis.animals;
                debugLog(`Using point filtering: ${outlierAnalysis.pointFilteringAnalysis.excludedPoints} points excluded`);
            } else if (useFilteredData) {
                // Use complete animal filtering
                dataToProcess = outlierAnalysis.dualAnalysis.filtered.animals;
                debugLog(`Using filtered data: ${outlierAnalysis.dualAnalysis.impact.animalsExcluded} animals excluded`);
            } else {
                // Use complete data (for comparison only)
                dataToProcess = outlierAnalysis.dualAnalysis.complete.animals;
                debugLog('Using complete data (no outlier filtering)');
            }

            // PASO 4: Calcular modelos exponenciales CON LOS DATOS YA FILTRADOS
            let validCount = 0;
            let invalidCount = 0;

            dataToProcess.forEach(animal => {
                // Verify we still have enough points after filtering
                if (animal.timePoints.length >= 3) {
                    // Calcular modelo con datos filtrados
                    const model = fitExponentialModel(animal.timePoints, animal.measurements);
                    const animalData = {
                        id: animal.id,
                        group: animal.group,
                        timePoints: animal.timePoints,
                        measurements: animal.measurements,
                        model: model,
                        dataType: dataType,
                        // Additional information about filtering
                        originalPoints: animalsForOutlierAnalysis.find(a => a.id === animal.id)?.timePoints.length || animal.timePoints.length,
                        filteredPoints: animal.excludedPoints?.length || 0
                    };

                    // PASO 5: Aplicar filtro R² a los datos YA FILTRADOS
                    if (model.r2 >= threshold) {
                        animalModels[animal.id] = animalData;
                        processedData.validAnimals.push(animalData);
                        validCount++;
                    } else {
                        processedData.invalidAnimals.push(animalData);
                        invalidCount++;
                    }
                } else {
                    // Animal descartado por tener muy pocos puntos después del filtrado
                    const animalData = {
                        id: animal.id,
                        group: animal.group,
                        timePoints: animal.timePoints,
                        measurements: animal.measurements,
                        model: { a: 0, r: 0, r2: 0 },
                        dataType: dataType,
                        reason: 'Insufficient points after filtering'
                    };
                    processedData.invalidAnimals.push(animalData);
                    invalidCount++;
                }
            });

            // Calculate group statistics
            calculateGroupStats();

            // Display results
            displayResults();

            // Mensaje informativo sobre el filtrado aplicado
            let filterMessage = '';
            if (usePointFiltering) {
                filterMessage = ` (with filtering of ${outlierAnalysis.pointFilteringAnalysis.excludedPoints} points)`;
            } else if (useFilteredData) {
                filterMessage = ` (with ${outlierAnalysis.dualAnalysis.impact.animalsExcluded} filtered animals)`;
            }

            showNotification(`Analysis completed: ${validCount} valid, ${invalidCount} discarded${filterMessage}`, 'success');

            // Show outliers panel
            displayOutlierPanel();
            initializeActiveBox();
        }

        // Función para ajuste exponencial
        function fitExponentialModel(x, y) {
            const n = x.length;
            const lnY = y.map(v => {
                if (v <= 0) {
                    console.warn(`Invalid value for logarithm: ${v}. Using minimum positive value.`);
                    return Math.log(Number.MIN_VALUE);
                }
                return Math.log(v);
            });

            const sumX = x.reduce((a, b) => a + b, 0);
            const sumLnY = lnY.reduce((a, b) => a + b, 0);
            const sumXLnY = x.reduce((sum, xi, i) => sum + xi * lnY[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);

            const denominator = n * sumX2 - sumX * sumX;
            const r = denominator !== 0 ? (n * sumXLnY - sumX * sumLnY) / denominator : 0;
            const lnA = (sumLnY - r * sumX) / n;
            const a = Math.exp(lnA);

            const meanLnY = sumLnY / n;
            const ssTot = lnY.reduce((sum, yi) => sum + Math.pow(yi - meanLnY, 2), 0);
            const ssRes = lnY.reduce((sum, yi, i) => sum + Math.pow(yi - (lnA + r * x[i]), 2), 0);
            const r2 = 1 - (ssRes / ssTot);

            return { a, r, r2 };
        }

        // Función para calcular estadísticas de grupo
        function calculateGroupStats() {
            processedData.groupStats = {};

            [...processedData.validAnimals, ...processedData.invalidAnimals].forEach(animal => {
                if (!processedData.groupStats[animal.group]) {
                    processedData.groupStats[animal.group] = {
                        valid: 0,
                        invalid: 0,
                        validAnimals: [],
                        avgR: 0,
                        avgR2: 0,
                        avgA: 0,
                        stdR: 0,
                        stdA: 0,
                        seR: 0,
                        seA: 0
                    };
                }
            });

            // Count valid and invalid
            processedData.validAnimals.forEach(animal => {
                processedData.groupStats[animal.group].valid++;
                processedData.groupStats[animal.group].validAnimals.push(animal);
            });

            processedData.invalidAnimals.forEach(animal => {
                processedData.groupStats[animal.group].invalid++;
            });

            // Calculate statistics for valid animals
            Object.keys(processedData.groupStats).forEach(group => {
                const stats = processedData.groupStats[group];
                const validInGroup = stats.validAnimals;

                if (validInGroup.length > 0) {
                    // Averages
                    stats.avgR = validInGroup.reduce((sum, a) => sum + a.model.r, 0) / validInGroup.length;
                    stats.avgR2 = validInGroup.reduce((sum, a) => sum + a.model.r2, 0) / validInGroup.length;
                    stats.avgA = validInGroup.reduce((sum, a) => sum + a.model.a, 0) / validInGroup.length;

                    // Standard deviations and standard errors
                    if (validInGroup.length > 1) {
                        stats.stdR = Math.sqrt(
                            validInGroup.reduce((sum, a) => sum + Math.pow(a.model.r - stats.avgR, 2), 0) / (validInGroup.length - 1)
                        );
                        stats.stdA = Math.sqrt(
                            validInGroup.reduce((sum, a) => sum + Math.pow(a.model.a - stats.avgA, 2), 0) / (validInGroup.length - 1)
                        );
                        stats.seR = stats.stdR / Math.sqrt(validInGroup.length);
                        stats.seA = stats.stdA / Math.sqrt(validInGroup.length);
                    } else {
                        stats.seR = 0;
                        stats.seA = 0;
                    }
                }
            });

            debugLog('Group statistics calculated:', processedData.groupStats);
        }

        // Statistical comparison functions for r values
        function performStatisticalComparison() {
            const groups = Object.keys(processedData.groupStats);
            const comparisons = [];

            // Perform pairwise comparisons between all groups
            for (let i = 0; i < groups.length; i++) {
                for (let j = i + 1; j < groups.length; j++) {
                    const group1 = groups[i];
                    const group2 = groups[j];
                    const stats1 = processedData.groupStats[group1];
                    const stats2 = processedData.groupStats[group2];

                    // Only compare groups with valid animals
                    if (stats1.validAnimals.length > 1 && stats2.validAnimals.length > 1) {
                        const comparison = compareGroups(group1, group2, stats1, stats2);
                        comparisons.push(comparison);
                    }
                }
            }

            return comparisons;
        }

        function compareGroups(group1Name, group2Name, stats1, stats2) {
            // Extract r values for each group
            const rValues1 = stats1.validAnimals.map(animal => animal.model.r);
            const rValues2 = stats2.validAnimals.map(animal => animal.model.r);

            // Perform Mann-Whitney U test
            const mannWhitneyResult = mannWhitneyUTest(rValues1, rValues2);

            // Calculate Cohen's d effect size
            const pooledStd = Math.sqrt(((rValues1.length - 1) * Math.pow(stats1.stdR, 2) + (rValues2.length - 1) * Math.pow(stats2.stdR, 2)) / (rValues1.length + rValues2.length - 2));
            const cohensD = Math.abs(stats1.avgR - stats2.avgR) / pooledStd;

            // Calculate median values for better representation of non-parametric data
            const median1 = calculateMedian(rValues1);
            const median2 = calculateMedian(rValues2);
            const medianDiff = median1 - median2;

            return {
                group1: group1Name,
                group2: group2Name,
                n1: rValues1.length,
                n2: rValues2.length,
                mean1: stats1.avgR,
                mean2: stats2.avgR,
                median1: median1,
                median2: median2,
                std1: stats1.stdR,
                std2: stats2.stdR,
                meanDiff: stats1.avgR - stats2.avgR,
                medianDiff: medianDiff,
                UStatistic: mannWhitneyResult.U,
                zStatistic: mannWhitneyResult.z,
                pValue: mannWhitneyResult.p,
                cohensD: cohensD,
                effectSize: getEffectSizeLabel(cohensD),
                significant: mannWhitneyResult.p < 0.05
            };
        }

        function calculateMedian(values) {
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 
                ? (sorted[mid - 1] + sorted[mid]) / 2 
                : sorted[mid];
        }

        function mannWhitneyUTest(sample1, sample2) {
            const n1 = sample1.length;
            const n2 = sample2.length;
            
            // Combine samples with group labels
            const combined = [];
            sample1.forEach(val => combined.push({value: val, group: 1}));
            sample2.forEach(val => combined.push({value: val, group: 2}));
            
            // Sort by value
            combined.sort((a, b) => a.value - b.value);
            
            // Assign ranks (handle ties)
            let ranks = [];
            let i = 0;
            while (i < combined.length) {
                let j = i;
                // Find all values equal to current value
                while (j < combined.length && combined[j].value === combined[i].value) {
                    j++;
                }
                // Assign average rank to tied values
                const avgRank = (i + 1 + j) / 2;
                for (let k = i; k < j; k++) {
                    ranks.push(avgRank);
                }
                i = j;
            }
            
            // Calculate rank sums
            let R1 = 0, R2 = 0;
            for (let i = 0; i < combined.length; i++) {
                if (combined[i].group === 1) {
                    R1 += ranks[i];
                } else {
                    R2 += ranks[i];
                }
            }
            
            // Calculate U statistics
            const U1 = R1 - (n1 * (n1 + 1)) / 2;
            const U2 = R2 - (n2 * (n2 + 1)) / 2;
            const U = Math.min(U1, U2);
            
            // Calculate z-score for normal approximation (when n1, n2 > 20)
            const meanU = (n1 * n2) / 2;
            
            // Calculate tie correction
            const N = n1 + n2;
            let tieCorrection = 0;
            let tieIndex = 0;
            while (tieIndex < combined.length) {
                let tieEnd = tieIndex;
                while (tieEnd < combined.length && combined[tieEnd].value === combined[tieIndex].value) {
                    tieEnd++;
                }
                const tieCount = tieEnd - tieIndex;
                if (tieCount > 1) {
                    tieCorrection += Math.pow(tieCount, 3) - tieCount;
                }
                tieIndex = tieEnd;
            }
            
            // Standard deviation with tie correction
            const stdU = Math.sqrt((n1 * n2 * (N + 1 - tieCorrection / (N * (N - 1)))) / 12);
            
            // Apply continuity correction
            const z = stdU > 0 ? Math.abs(U - meanU - 0.5) / stdU : 0;
            
            // Two-tailed p-value
            const p = 2 * (1 - normalCDF(z));
            
            return { 
                U: U, 
                U1: U1, 
                U2: U2, 
                z: z, 
                p: p, 
                R1: R1, 
                R2: R2 
            };
        }

        function normalCDF(z) {
            // Approximation of standard normal CDF
            return 0.5 * (1 + erf(z / Math.sqrt(2)));
        }

        function erf(x) {
            // Approximation of error function
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;

            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);

            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

            return sign * y;
        }

        function getEffectSizeLabel(cohensD) {
            if (cohensD < 0.2) return 'Negligible';
            if (cohensD < 0.5) return 'Small';
            if (cohensD < 0.8) return 'Medium';
            return 'Large';
        }

        function getEffectSizeLabelR(r) {
            // Effect size interpretation for r = Z/sqrt(N)
            if (r < 0.1) return 'Negligible';
            if (r < 0.3) return 'Small';
            if (r < 0.5) return 'Medium';
            return 'Large';
        }

        function getAsteriskNotation(pValue) {
            // Standard asterisk notation for p-values
            if (pValue < 0.001) return '***';
            if (pValue < 0.01) return '**';
            if (pValue < 0.05) return '*';
            return '';
        }

        // Function to show results
        function displayResults() {
            const resultsDiv = document.getElementById('results');

            // Limpiar resultados previos (excepto debug info)
            resultsDiv.innerHTML = '';

            if (outlierAnalysis) {
                displayOutlierPanel();
                initializeActiveBox();
            }

            // Summary statistics
            createSummaryCard();

            // Group statistics
            createGroupStatsCard();

            // Parameter table
            if (processedData.validAnimals.length > 0) {
                createParameterTable();
            }

            // Statistical comparison of r values
            createStatisticalComparisonCard();

            createMainChart();
            createNormalizedGrowthChart();
        }

        // Function to create summary card
        function createSummaryCard() {
            const card = document.createElement('div');
            card.className = 'result-card';

            const totalAnimals = processedData.validAnimals.length + processedData.invalidAnimals.length;
            const validPercentage = totalAnimals > 0 ? (processedData.validAnimals.length / totalAnimals * 100).toFixed(1) : 0;

            card.innerHTML = `
                <h2>Analysis Summary</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1rem 0;">
                    <div style="background: rgba(79, 172, 254, 0.2); padding: 1rem; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: bold; color: #4facfe;">${totalAnimals}</div>
                        <div style="color: #a0a0a0;">Total Animals</div>
                    </div>
                    <div style="background: rgba(0, 242, 254, 0.2); padding: 1rem; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: bold; color: #00f2fe;">${processedData.validAnimals.length}</div>
                        <div style="color: #a0a0a0;">Valid Animals</div>
                    </div>
                    <div style="background: rgba(250, 112, 154, 0.2); padding: 1rem; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: bold; color: #fa709a;">${validPercentage}%</div>
                        <div style="color: #a0a0a0;">Validity Rate</div>
                    </div>
                    <div style="background: rgba(254, 225, 64, 0.2); padding: 1rem; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: bold; color: #fee140;">${Object.keys(processedData.groupStats).length}</div>
                        <div style="color: #a0a0a0;">Detected Groups</div>
                    </div>
                </div>
            `;

            document.getElementById('results').appendChild(card);
        }

        // Función para crear tarjeta de estadísticas de grupo
        function createGroupStatsCard() {
            const card = document.createElement('div');
            card.className = 'result-card';

            const dataType = processedData.dataType;
            const paramLabel = dataType === 'volume' ? 'V₀' : 'BLI₀';
            const unitLabel = dataType === 'volume' ? ' mm³' : '';

            let html = '<h2>Group Statistics</h2>';
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">';

            Object.entries(processedData.groupStats).forEach(([group, stats]) => {
                const total = stats.valid + stats.invalid;
                const validPercentage = total > 0 ? (stats.valid / total * 100).toFixed(1) : 0;

                // Calculate relative errors (standard error/mean * 100)
                const relErrorR = stats.avgR !== 0 && stats.seR > 0 ?
                    (stats.seR / Math.abs(stats.avgR) * 100).toFixed(1) : '0.0';
                const relErrorA = stats.avgA !== 0 && stats.seA > 0 ?
                    (stats.seA / Math.abs(stats.avgA) * 100).toFixed(1) : '0.0';

                const avgAValue = dataType === 'bli' ?
                    stats.avgA.toExponential(2) :
                    stats.avgA.toFixed(2);

                html += `
                    <div style="background: rgba(255, 255, 255, 0.08); padding: 1.5rem; border-radius: 15px;">
                        <div style="font-weight: 600; color: #00f2fe; margin-bottom: 0.5rem; font-size: 1.1rem;">${group}</div>
                        <div style="font-size: 1.5rem; font-weight: 700; color: #4facfe;">${stats.valid}/${total}</div>
                        <div style="color: #a0a0a0; font-size: 1.05rem; margin-bottom: .85rem;">Valid (${validPercentage}%)</div>
                        ${stats.valid > 0 ? `
                            <div style="font-size: 1.0rem; line-height: 1.5;">
                                <div>r: ${stats.avgR.toFixed(4)} ± ${relErrorR}%</div>
                                <div>R²: ${stats.avgR2.toFixed(4)}</div>
                                <div>${paramLabel}: ${avgAValue}${unitLabel} ± ${relErrorA}%</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            html += '</div>';
            card.innerHTML = html;

            document.getElementById('results').appendChild(card);
        }

        // Función para crear tabla de parámetros
        function createParameterTable() {
            const card = document.createElement('div');
            card.className = 'result-card';

            const dataType = processedData.dataType;
            const paramLabel = dataType === 'volume' ? 'V₀' : 'BLI₀';
            const unitLabel = dataType === 'volume' ? 'mm³' : '';

            let html = '<h2>Exponential Model Parameters</h2>';
            html += `
            <div style="overflow-x: auto;">
                <table>
                    <thead>
                        <tr>
                            <th style="text-align: left;">Animal ID</th>
                            <th>Group</th>
                            <th>${paramLabel}${unitLabel ? ` (${unitLabel})` : ''}</th>
                            <th>r (day⁻¹)</th>
                            <th>R²</th>
                            <th>Doubling time (days)</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            processedData.validAnimals.forEach((animal, index) => {
                const doublingTime = (animal.model.r && animal.model.r > 0) ? Math.log(2) / animal.model.r : Infinity;
                const a0Value = dataType === 'bli' ?
                    animal.model.a.toExponential(3) :
                    animal.model.a.toFixed(2);

                html += `
                    <tr>
                        <td style="text-align: left;">${animal.id}</td>
                        <td>${animal.group}</td>
                        <td>${a0Value}</td>
                        <td>${animal.model.r.toFixed(4)}</td>
                        <td>${animal.model.r2.toFixed(3)}</td>
                        <td>${doublingTime.toFixed(1)}</td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            card.innerHTML = html;

            document.getElementById('results').appendChild(card);
        }

        // Función para crear tarjeta de comparación estadística
        function createStatisticalComparisonCard() {
            const groups = Object.keys(processedData.groupStats);
            
            // Only show comparison if there are 2 or more groups with valid animals
            const validGroups = groups.filter(group => 
                processedData.groupStats[group].validAnimals.length > 1
            );
            
            if (validGroups.length < 2) {
                return; // Don't show card if insufficient data for comparison
            }

            const card = document.createElement('div');
            card.className = 'result-card';

            let html = `
                <h2>Statistical Comparison of Growth Rates (r values)</h2>
                <p style="color: #a0a0a0; margin-bottom: 1rem;">Pairwise comparisons using Mann-Whitney U test</p>
            `;

            // Perform statistical comparisons
            const comparisons = performStatisticalComparison();

            if (comparisons.length === 0) {
                html += '<p style="color: #ffa500;">No valid comparisons possible with current data.</p>';
            } else {
                html += `
                    <div style="overflow-x: auto;">
                        <table>
                            <thead>
                                <tr>
                                    <th style="text-align: left">Comparison</th>
                                    <th>Group 1 (n)</th>
                                    <th>Group 2 (n)</th>
                                    <th>Median Diff</th>
                                    <th>U-statistic</th>
                                    <th>Z-statistic</th>
                                    <th>p-value</th>
                                    <th>Effect Size</th>
                                    <th>Significance</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                comparisons.forEach(comp => {
                    const significanceColor = comp.significant ? '#00f2fe' : '#a0a0a0';
                    const significanceText = comp.significant ? 'Significant' : 'Not significant';
                    const pValueText = comp.pValue < 0.001 ? '<0.001' : comp.pValue.toFixed(3);
                    const asterisks = getAsteriskNotation(comp.pValue);
                    
                    html += `
                        <tr>
                            <td style="font-weight: bold; text-align: left;">${comp.group1} vs ${comp.group2}</td>
                            <td>${comp.median1.toFixed(4)} (${comp.n1})</td>
                            <td>${comp.median2.toFixed(4)} (${comp.n2})</td>
                            <td style="color: ${comp.medianDiff > 0 ? '#4facfe' : '#ff6b6b'};">
                                ${comp.medianDiff > 0 ? '+' : ''}${comp.medianDiff.toFixed(4)}
                            </td>
                            <td>${comp.UStatistic.toFixed(1)}</td>
                            <td>${comp.zStatistic.toFixed(3)}</td>
                            <td style="color: ${significanceColor}; font-weight: bold;">
                            ${pValueText}${asterisks ? ` (${asterisks})` : ''}
                            </td>
                            </td>
                            <td>
                                ${comp.effectSize}<br>
                                <small style="color: #a0a0a0;">(d=${comp.cohensD.toFixed(3)})</small>
                            </td>
                            <td style="color: ${significanceColor}; font-weight: bold;">
                                ${significanceText}
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(79, 172, 254, 0.1); border-radius: 8px; border: 1px solid rgba(79, 172, 254, 0.3);">
                        <h4 style="margin: 0 0 0.5rem 0; color: #4facfe;">Statistical Notes:</h4>
                        <ul style="margin: 0; padding-left: 1.5rem; color: #a0a0a0; font-size: 0.9rem;">
                            <li>Two-tailed Mann-Whitney U test (non-parametric, rank-based)</li>
                            <li>Significance level: α = 0.05</li>
                            <li>Effect size (Cohen's d): Small=0.2, Medium=0.5, Large=0.8</li>
                            <li>U = Mann-Whitney U statistic, Z = standardized test statistic</li>
                            <li>Medians reported instead of means for non-parametric analysis</li>
                        </ul>
                    </div>
                `;
            }

            card.innerHTML = html;
            document.getElementById('results').appendChild(card);
        }

        // Función para crear gráfica principal
        function createMainChart() {
            const card = document.createElement('div');
            card.className = 'result-card';

            card.innerHTML = `
                <h2>Exponential Growth Curves</h2>
                <div id="mainChart" style="width: 100%; height: 500px;"></div>
            `;

            document.getElementById('results').appendChild(card);

            // Crear las trazas para Plotly
            const traces = [];
            const colors = ['#4facfe', '#00f2fe', '#fa709a', '#fee140', '#a8edea', '#fed6e3'];
            const groups = [...new Set(processedData.validAnimals.map(a => a.group))];

            groups.forEach((group, idx) => {
                const groupAnimals = processedData.validAnimals.filter(a => a.group === group);
                const groupColor = colors[idx % colors.length];

                // Datos individuales como puntos
                groupAnimals.forEach(animal => {
                    const dataType = processedData.dataType;
                    const unitLabel = dataType === 'volume' ? ' mm³' : '';

                    traces.push({
                        x: animal.timePoints,
                        y: animal.measurements,
                        mode: 'markers',
                        name: animal.id,
                        legendgroup: group,
                        marker: {
                            color: groupColor,
                            size: 8,
                            symbol: 'circle'
                        },
                        showlegend: false,
                        hovertemplate: `<b>Animal:</b> ${animal.id}<br><b>Value:</b> %{y}${unitLabel}<extra></extra>`
                    });
                });

                // Curva promedio del grupo
                const stats = processedData.groupStats[group];
                if (stats.valid > 0) {
                    const allDays = [...new Set(groupAnimals.flatMap(a => a.timePoints))].sort((a, b) => a - b);
                    const xFit = [];
                    const yFit = [];

                    for (let x = allDays[0]; x <= allDays[allDays.length - 1]; x += 0.5) {
                        xFit.push(x);
                        yFit.push(stats.avgA * Math.exp(stats.avgR * x));
                    }

                    traces.push({
                        x: xFit,
                        y: yFit,
                        mode: 'lines',
                        name: `${group} (average)`,
                        legendgroup: group,
                        line: {
                            color: groupColor,
                            width: 4
                        },
                        hovertemplate: `<b>Group:</b> ${group}<br><b>Average value:</b> %{y:.2f}<extra></extra>`
                    });
                }
            });

            const dataType = processedData.dataType;
            const yAxisTitle = dataType === 'volume' ? 'Tumor Volume (mm³)' : 'BLI (Bioluminescence)';
            const layout = {
                title: {
                    text: 'Exponential Fit: y = a·e^(r·t)',
                    font: { color: '#e0e0e0' }
                },
                xaxis: {
                    title: 'Days',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    color: '#e0e0e0'
                },
                yaxis: {
                    title: yAxisTitle,
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    color: '#e0e0e0'
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'transparent',
                font: { color: '#e0e0e0' },
                hovermode: 'closest'
            };

            Plotly.newPlot('mainChart', traces, layout, { responsive: true });
        }

        // Función para crear gráfica de crecimiento normalizado (sin tabla)
        function createNormalizedGrowthChart() {
            const card = document.createElement('div');
            card.className = 'result-card';

            let html = '<h2>Normalized Growth Comparison</h2>';
            html += '<p>Exponential growth functions with initial value = 1, using only average growth rates (r)</p>';

            // ADD SCALE SWITCH
            html += `
            <div style="margin: 15px 0; display: flex; align-items: center; justify-content: center; gap: 15px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px;">
                <span style="color: #e0e0e0; font-weight: 500;">Y-axis scale:</span>
                <label class="scale-switch">
                    <input type="checkbox" id="scaleToggle" onchange="toggleNormalizedScale()">
                    <span class="slider">
                        <span class="slider-text" data-on="LOG" data-off="EXP"></span>
                    </span>
                </label>
                <div style="display: flex; flex-direction: column; font-size: 0.8em; color: #bbb;">
                    <span id="scaleDescription">Exponential: Shows real growth</span>
                </div>
            </div>
            `;

            html += '<div id="normalizedChart" style="width: 100%; height: 400px; margin-top: 1rem;"></div>';

            card.innerHTML = html;
            document.getElementById('results').appendChild(card);

            // OBTENER EL RANGO TEMPORAL DE LA GRÁFICA ORIGINAL
            const originalChart = document.getElementById('mainChart');
            let timeRange = { min: 0, max: 30 };

            if (originalChart && originalChart.layout && originalChart.layout.xaxis) {
                timeRange.min = originalChart.layout.xaxis.range ? originalChart.layout.xaxis.range[0] : 0;
                timeRange.max = originalChart.layout.xaxis.range ? originalChart.layout.xaxis.range[1] : 30;
                debugLog('Time range detected from original chart:', timeRange);
            } else {
                const allDays = [];
                processedData.validAnimals.forEach(animal => {
                    animal.timePoints.forEach(tp => allDays.push(tp.day));
                });
                if (allDays.length > 0) {
                    timeRange.min = Math.min(...allDays);
                    timeRange.max = Math.max(...allDays);
                }
                debugLog('Time range calculated from data:', timeRange);
            }

            // CREAR DATOS SIMULADOS USANDO EL MISMO RANGO TEMPORAL
            const stepSize = (timeRange.max - timeRange.min) / 60;
            const days = [];
            for (let day = timeRange.min; day <= timeRange.max; day += stepSize) {
                days.push(day);
            }

            const groupData = {};

            Object.entries(processedData.groupStats).forEach(([group, stats]) => {
                if (stats.valid > 0) {
                    groupData[group] = {
                        r: stats.avgR,
                        values: days.map(day => Math.exp(stats.avgR * day))
                    };
                }
            });

            // Crear gráfica normalizada
            const normTraces = [];
            const colors = ['#4facfe', '#00f2fe', '#fa709a', '#fee140', '#a8edea', '#fed6e3'];
            let colorIndex = 0;

            Object.entries(groupData).forEach(([group, data]) => {
                normTraces.push({
                    x: days,
                    y: data.values,
                    mode: 'lines',
                    name: `${group} (r=${data.r.toFixed(4)})`,
                    line: {
                        color: colors[colorIndex % colors.length],
                        width: 3
                    },
                    hovertemplate: `<b>${group}</b><br>` +
                        `Day: %{x:.1f}<br>` +
                        `Normalized value: %{y:.3f}<br>` +
                        `r = ${data.r.toFixed(4)} day⁻¹<br>` +
                        `<extra></extra>`
                });
                colorIndex++;
            });

            // Add reference line y = 1
            normTraces.push({
                x: [timeRange.min, timeRange.max],
                y: [1, 1],
                mode: 'lines',
                name: 'Reference (initial value)',
                line: {
                    color: '#bdc3c7',
                    width: 2,
                    dash: 'dash'
                },
                showlegend: true,
                hovertemplate: `<b>Reference Line</b><br>` +
                    `Normalized initial value = 1<br>` +
                    `<extra></extra>`
            });

            // Guardar datos para la función de toggle
            window.normalizedChartData = {
                traces: normTraces,
                timeRange: timeRange
            };

            const normLayout = {
                title: {
                    text: 'Normalized Growth Curves (Initial value = 1)',
                    font: { color: '#e0e0e0' }
                },
                xaxis: {
                    title: 'Days',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    color: '#e0e0e0',
                    range: [timeRange.min, timeRange.max],
                    tickmode: 'linear',
                    dtick: Math.max(1, Math.round((timeRange.max - timeRange.min) / 10))
                },
                yaxis: {
                    title: 'Normalized Value',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    color: '#e0e0e0',
                    type: 'linear' // Start with linear scale
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'transparent',
                font: { color: '#e0e0e0' },
                hovermode: 'closest',
                legend: {
                    orientation: 'v',
                    x: 1.02,
                    y: 1,
                    bgcolor: 'rgba(0,0,0,0.5)',
                    bordercolor: '#444',
                    borderwidth: 1,
                    font: { color: '#e0e0e0' }
                },
                margin: { r: 150 }
            };

            Plotly.newPlot('normalizedChart', normTraces, normLayout, {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                displaylogo: false
            });
            debugLog('Normalized chart created with time range:', timeRange);
        }

        function toggleNormalizedScale() {
            const toggle = document.getElementById('scaleToggle');
            const description = document.getElementById('scaleDescription');
            const chart = document.getElementById('normalizedChart');

            if (!chart || !window.normalizedChartData) {
                debugError('Normalized chart not found');
                return;
            }

            const isLogarithmic = toggle.checked;
            const newYAxisType = isLogarithmic ? 'log' : 'linear';

            // Update description
            if (isLogarithmic) {
                description.innerHTML = 'Logarithmic: Compares growth rates';
                description.style.color = '#fee140';
            } else {
                description.innerHTML = 'Exponential: Shows real growth';
                description.style.color = '#4facfe';
            }

            // Create new layout with updated scale
            const newLayout = {
                title: {
                    text: `Normalized Growth Curves - ${isLogarithmic ? 'Logarithmic' : 'Exponential'} Scale`,
                    font: { color: '#e0e0e0' }
                },
                xaxis: {
                    title: 'Days',
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    color: '#e0e0e0',
                    range: window.normalizedChartData.timeRange,
                    tickmode: 'linear',
                    dtick: Math.max(1, Math.round((window.normalizedChartData.timeRange.max - window.normalizedChartData.timeRange.min) / 10))
                },
                yaxis: {
                    title: `Normalized Value ${isLogarithmic ? '(log scale)' : '(linear scale)'}`,
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    color: '#e0e0e0',
                    type: newYAxisType
                },
                plot_bgcolor: 'rgba(0, 0, 0, 0.2)',
                paper_bgcolor: 'transparent',
                font: { color: '#e0e0e0' },
                hovermode: 'closest',
                legend: {
                    orientation: 'v',
                    x: 1.02,
                    y: 1,
                    bgcolor: 'rgba(0,0,0,0.5)',
                    bordercolor: '#444',
                    borderwidth: 1,
                    font: { color: '#e0e0e0' }
                },
                margin: { r: 150 }
            };

            // Update chart with smooth animation
            Plotly.react('normalizedChart', window.normalizedChartData.traces, newLayout, {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                displaylogo: false
            });

            // Notification
            const scaleType = isLogarithmic ? 'logarithmic' : 'exponential';
            showNotification(`Scale changed to ${scaleType}`, 'info');

            debugLog(`Normalized chart scale changed to: ${scaleType}`);
        }

        // Función para identificar grupo control y calcular rango optimizado
        // Función para identificar grupo control y calcular rango optimizado (CORREGIDA)
        function identifyControlGroupAndCalculateRange() {
            // Identificar grupo control (contiene "control" o "ctrl" en el nombre)
            controlGroup = null;
            Object.keys(processedData.groupStats).forEach(group => {
                if (group.toLowerCase().includes('control') ||
                    group.toLowerCase().includes('ctrl') ||
                    group.toLowerCase().includes('vehiculo') ||
                    group.toLowerCase().includes('vehicle')) {
                    controlGroup = group;
                }
            });

            // Si no se encuentra, usar el primer grupo
            if (!controlGroup) {
                controlGroup = Object.keys(processedData.groupStats)[0];
            }
            debugLog('Control group identified:', controlGroup);

            // Calcular rangos usando solo el grupo control para establecer baseline
            if (growthMatrices[controlGroup]) {
                const controlMatrix = growthMatrices[controlGroup];
                let controlValues = [];

                // Recopilar SOLO valores no-cero y no-null del grupo control
                controlMatrix.values.forEach(row => {
                    row.forEach(val => {
                        if (val !== null && !isNaN(val) && val !== 0) {
                            controlValues.push(val);
                        }
                    });
                });

                // Calcular min/max del control (solo valores no-cero)
                const controlMin = controlValues.length > 0 ? Math.min(...controlValues) : 0;
                const controlMax = controlValues.length > 0 ? Math.max(...controlValues) : 0;

                // Recopilar todos los valores de todas las matrices para el máximo global
                const allValues = [];
                Object.values(growthMatrices).forEach(matrix => {
                    matrix.values.forEach(row => {
                        row.forEach(val => {
                            if (val !== null && !isNaN(val) && val !== 0) {
                                allValues.push(val);
                            }
                        });
                    });
                });

                const globalMaxVal = allValues.length > 0 ? Math.max(...allValues) : 0;
                const globalMinVal = getGlobalMinValue(allValues);

                // Establecer rango optimizado:
                optimizedColorRange.min = controlMin * .5;
                optimizedColorRange.max = globalMaxVal * .75;
                debugLog('Optimized range calculated:', {
                    controlValues: controlValues.length,
                    controlMin: controlMin,
                    controlMax: controlMax,
                    globalMax: globalMaxVal,
                    optimizedRange: optimizedColorRange
                });
            } else {
                debugLog('Matrix not found for control group, using default values');
                optimizedColorRange.min = 0;
                optimizedColorRange.max = 0.1;
            }
        }

        function getGlobalMinValue(allValues) {
            // Filtrar solo valores numéricos válidos
            const validValues = allValues.filter(val =>
                val !== null &&
                val !== undefined &&
                typeof val === 'number' &&
                !isNaN(val) &&
                isFinite(val)
            );

            if (validValues.length === 0) {
                showNotification('No valid values to calculate global minimum', 'error');
                return 0;
            }

            const minValue = Math.min(...validValues);

            // Debug adicional
            debugLog('Global minimum calculation', {
                totalValues: allValues.length,
                validValues: validValues.length,
                minValue: minValue,
                invalidValues: allValues.length - validValues.length
            });

            return minValue;
        }

        // Función para obtener el rango de colores actual (personalizado o automático)
        function getCurrentColorRange() {
            return customColorRange || optimizedColorRange;
        }

        function updateCustomColorRange(minVal, maxVal) {
            // Validate inputs
            if (isNaN(minVal) || isNaN(maxVal) || !isFinite(minVal) || !isFinite(maxVal)) {
                showNotification('Invalid values for scale', 'warning');
                return false;
            }

            if (minVal >= maxVal) {
                showNotification('Minimum value must be less than maximum', 'warning');
                return false;
            }

            customColorRange = {
                min: minVal,
                max: maxVal
            };

            debugLog('Custom color scale updated', customColorRange);

            // Repaint all existing matrices
            repaintAllMatrices();

            showNotification('Color scale updated', 'success');
            return true;
        }

        function resetToAutoScale() {
            customColorRange = null;

            // Update inputs with automatic values
            const minInput = document.getElementById('colorScaleMin');
            const maxInput = document.getElementById('colorScaleMax');

            if (minInput && maxInput) {
                minInput.value = optimizedColorRange.min.toFixed(4);
                maxInput.value = optimizedColorRange.max.toFixed(4);
            }

            // Repaint matrices
            repaintAllMatrices();

            showNotification('Automatic scale restored', 'info');
            debugLog('Scale reset to automatic', optimizedColorRange);
        }

        // Función para repintar todas las matrices existentes
        function repaintAllMatrices() {
            const matrixGroups = document.querySelectorAll('.matrix-group');

            matrixGroups.forEach(group => {
                const groupTitle = group.querySelector('h3').textContent;
                const matrix = growthMatrices[groupTitle];

                if (matrix) {
                    const table = group.querySelector('table');
                    if (table) {
                        // CREAR CONTENEDOR TEMPORAL
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = createOptimizedMatrixTable(matrix);
                        const newTable = tempDiv.querySelector('table');

                        // REEMPLAZAR SOLO LA TABLA
                        table.parentNode.replaceChild(newTable, table);
                    }
                }
            });
        }

        // Función modificada para crear la leyenda con controles ajustables
        function createAdjustableColorLegend() {
            const currentRange = getCurrentColorRange();

            return `
                <div style="text-align: center; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e0e0e0;">
                    <div style="font-weight: 500; margin-bottom: 15px;">Adjustable Color Scale</div>
                    
                    <!-- Scale controls -->
                    <div style="display: flex; justify-content: center; align-items: center; gap: 15px; margin-bottom: 15px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="colorScaleMin" style="font-size: 0.9em; color: #666;">Minimum:</label>
                            <input 
                                type="number" 
                                id="colorScaleMin" 
                                value="${currentRange.min.toFixed(4)}" 
                                step="0.0001" 
                                style="width: 80px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; text-align: center;"
                                onchange="handleColorScaleChange()"
                                onkeypress="handleColorScaleKeypress(event)"
                            >
                        </div>
                        
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="colorScaleMax" style="font-size: 0.9em; color: #666;">Maximum:</label>
                            <input 
                                type="number" 
                                id="colorScaleMax" 
                                value="${currentRange.max.toFixed(4)}" 
                                step="0.0001" 
                                style="width: 80px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; text-align: center;"
                                onchange="handleColorScaleChange()"
                                onkeypress="handleColorScaleKeypress(event)"
                            >
                        </div>
                        
                        <button 
                            onclick="resetToAutoScale()" 
                            style="padding: 4px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 0.8em; cursor: pointer; transition: background 0.2s;"
                            onmouseover="this.style.background='#5a6268'" 
                            onmouseout="this.style.background='#6c757d'"
                            title="Restore automatic scale"
                        >
                            Auto
                        </button>
                    </div>
                    
                    <!-- Visual indicators -->
                    <div style="display: flex; justify-content: center; align-items: center; gap: 20px; font-size: 0.9em; margin-bottom: 10px;">
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 16px; height: 16px; background: rgb(100, 200, 100); border-radius: 3px; border: 1px solid #ccc;"></div>
                            Low
                        </span>
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 16px; height: 16px; background: rgb(255, 255, 0); border-radius: 3px; border: 1px solid #ccc;"></div>
                            Medium
                        </span>
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <div style="width: 16px; height: 16px; background: rgb(255, 0, 100); border-radius: 3px; border: 1px solid #ccc;"></div>
                            High
                        </span>
                    </div>
                    
                    <div style="font-size: 0.8rem; color: #666;">
                        Control group: <strong>${controlGroup}</strong>
                        ${customColorRange ? ' • <span style="color: #28a745;">Custom scale</span>' : ' • <span style="color: #CACED1;">Automatic scale</span>'}
                    </div>
                </div>
                `;
        }

        // Función para manejar cambios en los inputs de escala
        function handleColorScaleChange() {
            const minInput = document.getElementById('colorScaleMin');
            const maxInput = document.getElementById('colorScaleMax');

            if (!minInput || !maxInput) return;

            const minVal = parseFloat(minInput.value);
            const maxVal = parseFloat(maxInput.value);

            updateCustomColorRange(minVal, maxVal);
        }

        // Función para manejar Enter en los inputs
        function handleColorScaleKeypress(event) {
            if (event.key === 'Enter') {
                handleColorScaleChange();
                event.target.blur(); // Quitar foco del input
            }
        }

        // Función modificada para usar la escala actual en lugar de la fija
        function getOptimizedColorForValue(value, minOverride = null, maxOverride = null) {
            if (value === null || isNaN(value)) return '#f8f9fa';

            // Usar valores override si se proporcionan, sino usar la escala actual
            const currentRange = getCurrentColorRange();
            const min = minOverride !== null ? minOverride : currentRange.min;
            const max = maxOverride !== null ? maxOverride : currentRange.max;

            // Normalizar valor entre 0 y 1
            const normalized = Math.max(0, Math.min(1, (value - min) / (max - min)));

            let r, g, b;

            if (normalized <= 0.5) {
                // Transición de verde a amarillo (0 a 0.5)
                const t = normalized * 2; // 0 a 1
                r = Math.round(100 + t * 155); // 100 a 255
                g = Math.round(200 + t * 55);  // 200 a 255
                b = Math.round(100 * (1 - t)); // 100 a 0
            } else {
                // Transición de amarillo a rojo (0.5 a 1)
                const t = (normalized - 0.5) * 2; // 0 a 1
                r = 255;                           // Mantener en 255
                g = Math.round(255 * (1 - t));     // 255 a 0
                b = 0;                             // Mantener en 0
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function generateGrowthMatrices() {
            if (processedData.validAnimals.length === 0) {
                showNotification('Analyze data first to generate matrices', 'warning');
                return;
            }

            showNotification('Generating optimized growth matrices...', 'info');

            // Calculate matrices for each group
            Object.entries(processedData.groupStats).forEach(([group, stats]) => {
                if (stats.valid > 0) {
                    const matrix = calculateGrowthMatrix(group);
                    growthMatrices[group] = matrix;
                }
            });

            // Identify control and calculate optimized range
            identifyControlGroupAndCalculateRange();

            // Display optimized matrices
            displayOptimizedGrowthMatrices();

            showNotification('Optimized growth matrices generated', 'success');
        }

        // Función para calcular matriz de crecimiento de un grupo
        function calculateGrowthMatrix(groupName) {
            const groupAnimals = processedData.validAnimals.filter(a => a.group === groupName);
            const dataType = processedData.dataType;

            // Obtener todos los días únicos del grupo
            const allDays = [...new Set(groupAnimals.flatMap(a => a.timePoints))].sort((a, b) => a - b);

            // Crear matriz vacía
            const matrix = {
                days: allDays,
                values: Array(allDays.length).fill().map(() => Array(allDays.length).fill(null))
            };

            // Store individual TGRs for statistical comparisons
            const individualData = {};
            
            // Llenar matriz con tasas de crecimiento usando Method 2 (average of individual TGRs)
            for (let i = 0; i < allDays.length; i++) {
                for (let j = 0; j < allDays.length; j++) {
                    const dayX = allDays[i];
                    const dayY = allDays[j];

                    if (dayX === dayY) {
                        matrix.values[i][j] = 0; // Diagonal principal
                    } else if (dayY > dayX) {
                        // Calculate individual TGRs for each animal
                        const individualTGRs = [];
                        
                        groupAnimals.forEach(animal => {
                            const dayXIndex = animal.timePoints.indexOf(dayX);
                            const dayYIndex = animal.timePoints.indexOf(dayY);
                            
                            // Only include animals that have data for both timepoints
                            if (dayXIndex !== -1 && dayYIndex !== -1) {
                                const valueX = animal.measurements[dayXIndex];
                                const valueY = animal.measurements[dayYIndex];
                                
                                // Only calculate TGR if both values are positive and valid
                                if (valueX > 0 && valueY > 0) {
                                    const r = Math.log(valueY / valueX) / (dayY - dayX);
                                    individualTGRs.push(r);
                                }
                            }
                        });

                        // Store individual TGRs for statistical analysis
                        const key = `${dayX}-${dayY}`;
                        individualData[key] = individualTGRs;

                        // Average the individual TGRs if we have valid calculations
                        if (individualTGRs.length > 0) {
                            const averageTGR = individualTGRs.reduce((sum, tgr) => sum + tgr, 0) / individualTGRs.length;
                            matrix.values[i][j] = averageTGR;
                            matrix.values[j][i] = averageTGR; // Matriz simétrica
                        }
                    }
                }
            }

            // Store individual data in the matrix object
            matrix.individualData = individualData;
            matrix.group = groupName;
            
            return matrix;
        }

        function displayOptimizedGrowthMatrices() {
            const card = document.createElement('div');
            card.className = 'result-card';

            let html = '<h2>Tumor Growth Rate Matrices (TGR)</h2>';
            html += '<p>Each matrix shows growth rates r(x→y) = log(V_y/V_x)/(t_y-t_x) between day pairs. Values are calculated using group averages.</p>';

            // NEW LEGEND WITH CONTROLS
            const currentRange = customColorRange || optimizedColorRange;
            html += `
       <div style="text-align: center; margin: 20px 0; padding: 20px; background: transparent; border-radius: 8px; border: 1px solid #e0e0e0;">
           <div style="font-weight: 500; margin-bottom: 15px;">Adjustable Color Scale</div>
           
           <div style="display: flex; justify-content: center; align-items: center; gap: 15px; margin-bottom: 15px; flex-wrap: wrap;">
               <div style="display: flex; align-items: center; gap: 8px;">
                   <label style="font-size: 0.9em; color: white;">Minimum:</label>
                   <input 
                       type="number" 
                       id="colorScaleMin" 
                       value="${currentRange.min.toFixed(4)}" 
                       step="0.0001" 
                       style="width: 80px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; text-align: center;"
                   >
               </div>
               
               <div style="display: flex; align-items: center; gap: 8px;">
                   <label style="font-size: 0.9em; color: white;">Maximum:</label>
                   <input 
                       type="number" 
                       id="colorScaleMax" 
                       value="${currentRange.max.toFixed(4)}" 
                       step="0.0001" 
                       style="width: 80px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; text-align: center;"
                   >
               </div>
               
               <button 
                   id="updateScaleBtn"
                   style="padding: 4px 12px; background: #28a745; color: white; border: none; border-radius: 4px; font-size: 0.8em; cursor: pointer;"
               >
                   Apply
               </button>
               
               <button 
                   id="resetScaleBtn"
                   style="padding: 4px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 0.8em; cursor: pointer;"
               >
                   Auto
               </button>
           </div>
           
           <div style="display: flex; justify-content: center; align-items: center; gap: 20px; font-size: 0.9em; margin-bottom: 10px;">
               <span style="display: flex; align-items: center; gap: 5px;">
                   <div style="width: 16px; height: 16px; background: rgb(100, 200, 100); border-radius: 3px; border: 1px solid #ccc;"></div>
                   Low
               </span>
               <span style="display: flex; align-items: center; gap: 5px;">
                   <div style="width: 16px; height: 16px; background: rgb(255, 255, 0); border-radius: 3px; border: 1px solid #ccc;"></div>
                   Medium
               </span>
               <span style="display: flex; align-items: center; gap: 5px;">
                   <div style="width: 16px; height: 16px; background: rgb(255, 0, 100); border-radius: 3px; border: 1px solid #ccc;"></div>
                   High
               </span>
           </div>
           
           <div style="font-size: 0.8rem; color: white;">
               Control group: <strong>${controlGroup}</strong>
               <span id="scaleStatus">${customColorRange ? ' • <span style="color: #CACED1;">Custom scale</span>' : ' • <span style="color: #CACED1;">Automatic scale</span>'}</span>
           </div>
       </div>
   `;

            // Add TGR functionality legend
            html += `
       <div style="text-align: center; margin: 15px 0; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">
           <div style="font-weight: 500; margin-bottom: 10px; color: #4facfe;">TGR Matrix Comparison Instructions</div>
           <div style="font-size: 0.85rem; color: #e0e0e0; line-height: 1.4;">
               <strong>1. Select cells:</strong> Click on any matrix cell to select it (blue border will appear)<br>
               <strong>2. Compare:</strong> When you select a second cell, automatic Mann-Whitney U comparison will be performed<br>
               <strong>3. Deselect:</strong> Click the same cell again to deselect it<br>
               <strong>4. View results:</strong> Statistical comparisons appear below the matrices with p-values, effect sizes, and significance indicators
           </div>
       </div>
   `;

            const numGroups = Object.keys(growthMatrices).length;
            
            // Detect if we have large matrices (>9 days)
            const hasLargeMatrices = Object.values(growthMatrices).some(matrix => matrix.days.length > 9);
            let containerClass = 'matrices-container';
            let gridStyle = '';

            if (hasLargeMatrices) {
                containerClass += ' large-matrix';
            } else if (numGroups <= 2) {
                gridStyle = 'grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));';
            } else if (numGroups === 3) {
                gridStyle = 'grid-template-columns: repeat(2, 1fr); grid-auto-flow: row;';
            } else {
                gridStyle = 'grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));';
            }

            html += `<div class="${containerClass}" style="${gridStyle}">`;

            Object.entries(growthMatrices).forEach(([group, matrix]) => {
                html += `
           <div class="matrix-group">
               <h3>${group}</h3>
               ${createOptimizedMatrixTable(matrix)}
           </div>
       `;
            });

            html += '</div>';
            card.innerHTML = html;

            document.getElementById('results').appendChild(card);

            // ADD EVENT LISTENERS after creating HTML
            setupColorScaleControls();
            
            // Create TGR comparisons container with buttons from the start
            createTGRComparisonsContainer();
        }

        function setupColorScaleControls() {
            const updateBtn = document.getElementById('updateScaleBtn');
            const resetBtn = document.getElementById('resetScaleBtn');
            const minInput = document.getElementById('colorScaleMin');
            const maxInput = document.getElementById('colorScaleMax');

            if (updateBtn) {
                updateBtn.addEventListener('click', () => {
                    const minVal = parseFloat(minInput.value);
                    const maxVal = parseFloat(maxInput.value);

                    if (isNaN(minVal) || isNaN(maxVal)) {
                        showNotification('Invalid values', 'warning');
                        return;
                    }

                    if (minVal >= maxVal) {
                        showNotification('Minimum must be less than maximum', 'warning');
                        return;
                    }

                    customColorRange = { min: minVal, max: maxVal };
                    repaintAllMatrices();
                    updateScaleStatus();
                    showNotification('Scale updated', 'success');
                });
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    customColorRange = null;
                    minInput.value = optimizedColorRange.min.toFixed(4);
                    maxInput.value = optimizedColorRange.max.toFixed(4);
                    repaintAllMatrices();
                    updateScaleStatus();
                    showNotification('Automatic scale restored', 'info');
                });
            }

            // Enter on inputs
            [minInput, maxInput].forEach(input => {
                if (input) {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            updateBtn.click();
                        }
                    });
                }
            });
        }

        function updateScaleStatus() {
            const statusElement = document.getElementById('scaleStatus');
            if (statusElement) {
                statusElement.innerHTML = customColorRange ?
                    ' • <span style="color: #28a745;">Custom scale</span>' :
                    ' • <span style="color: #CACED1;">Automatic scale</span>';
            }
        }

        // Función modificada para crear tabla de matriz optimizada (solo triángulo superior)
        function createOptimizedMatrixTable(matrix) {
            const days = matrix.days;
            const currentRange = getCurrentColorRange();

            let html = '<table class="matrix-table"><thead><tr><th></th>';

            // Solo mostrar columnas desde el segundo día (omitir la primera columna vacía)
            days.slice(1).forEach(day => {
                html += `<th>D${day}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Solo mostrar filas hasta el penúltimo día (ya que la última fila sería toda vacía)
            days.slice(0, -1).forEach((dayRow, i) => {
                html += `<tr><th>D${dayRow}</th>`;
                
                // Solo mostrar columnas desde el segundo día (j+1 para compensar el slice)
                days.slice(1).forEach((dayCol, j) => {
                    const actualJ = j + 1; // Ajustar índice porque sliceamos desde 1
                    
                    if (actualJ <= i) {
                        // Celda vacía para triángulo inferior y diagonal
                        html += '<td class="empty-cell"></td>';
                    } else {
                        // Triángulo superior con valores
                        const value = matrix.values[i][actualJ];
                        let cellContent = '';
                        let cellClass = 'matrix-cell';
                        let cellStyle = '';

                        if (value !== null && !isNaN(value)) {
                            cellContent = value.toFixed(4);
                            const bgColor = getOptimizedColorForValue(value, currentRange.min, currentRange.max);
                            const textColor = getContrastColor(bgColor);
                            cellStyle = `background-color: ${bgColor}; color: ${textColor};`;
                        } else {
                            cellContent = '—';
                            cellClass += ' empty-cell';
                        }

                        html += `<td class="${cellClass}" style="${cellStyle}" 
                                    title="r(D${dayRow}→D${dayCol}) = ${cellContent}"
                                    data-group="${matrix.group}" 
                                    data-day-x="${dayRow}" 
                                    data-day-y="${dayCol}"
                                    data-value="${value}"
                                    onclick="selectTGRCell(this)">${cellContent}</td>`;
                    }
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        // 3. FUNCIÓN AUXILIAR PARA DETERMINAR COLOR DE TEXTO CONTRASTANTE
        function getContrastColor(rgbColor) {
            const matches = rgbColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (!matches) return '#000';

            const r = parseInt(matches[1]);
            const g = parseInt(matches[2]);
            const b = parseInt(matches[3]);

            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5 ? '#000' : '#fff';
        }


        function togglePredictionForm() {
            if (Object.keys(animalModels).length === 0) {
                showNotification('Analyze data first to enable predictions', 'warning');
                return;
            }

            const existingForm = document.getElementById('predictionCard');
            if (existingForm) {
                existingForm.remove();
                return;
            }

            const card = document.createElement('div');
            card.className = 'result-card';
            card.id = 'predictionCard';

            const dataType = processedData.dataType;
            const paramLabel = dataType === 'volume' ? 'Volume' : 'BLI';

            card.innerHTML = `
                <h2>${paramLabel} and Tumor Weight Prediction</h2>
                
                <!-- Prediction Mode Selection -->
                <div style="margin: 1rem 0; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                    <h3>Prediction Mode</h3>
                    <div style="display: flex; gap: 1rem; margin: 0.5rem 0;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="radio" name="predictionMode" value="single" checked onchange="togglePredictionMode()" style="accent-color: #4facfe;">
                            <span>Single Animal Prediction</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="radio" name="predictionMode" value="batch" onchange="togglePredictionMode()" style="accent-color: #4facfe;">
                            <span>Batch Weight Prediction</span>
                        </label>
                    </div>
                </div>

                <!-- Single Animal Prediction -->
                <div id="singlePredictionForm" style="display: block;">
                    <h3>Single Animal Prediction</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; color: #4facfe;">Animal ID:</label>
                            <select id="predictAnimal" onchange="updatePredictionForm()" style="width: 100%; padding: 0.5rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #e0e0e0;">
                                <option value="">Select animal...</option>
                                ${processedData.validAnimals.map(a =>
                    `<option value="${a.id}">${a.id} - ${a.group}</option>`
                ).join('')}
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; color: #4facfe;">Last weight day:</label>
                            <input type="number" id="lastWeightDay" min="0" step="1" style="width: 100%; padding: 0.5rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #e0e0e0;" />
                            <small id="lastWeightDayHelp" style="display: block; margin-top: 0.25rem; color: #a0a0a0; font-size: 0.8rem;">Select an animal to see available days</small>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; color: #4facfe;">Last day tumor weight (g):</label>
                            <input type="number" id="lastTumorWeight" min="0" step="0.001" style="width: 100%; padding: 0.5rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #e0e0e0;" />
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; color: #4facfe;">Day to predict:</label>
                            <input type="number" id="predictDay" min="0" step="1" style="width: 100%; padding: 0.5rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #e0e0e0;" />
                            <small id="predictDayHelp" style="display: block; margin-top: 0.25rem; color: #a0a0a0; font-size: 0.8rem;">Select an animal to see valid range</small>
                        </div>
                    </div>
                    <button class="btn" onclick="predictValue()" style="margin: 1rem 0;">Calculate Prediction</button>
                </div>

                <!-- Batch Weight Prediction -->
                <div id="batchPredictionForm" style="display: none;">
                    <h3>Batch Tumor Weight Prediction</h3>
                    
                    <!-- Weight Source Selection -->
                    <div style="margin: 1rem 0; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                        <h4>Weight Data Source</h4>
                        <div style="display: flex; gap: 1.5rem; margin: 0.5rem 0;">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="radio" name="weightSource" value="auto" checked onchange="toggleWeightSource()" style="accent-color: #4facfe;">
                                <span>Auto-detect from dataset</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="radio" name="weightSource" value="manual" onchange="toggleWeightSource()" style="accent-color: #4facfe;">
                                <span>Upload separate CSV file</span>
                            </label>
                        </div>
                    </div>

                    <!-- Auto-detection Status -->
                    <div id="autoWeightStatus" style="margin: 1rem 0; display: block;">
                        <div id="autoWeightMessage" style="padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 4px solid #4facfe;">
                            <span style="color: #a0a0a0;">🔍 Checking for Tumor_Weight column...</span>
                        </div>
                    </div>

                    <!-- Manual Upload -->
                    <div id="manualWeightUpload" style="margin: 1rem 0; display: none;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #4facfe; font-weight: 600;">Load Tumor Weight CSV:</label>
                        <div class="file-input-wrapper" style="position: relative; display: inline-block; width: 100%;">
                            <input type="file" id="weightsFileInput" accept=".csv,.txt" style="position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer;" />
                            <div class="file-input-label" id="weightFileLabel" style="
                                display: flex; 
                                align-items: center; 
                                justify-content: center; 
                                padding: 1rem; 
                                background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1)); 
                                border: 2px dashed rgba(79, 172, 254, 0.5); 
                                border-radius: 12px; 
                                color: #e0e0e0; 
                                cursor: pointer; 
                                transition: all 0.3s ease;
                                min-height: 60px;
                                text-align: center;
                                font-size: 0.95rem;
                            ">
                                Drag your tumor weight CSV here or click to select
                                <br><small style="color: #a0a0a0; margin-top: 2px; padding-left: 5px;">Accepted formats: .csv, .txt</small>
                            </div>
                        </div>
                        <p style="margin: 8px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">
                            <strong>Required columns:</strong> Animal_ID, Day, Tumor_Weight
                            <br><strong>Example:</strong> C1, 28, 1.245 (animal C1, day 28, weight 1.245g)
                        </p>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; color: #4facfe;">Target prediction day:</label>
                            <input type="number" id="batchPredictDay" min="0" step="1" style="width: 100%; padding: 0.5rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #e0e0e0;" />
                            <small style="display: block; margin-top: 0.25rem; color: #a0a0a0; font-size: 0.8rem;">Day to predict weights for all animals</small>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; color: #4facfe;">Statistical comparison:</label>
                            <select id="batchComparison" style="width: 100%; padding: 0.5rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #e0e0e0;">
                                <option value="none">No comparison</option>
                                <option value="mann-whitney" selected>Mann-Whitney U test</option>
                            </select>
                        </div>
                    </div>
                    <button class="btn" onclick="predictBatchWeights()" style="margin: 1rem 0;" disabled id="batchPredictBtn">Calculate Batch Predictions</button>
                </div>

                <div id="predictionResults" style="margin-top: 1rem; background: transparent; border-radius: 8px; display: none;"></div>
            `;

            document.getElementById('results').appendChild(card);
            
            // Auto-select Batch Weight Prediction if Tumor_Weight column exists
            if (rawData && rawData.length > 0) {
                const firstRow = rawData[0];
                const hasTumorWeight = firstRow && firstRow.hasOwnProperty('Tumor_Weight');
                
                if (hasTumorWeight) {
                    // Select batch prediction mode
                    const batchRadio = document.querySelector('input[name="predictionMode"][value="batch"]');
                    if (batchRadio) {
                        batchRadio.checked = true;
                        // Trigger the mode change
                        togglePredictionMode();
                    }
                }
            }
            
            showNotification('Prediction form opened', 'info');
        }

        // Función para actualizar formulario de predicción
        function updatePredictionForm() {
            const animalId = document.getElementById('predictAnimal').value;
            if (animalId && animalModels[animalId]) {
                const animal = animalModels[animalId];
                const maxDay = Math.max(...animal.timePoints);
                const lastValue = animal.measurements[animal.measurements.length - 1];

                document.getElementById('predictDay').value = maxDay + 7;
                document.getElementById('lastWeightDay').value = maxDay;
                document.getElementById('lastTumorWeight').placeholder = `Ej: 1.0`;
                
                // Update help text
                document.getElementById('predictDayHelp').textContent = `Any day can be predicted (data available: ${Math.min(...animal.timePoints)}-${maxDay})`;
                document.getElementById('lastWeightDayHelp').textContent = `Available days: ${animal.timePoints.join(', ')}`;
            } else {
                // Reset help text when no animal is selected
                document.getElementById('predictDayHelp').textContent = 'Any day can be predicted';
                document.getElementById('lastWeightDayHelp').textContent = 'Select an animal to see available days';
            }
        }

        // Función para predecir valores
        function predictValue() {
            const animalId = document.getElementById('predictAnimal').value;
            const day = parseFloat(document.getElementById('predictDay').value);
            const lastWeight = parseFloat(document.getElementById('lastTumorWeight').value);
            const lastWeightDay = parseFloat(document.getElementById('lastWeightDay').value);

            if (!animalId || !animalModels[animalId] || isNaN(day)) {
                showNotification('Please select a valid animal and day', 'warning');
                return;
            }

            const animal = animalModels[animalId];

            // Validate tumor weight day if provided
            if (!isNaN(lastWeightDay) && !animal.timePoints.includes(lastWeightDay)) {
                showNotification(`Tumor weight day (${lastWeightDay}) must correspond to an actual measurement day for animal ${animal.id}. Available days: ${animal.timePoints.join(', ')}`, 'warning');
                return;
            }

            const predictedMeasurement = animal.model.a * Math.exp(animal.model.r * day);

            const dataType = processedData.dataType;
            const paramLabel = dataType === 'volume' ? 'Predicted volume' : 'Predicted BLI';
            const unitLabel = dataType === 'volume' ? ' mm³' : '';

            const predictedValue = dataType === 'bli' ?
                predictedMeasurement.toExponential(3) :
                predictedMeasurement.toFixed(2);

            let weightPrediction = '';
            if (!isNaN(lastWeight) && !isNaN(lastWeightDay)) {
                // Assume tumor weight grows proportionally to volume/BLI
                const lastMeasurement = animal.model.a * Math.exp(animal.model.r * lastWeightDay);
                const weightGrowthRatio = predictedMeasurement / lastMeasurement;
                const predictedWeight = lastWeight * weightGrowthRatio;

                weightPrediction = `
                    <p><strong>Predicted tumor weight (day ${day}): </strong><span style="padding-left: 4px; padding-right: 4px; background-color: white; color: black; font-weight: bold; font-size: 1.1rem;">${predictedWeight.toFixed(3)} g</span></p>
                    <p><strong>Weight growth ratio:</strong> ${weightGrowthRatio.toFixed(2)}x</p>
                    `;
            }

            // Check if prediction day is within experimental range for interpolation validation
            let interpolationValidation = '';
            const minDay = Math.min(...animal.timePoints);
            const maxDay = Math.max(...animal.timePoints);
            
            if (day >= minDay && day <= maxDay) {
                // Interpolation - find actual experimental value for validation
                const actualIndex = animal.timePoints.indexOf(day);
                if (actualIndex !== -1) {
                    const actualValue = animal.measurements[actualIndex];
                    const percentError = Math.abs((predictedMeasurement - actualValue) / actualValue * 100);
                    interpolationValidation = `
                        <div style="background: rgba(165, 94, 234, 0.1); padding: 15px; border-radius: 8px; margin: 10 0px; border-left: 4px solid #a55eea;">
                            <h4 style="color: white; margin: 0 0 8px 0;">Interpolation Validation</h4>
                            <p><strong>Experimental value (day ${day}):</strong> ${dataType === 'bli' ? actualValue.toExponential(3) : actualValue.toFixed(2)}${unitLabel}</p>
                            <p><strong>Prediction error:</strong> <span style="font-weight: bold; font-size: 1.1rem; color: ${percentError < 10 ? '#84D288' : percentError < 20 ? '#FFAA55' : '#E68989'};">${percentError.toFixed(1)}%</span></p>
                        </div>
                    `;
                }
            }

            const resultsDiv = document.getElementById('predictionResults');
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `
                <h3>Prediction Results</h3>
                <div style="background: transparent; padding: 0px 0px 10px 15px; border-radius: 8px; margin: 10px 0;">
                    <p><strong>Animal:</strong> ${animal.id} (${animal.group})</p>
                    <p><strong>Model:</strong> y = ${
                        animal.model.a > 10000
                            ? animal.model.a.toExponential(2)
                            : animal.model.a.toFixed(2)
                        } × e^(${animal.model.r.toFixed(4)} × t)</p>
                    <p><strong>R²:</strong> ${animal.model.r2.toFixed(2)}</p>
                </div>
                
                <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #1976d2;">
                    <h4 style="color: white; margin: 0 0 8px 0;">${paramLabel}</h4>
                    <p style="font-size: 1.0em;"><strong>Day ${day}:</strong> <span style="padding-left: 4px; padding-right: 4px; background-color: white; color: black; font-weight: bold; font-size: 1.1rem;">${predictedValue}${unitLabel}</span></p>
                    <p><strong>95% confidence interval:</strong> ${formatNumber(predictedMeasurement * 0.85)} - ${formatNumber(predictedMeasurement * 1.15)}${unitLabel}</p>
                </div>
                
                ${interpolationValidation}
                
                ${weightPrediction ? `
                    <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #f57c00;">
                        <h4 style="color: white; margin: 0 0 8px 0;">Tumor Weight Prediction</h4>
                        ${weightPrediction}
                    </div>
                ` : ''}
                `;

            showNotification('Prediction calculated correctly', 'success');
        }

        function formatNumber(x) {
            return x > 10000 ? x.toExponential(2) : x.toFixed(2);
        }

        // Global variables for batch prediction
        let tumorWeightsData = null;
        let batchPredictionResults = null;

        function togglePredictionMode() {
            const mode = document.querySelector('input[name="predictionMode"]:checked').value;
            const singleForm = document.getElementById('singlePredictionForm');
            const batchForm = document.getElementById('batchPredictionForm');
            
            if (mode === 'single') {
                singleForm.style.display = 'block';
                batchForm.style.display = 'none';
            } else {
                singleForm.style.display = 'none';
                batchForm.style.display = 'block';
                setupWeightFileInput();
                // Initialize weight source selection and check for auto-detection
                toggleWeightSource();
            }
        }

        function toggleWeightSource() {
            const weightSource = document.querySelector('input[name="weightSource"]:checked').value;
            const autoStatus = document.getElementById('autoWeightStatus');
            const manualUpload = document.getElementById('manualWeightUpload');
            const batchPredictBtn = document.getElementById('batchPredictBtn');
            
            if (weightSource === 'auto') {
                autoStatus.style.display = 'block';
                manualUpload.style.display = 'none';
                checkForTumorWeightColumn();
            } else {
                autoStatus.style.display = 'none';
                manualUpload.style.display = 'block';
                // Reset auto-detected data
                tumorWeightsData = null;
                batchPredictBtn.disabled = true;
            }
        }
        
        function checkForTumorWeightColumn() {
            const autoWeightMessage = document.getElementById('autoWeightMessage');
            const batchPredictBtn = document.getElementById('batchPredictBtn');
            
            if (!rawData || rawData.length === 0) {
                autoWeightMessage.innerHTML = `
                    <span style="color: #ff6b6b;">❌ No dataset loaded. Please load your main CSV file first.</span>
                `;
                batchPredictBtn.disabled = true;
                return;
            }
            
            // Check if Tumor_Weight column exists
            const firstRow = rawData[0];
            const hasTumorWeight = firstRow && firstRow.hasOwnProperty('Tumor_Weight');
            
            if (hasTumorWeight) {
                // Extract tumor weight data from the original dataset
                extractTumorWeightsFromDataset();
            } else {
                autoWeightMessage.innerHTML = `
                    <span style="color: #FFAA55;">No 'Tumor_Weight' column found in your dataset.</span>
                    <br><small style="color: #a0a0a0; margin-top: 4px;">Please use the "Upload separate CSV file" option instead.</small>
                `;
                batchPredictBtn.disabled = true;
            }
        }
        
        function extractTumorWeightsFromDataset() {
            const autoWeightMessage = document.getElementById('autoWeightMessage');
            const batchPredictBtn = document.getElementById('batchPredictBtn');
            
            try {
                tumorWeightsData = [];
                
                // Process each row to extract tumor weights
                rawData.forEach(row => {
                    const animalId = row.Animal || row.ID || `Animal_${rawData.indexOf(row) + 1}`;
                    const tumorWeight = parseFloat(row.Tumor_Weight);
                    
                    if (!isNaN(tumorWeight) && tumorWeight > 0) {
                        // Find the last day with V/BLI data for this animal
                        const dayCols = Object.keys(row)
                            .filter(k => !isNaN(parseFloat(k)))
                            .map(Number)
                            .sort((a, b) => a - b);
                        
                        // Find the last day with valid measurement data
                        let lastDayWithData = null;
                        for (let i = dayCols.length - 1; i >= 0; i--) {
                            const dayValue = parseFloat(row[dayCols[i]]);
                            if (!isNaN(dayValue) && dayValue > 0) {
                                lastDayWithData = dayCols[i];
                                break;
                            }
                        }
                        
                        if (lastDayWithData !== null) {
                            tumorWeightsData.push({
                                animalId: animalId,
                                day: lastDayWithData,
                                weight: tumorWeight
                            });
                        }
                    }
                });
                
                if (tumorWeightsData.length > 0) {
                    autoWeightMessage.innerHTML = `
                        <span style="color: #84D288;">Found Tumor_Weight column with ${tumorWeightsData.length} valid measurements.</span>
                        <br><small style="color: #a0a0a0; margin-top: 4px;">Using tumor weights corresponding to last measurement day for each animal.</small>
                    `;
                    batchPredictBtn.disabled = false;
                } else {
                    autoWeightMessage.innerHTML = `
                        <span style="color: #FFAA55;">Tumor_Weight column found but no valid weight data.</span>
                        <br><small style="color: #a0a0a0; margin-top: 4px;">Please check your data or use the upload option.</small>
                    `;
                    batchPredictBtn.disabled = true;
                }
                
            } catch (error) {
                autoWeightMessage.innerHTML = `
                    <span style="color: #ff6b6b;">Error processing Tumor_Weight data: ${error.message}</span>
                `;
                batchPredictBtn.disabled = true;
            }
        }

        function setupWeightFileInput() {
            const weightsFileInput = document.getElementById('weightsFileInput');
            const weightFileLabel = document.getElementById('weightFileLabel');
            
            weightsFileInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (!file) {
                    weightFileLabel.innerHTML = `
                        Drag your tumor weight CSV here or click to select
                        <br><small style="color: #a0a0a0; padding-left: 5px;">Accepted formats: .csv, .txt</small>
                    `;
                    return;
                }
                
                weightFileLabel.innerHTML = `
                    ${file.name} (Loading...)
                    <br><small style="color: #a0a0a0; margin-top: 5px;">Processing file...</small>
                `;
                weightFileLabel.style.borderColor = 'rgba(79, 172, 254, 0.8)';
                weightFileLabel.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.2), rgba(0, 153, 204, 0.2))';
                
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const csvData = e.target.result;
                            const parsed = Papa.parse(csvData, { header: true, skipEmptyLines: true });
                            
                            // Validate required columns
                            const requiredColumns = ['Animal_ID', 'Day', 'Tumor_Weight'];
                            const hasRequiredColumns = requiredColumns.every(col => 
                                parsed.data.length > 0 && parsed.data[0].hasOwnProperty(col)
                            );
                            
                            if (!hasRequiredColumns) {
                                weightFileLabel.innerHTML = `
                                    ❌ Missing columns: ${requiredColumns.filter(col => !parsed.data[0].hasOwnProperty(col)).join(', ')}
                                    <br><small style="color: #ff6b6b;">Required: Animal_ID, Day, Tumor_Weight</small>
                                `;
                                weightFileLabel.style.borderColor = 'rgba(255, 107, 107, 0.8)';
                                weightFileLabel.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(220, 53, 69, 0.1))';
                                showNotification(`CSV must contain columns: ${requiredColumns.join(', ')}`, 'error');
                                return;
                            }
                            
                            // Process and validate data
                            tumorWeightsData = parsed.data.map(row => ({
                                animalId: row.Animal_ID,
                                day: parseFloat(row.Day),
                                weight: parseFloat(row.Tumor_Weight)
                            })).filter(row => 
                                row.animalId && !isNaN(row.day) && !isNaN(row.weight)
                            );
                            
                            if (tumorWeightsData.length === 0) {
                                weightFileLabel.innerHTML = `
                                    No valid weight data found
                                    <br><small style="color: #ff6b6b;">Check data format</small>
                                `;
                                weightFileLabel.style.borderColor = 'rgba(255, 107, 107, 0.8)';
                                weightFileLabel.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(220, 53, 69, 0.1))';
                                showNotification('No valid weight data found in CSV', 'error');
                                return;
                            }
                            
                            // Success
                            weightFileLabel.innerHTML = `
                                ${file.name} loaded successfully
                                <br><small style="color: #84D288; padding-left: 5px;">${tumorWeightsData.length} weight measurements</small>
                            `;
                            weightFileLabel.style.borderColor = 'rgba(132, 210, 136, 0.8)';
                            weightFileLabel.style.background = 'linear-gradient(135deg, rgba(132, 210, 136, 0.1), rgba(40, 167, 69, 0.1))';
                            
                            // Enable batch prediction button
                            document.getElementById('batchPredictBtn').disabled = false;
                            showNotification(`Loaded ${tumorWeightsData.length} weight measurements`, 'success');
                            
                        } catch (error) {
                            weightFileLabel.innerHTML = `
                                Error parsing CSV file
                                <br><small style="color: #ff6b6b;">Please check file format</small>
                            `;
                            weightFileLabel.style.borderColor = 'rgba(255, 107, 107, 0.8)';
                            weightFileLabel.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(220, 53, 69, 0.1))';
                            showNotification('Error parsing CSV file', 'error');
                            console.error('CSV parsing error:', error);
                        }
                    };
                    reader.readAsText(file);
                }
            });
            
            // Drag and drop functionality
            weightFileLabel.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.style.borderColor = 'rgba(79, 172, 254, 1)';
                this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(0, 153, 204, 0.3))';
            });
            
            weightFileLabel.addEventListener('dragleave', function(e) {
                e.preventDefault();
                this.style.borderColor = 'rgba(79, 172, 254, 0.5)';
                this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1))';
            });
            
            weightFileLabel.addEventListener('drop', function(e) {
                e.preventDefault();
                this.style.borderColor = 'rgba(79, 172, 254, 0.5)';
                this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1))';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    weightsFileInput.files = files;
                    weightsFileInput.dispatchEvent(new Event('change'));
                }
            });
        }

        function predictBatchWeights() {
            if (!tumorWeightsData) {
                showNotification('Please load tumor weights CSV first', 'warning');
                return;
            }
            
            const targetDay = parseFloat(document.getElementById('batchPredictDay').value);
            if (isNaN(targetDay)) {
                showNotification('Please enter a valid target day', 'warning');
                return;
            }
            
            const comparison = document.getElementById('batchComparison').value;
            
            // Calculate predictions for all animals
            const predictions = [];
            const experimentalWeights = [];
            
            Object.values(animalModels).forEach(animal => {
                // Find weight data for this animal
                const animalWeightData = tumorWeightsData.filter(w => w.animalId === animal.id);
                
                if (animalWeightData.length === 0) {
                    console.warn(`No weight data found for animal ${animal.id}`);
                    return;
                }
                
                // Sort by day and get the last available weight
                animalWeightData.sort((a, b) => a.day - b.day);
                const lastWeight = animalWeightData[animalWeightData.length - 1];
                
                // Calculate predicted volume/BLI for target day
                const predictedMeasurement = animal.model.a * Math.exp(animal.model.r * targetDay);
                const lastMeasurement = animal.model.a * Math.exp(animal.model.r * lastWeight.day);
                
                // Calculate predicted weight
                const weightGrowthRatio = predictedMeasurement / lastMeasurement;
                const predictedWeight = lastWeight.weight * weightGrowthRatio;
                
                // Check if experimental weight exists for target day, or get the closest available
                let experimentalWeight = animalWeightData.find(w => w.day === targetDay);
                if (!experimentalWeight && animalWeightData.length > 0) {
                    // If no exact match, get the closest day to target day
                    experimentalWeight = animalWeightData.reduce((closest, current) => {
                        return Math.abs(current.day - targetDay) < Math.abs(closest.day - targetDay) ? current : closest;
                    });
                }
                
                const predictionData = {
                    animalId: animal.id,
                    group: animal.group,
                    targetDay: targetDay,
                    predictedWeight: predictedWeight,
                    experimentalWeight: experimentalWeight ? experimentalWeight.weight : null,
                    lastKnownWeight: lastWeight.weight,
                    lastKnownDay: lastWeight.day,
                    weightGrowthRatio: weightGrowthRatio,
                    r2: animal.model.r2
                };
                
                predictions.push(predictionData);
                
                if (experimentalWeight) {
                    // Calculate prediction error EXACTLY like Single Animal Prediction
                    const predictedMeasurementForTargetDay = animal.model.a * Math.exp(animal.model.r * targetDay);
                    
                    // Check if target day is within experimental range (same logic as Single Animal)
                    const minDay = Math.min(...animal.timePoints);
                    const maxDay = Math.max(...animal.timePoints);
                    
                    let relativeError = null; // null when no validation possible
                    let actualMeasurementTargetDay = null;
                    
                    if (targetDay >= minDay && targetDay <= maxDay) {
                        // Find actual experimental value for validation (same logic as Single Animal)
                        const actualIndex = animal.timePoints.indexOf(targetDay);
                        if (actualIndex !== -1) {
                            actualMeasurementTargetDay = animal.measurements[actualIndex];
                            relativeError = Math.abs((predictedMeasurementForTargetDay - actualMeasurementTargetDay) / actualMeasurementTargetDay * 100);
                        }
                    }
                    
                    experimentalWeights.push({
                        ...predictionData,
                        experimentalWeight: experimentalWeight.weight,
                        sacrificeDay: experimentalWeight.day,
                        predictionError: relativeError,
                        actualMeasurement: actualMeasurementTargetDay,
                        predictedMeasurement: predictedMeasurementForTargetDay
                    });
                }
            });
            
            if (predictions.length === 0) {
                showNotification('No predictions could be calculated', 'warning');
                return;
            }
            
            // Store results globally
            batchPredictionResults = {
                predictions: predictions,
                experimentalWeights: experimentalWeights,
                targetDay: targetDay,
                comparison: comparison
            };
            
            // Perform statistical comparison if requested
            let comparisonResults = null;
            if (comparison === 'mann-whitney') {
                comparisonResults = performMannWhitneyComparison(predictions);
            }
            
            // Display results
            displayBatchPredictionResults(predictions, experimentalWeights, comparisonResults);
            
            showNotification(`Batch predictions calculated for ${predictions.length} animals`, 'success');
        }

        function performMannWhitneyComparison(predictions) {
            // Group predictions by experimental group
            const groups = {};
            predictions.forEach(pred => {
                if (!groups[pred.group]) {
                    groups[pred.group] = [];
                }
                groups[pred.group].push(pred.predictedWeight);
            });
            
            const groupNames = Object.keys(groups);
            const comparisons = [];
            
            // Perform pairwise Mann-Whitney U tests
            for (let i = 0; i < groupNames.length; i++) {
                for (let j = i + 1; j < groupNames.length; j++) {
                    const group1 = groupNames[i];
                    const group2 = groupNames[j];
                    const values1 = groups[group1];
                    const values2 = groups[group2];
                    
                    if (values1.length > 0 && values2.length > 0) {
                        const mannWhitneyResult = mannWhitneyUTest(values1, values2);
                        const cohensD = calculateCohensD(values1, values2);
                        
                        comparisons.push({
                            group1: group1,
                            group2: group2,
                            n1: values1.length,
                            n2: values2.length,
                            median1: calculateMedian(values1),
                            median2: calculateMedian(values2),
                            u: mannWhitneyResult.U,
                            pValue: mannWhitneyResult.p,
                            significant: mannWhitneyResult.p < 0.05,
                            cohensD: cohensD,
                            effectSize: getEffectSizeLabel(cohensD)
                        });
                    }
                }
            }
            
            return {
                groups: groups,
                comparisons: comparisons
            };
        }

        function displayBatchPredictionResults(predictions, experimentalWeights, comparisonResults) {
            const resultsDiv = document.getElementById('predictionResults');
            resultsDiv.style.display = 'block';
            
            // Summary statistics
            const groupStats = {};
            predictions.forEach(pred => {
                if (!groupStats[pred.group]) {
                    groupStats[pred.group] = [];
                }
                groupStats[pred.group].push(pred.predictedWeight);
            });
            
            let summaryHtml = `
                <h3>Batch Prediction Results (Day ${predictions[0].targetDay})</h3>
                <div style="background: transparent; border-radius: 8px; margin: 10px 0;">
                    <h4>Group Summary</h4>
                    ${Object.entries(groupStats).map(([group, weights]) => `
                        <p style="padding-left: 15px;"><strong>${group}:</strong> n=${weights.length}, median=${calculateMedian(weights).toFixed(3)}g, range=${Math.min(...weights).toFixed(3)}-${Math.max(...weights).toFixed(3)}g</p>
                    `).join('')}
                </div>
            `;
            
            // Experimental validation if available
            if (experimentalWeights.length > 0) {
                // Filter out animals where prediction error couldn't be calculated (null values)
                const validErrors = experimentalWeights.filter(w => w.predictionError !== null);
                
                let errorDisplay = '';
                let errorColor = '#666';
                
                if (validErrors.length > 0) {
                    const avgError = validErrors.reduce((sum, w) => sum + w.predictionError, 0) / validErrors.length;
                    errorColor = avgError < 10 ? '#84D288' : avgError < 20 ? '#FFAA55' : '#E68989';
                    errorDisplay = `<span style="font-weight: bold; color: ${errorColor};">${avgError.toFixed(1)}%</span>`;
                } else {
                    errorDisplay = `<span style="color: ${errorColor};">Cannot be calculated (no experimental measurements for target days)</span>`;
                }
                
                summaryHtml += `
                    <div style="background: rgba(165, 94, 234, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0px; border-left: 4px solid #a55eea;">
                        <h4 style="margin-bottom: 15px;">Prediction Validation</h4>
                        <p><strong>Animals with experimental weights:</strong> ${experimentalWeights.length}</p>
                        <p><strong>Animals with calculable errors:</strong> ${validErrors.length}</p>
                        <p><strong>Average prediction error:</strong> ${errorDisplay}</p>
                    </div>
                `;
            }
            
            // Statistical comparison results
            if (comparisonResults && comparisonResults.comparisons.length > 0) {
                summaryHtml += `
                    <div style="background: transparent; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <h4>Statistical Comparison (Mann-Whitney U Test)</h4>
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                                <thead>
                                    <tr style="background: rgba(0,0,0,0.1);">
                                        <th style="padding: 8px;text-align: left;">Comparison</th>
                                        <th style="padding: 8px; text-align: center;">n₁</th>
                                        <th style="padding: 8px; text-align: center;">n₂</th>
                                        <th style="padding: 8px; text-align: center;">Median₁ (g)</th>
                                        <th style="padding: 8px; text-align: center;">Median₂ (g)</th>
                                        <th style="padding: 8px; text-align: center;">U</th>
                                        <th style="padding: 8px; text-align: center;">p-value</th>
                                        <th style="padding: 8px; text-align: center;">Cohen's d</th>
                                        <th style="padding: 8px; text-align: center;">Significant</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${comparisonResults.comparisons.map(comp => `
                                        <tr style="background: ${comp.significant ? 'rgba(244, 67, 54, 0.1)' : 'transparent'};">
                                            <td style="padding: 8px; font-weight: bold; text-align: left;">${comp.group1} vs ${comp.group2}</td>
                                            <td style="padding: 8px; text-align: center;">${comp.n1}</td>
                                            <td style="padding: 8px; text-align: center;">${comp.n2}</td>
                                            <td style="padding: 8px; text-align: center;">${comp.median1.toFixed(3)}</td>
                                            <td style="padding: 8px; text-align: center;">${comp.median2.toFixed(3)}</td>
                                            <td style="padding: 8px; text-align: center;">${comp.u.toFixed(0)}</td>
                                            <td style="padding: 8px; text-align: center;">${comp.significant ? `<span style="color: #00f2fe; font-weight: bold;">${comp.pValue.toFixed(4)} (${getAsteriskNotation(comp.pValue)})</span>` : `${comp.pValue.toFixed(4)} (${getAsteriskNotation(comp.pValue)})`}</td>
                                            <td style="padding: 8px; text-align: center;">
                                                ${comp.effectSize}<br>
                                                <small style="color: #a0a0a0;">(d=${Math.abs(comp.cohensD).toFixed(3)})</small>
                                            </td>
                                            <td style="padding: 8px; text-align: center;">
                                                ${comp.significant ? '<span style="color: #00f2fe; font-weight: bold;">Significant</span>' : '<span style="color: #a0a0a0; font-weight: bold;">Not significant</span>'}
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        <p style="margin-top: 10px; font-size: 0.9em; color: #666;"><strong>*</strong> p < 0.05 (statistically significant)</p>
                    </div>
                `;
            }
            
            // Individual predictions table
            summaryHtml += `
                <div style="background: transparent; padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <h4>Individual Predictions</h4>
                    <div style="max-height: 400px; overflow-y: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: rgba(0,0,0,0.1);">
                                    <th style="padding: 8px; text-align: left;">Animal_ID</th>
                                    <th style="padding: 8px;">Group</th>
                                    <th style="padding: 8px;">Predicted Weight (g)<br><small>Day ${predictions[0].targetDay}</small></th>
                                    <th style="padding: 8px;">Experimental Weight (g)<br><small>Sacrifice Day</small></th>
                                    <th style="padding: 8px;">Error (%)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${predictions.map(pred => {
                                    const exp = experimentalWeights.find(e => e.animalId === pred.animalId);
                                    
                                    // Apply same color pattern as Single Animal Prediction
                                    let errorDisplay = 'N/A';
                                    let errorColor = '#666';
                                    
                                    if (exp && exp.predictionError !== null) {
                                        const percentError = exp.predictionError;
                                        errorColor = percentError < 10 ? '#84D288' : percentError < 20 ? '#FFAA55' : '#E68989';
                                        errorDisplay = `<span style="font-weight: bold; color: ${errorColor};">${percentError.toFixed(1)}%</span>`;
                                    }
                                    
                                    return `
                                        <tr>
                                            <td style="padding: 8px; text-align: left;">${pred.animalId}</td>
                                            <td style="padding: 8px;">${pred.group}</td>
                                            <td style="padding: 8px;">${pred.predictedWeight.toFixed(3)}<br><small>Day ${pred.targetDay}</small></td>
                                            <td style="padding: 8px;">${exp ? exp.experimentalWeight.toFixed(3) + '<br><small>Day ' + exp.sacrificeDay + '</small>' : 'N/A'}</td>
                                            <td style="padding: 8px;">${errorDisplay}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            // Export button
            summaryHtml += `
                <div style="margin: 15px 0;">
                    <button class="btn secondary" onclick="exportBatchPredictions()" style="margin-right: 10px;">Export CSV</button>
                    <button class="btn tertiary" onclick="addBatchPredictionToReport()">Add to Report</button>
                </div>
            `;
            
            resultsDiv.innerHTML = summaryHtml;
        }

        function exportBatchPredictions() {
            try {
                if (!batchPredictionResults) {
                    showNotification('No batch prediction results to export', 'warning');
                    return;
                }
                
                // Validate required properties
                if (!batchPredictionResults.predictions || !Array.isArray(batchPredictionResults.predictions)) {
                    showNotification('Invalid prediction data structure', 'error');
                    return;
                }
                
                if (batchPredictionResults.predictions.length === 0) {
                    showNotification('No predictions available to export', 'warning');
                    return;
                }
                
                const csvData = [
                    ['Animal_ID', 'Group', 'Target_Day', 'Predicted_Tumor_Weight', 'Experimental_Tumor_Weight', 'Prediction_Error_percent', 'R2']
                ];
                
                batchPredictionResults.predictions.forEach(pred => {
                    try {
                        // Validate prediction object
                        if (!pred || typeof pred !== 'object') {
                            console.warn('Invalid prediction object:', pred);
                            return;
                        }
                        
                        const exp = batchPredictionResults.experimentalWeights ? 
                            batchPredictionResults.experimentalWeights.find(e => e && e.animalId === pred.animalId) : null;
                        
                        csvData.push([
                            pred.animalId || '',
                            pred.group || '',
                            pred.targetDay || '',
                            (pred.predictedWeight && typeof pred.predictedWeight === 'number') ? pred.predictedWeight.toFixed(3) : '',
                            (exp && exp.experimentalWeight && typeof exp.experimentalWeight === 'number') ? exp.experimentalWeight.toFixed(3) : '',
                            (exp && exp.predictionError && typeof exp.predictionError === 'number') ? exp.predictionError.toFixed(1) : '',
                            (pred.r2 && typeof pred.r2 === 'number') ? pred.r2.toFixed(3) : ''
                        ]);
                    } catch (predError) {
                        console.warn('Error processing prediction:', pred, predError);
                    }
                });
                
                if (csvData.length <= 1) {
                    showNotification('No valid prediction data to export', 'warning');
                    return;
                }
                
                const csvContent = csvData.map(row => row.join(',')).join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `batch_weight_predictions_day${batchPredictionResults.targetDay || 'unknown'}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('Batch predictions exported successfully', 'success');
            } catch (error) {
                console.error('Error exporting batch predictions:', error);
                showNotification('Failed to export batch predictions: ' + error.message, 'error');
            }
        }

        function addBatchPredictionToReport() {
            if (!batchPredictionResults) {
                showNotification('No batch prediction results to add', 'warning');
                return;
            }
            
            // Mark batch predictions for inclusion in report
            window.batchPredictionForReport = batchPredictionResults;
            showNotification('Batch predictions will be included in next report generation', 'success');
        }

        function calculateMedian(arr) {
            const sorted = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }

        async function captureChart(chartId) {
            try {
                const chartDiv = document.getElementById(chartId);
                if (chartDiv && chartDiv.data) {
                    // Guardar configuración original
                    const originalLayout = JSON.parse(JSON.stringify(chartDiv.layout));
                    const originalData = JSON.parse(JSON.stringify(chartDiv.data));

                    // Configuración optimizada para el reporte
                    const reportLayout = {
                        ...chartDiv.layout,
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        plot_bgcolor: 'rgba(0,0,0,0)',
                        font: {
                            family: 'Segoe UI, Arial, sans-serif',
                            size: 14,
                            color: '#1a202c'
                        },
                        xaxis: {
                            ...chartDiv.layout.xaxis,
                            title: {
                                ...chartDiv.layout.xaxis?.title,
                                font: { family: 'Segoe UI', size: 16, color: '#1a202c' }
                            },
                            tickfont: { family: 'Segoe UI', size: 12, color: '#2d3748' },
                            gridcolor: '#e2e8f0',
                            linecolor: '#4a5568',
                            zerolinecolor: '#4a5568'
                        },
                        yaxis: {
                            ...chartDiv.layout.yaxis,
                            title: {
                                ...chartDiv.layout.yaxis?.title,
                                font: { family: 'Segoe UI', size: 16, color: '#1a202c' }
                            },
                            tickfont: { family: 'Segoe UI', size: 12, color: '#2d3748' },
                            gridcolor: '#e2e8f0',
                            linecolor: '#4a5568',
                            zerolinecolor: '#4a5568'
                        },
                        title: {
                            ...chartDiv.layout.title,
                            font: { family: 'Segoe UI', size: 18, color: '#1e3a5f' }
                        },
                        legend: {
                            ...chartDiv.layout.legend,
                            font: { family: 'Segoe UI', size: 12, color: '#1a202c' },
                            bgcolor: 'rgba(255,255,255,0.9)',
                            bordercolor: '#e2e8f0',
                            borderwidth: 1
                        }
                    };

                    // Colores profesionales
                    const professionalColors = [
                        '#1e3a5f', '#2c5282', '#22543d', '#c53030',
                        '#d69e2e', '#553c9a', '#2d3748', '#4a5568'
                    ];

                    const reportData = chartDiv.data.map((trace, index) => ({
                        ...trace,
                        line: {
                            ...trace.line,
                            color: professionalColors[index % professionalColors.length],
                            width: 3
                        },
                        marker: {
                            ...trace.marker,
                            color: professionalColors[index % professionalColors.length],
                            size: 6,
                            line: { color: '#ffffff', width: 1 }
                        }
                    }));

                    // APLICAR CAMBIOS TEMPORALMENTE AL GRÁFICO REAL
                    await Plotly.react(chartDiv, reportData, reportLayout);

                    // Esperar un poco para que se renderice
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Capturar imagen
                    const imgData = await Plotly.toImage(chartDiv, {
                        format: 'png',
                        width: 900,
                        height: 500,
                        scale: 2
                    });

                    // RESTAURAR configuración original
                    await Plotly.react(chartDiv, originalData, originalLayout);

                    return imgData;
                }
            } catch (error) {
                debugError(`Could not capture chart ${chartId}:`, error);
                return null;
            }
            return null;
        }

        // Función para capturar matrices como HTML
        function captureMatrices() {
            const matricesContainer = document.querySelector('.matrices-container');
            if (!matricesContainer) return '';

            // Crear versión simplificada para el informe
            let matricesHTML = '<h2>Tumor Growth Rate Matrices (TGR)</h2>';

            // Leyenda corregida - usar escala actual (personalizada o automática)
            const currentRange = customColorRange || optimizedColorRange;
            matricesHTML += `
                <div style="text-align: center; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <p><strong>Scale:</strong> 
                        <span style="background: rgb(100,200,100); padding: 2px 8px; border-radius: 3px; color: #000;">🟢 Green = Low</span>
                        <span style="background: rgb(255,255,0); padding: 2px 8px; border-radius: 3px; margin: 0 5px; color: #000;">🟡 Yellow = Medium</span>
                        <span style="background: rgb(255,0,100); padding: 2px 8px; border-radius: 3px; color: #fff;">🔴 Red = High</span>
                    </p>
                    <p><strong>Range:</strong> ${currentRange.min.toFixed(4)} to ${currentRange.max.toFixed(4)}</p>
                    <p><strong>Control group:</strong> ${controlGroup}</p>
                    ${customColorRange ? '<p><strong>Custom scale active</strong></p>' : '<p>Automatic scale</p>'}
                </div>
            `;

            // Apply the same stacking logic as web-app visualization
            const numGroups = Object.keys(growthMatrices).length;
            const hasLargeMatrices = Object.values(growthMatrices).some(matrix => matrix.days.length > 9);
            
            let gridStyle = 'display: grid; gap: 20px;';
            if (hasLargeMatrices) {
                // For large matrices, stack them vertically (single column)
                gridStyle += ' grid-template-columns: 1fr; max-width: 100%;';
            } else if (numGroups <= 2) {
                gridStyle += ' grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));';
            } else if (numGroups === 3) {
                gridStyle += ' grid-template-columns: repeat(2, 1fr); grid-auto-flow: row;';
            } else {
                gridStyle += ' grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));';
            }
            
            matricesHTML += `<div style="${gridStyle}">`;

            Object.entries(growthMatrices).forEach(([group, matrix]) => {
                matricesHTML += `
                    <div style="border: none; border-radius: 8px; padding: 15px; ${hasLargeMatrices ? 'max-width: 100%; overflow-x: auto;' : ''}">
                        <h3 style="text-align: center; color: #2c3e50; margin-bottom: 15px;">${group}</h3>
                        ${createReportMatrixTable(matrix, group)}
                    </div>
                `;
            });

            matricesHTML += '</div>';
            
            // Add TGR comparisons if any exist
            if (tgrComparisons && tgrComparisons.length > 0) {
                matricesHTML += captureTGRComparisons();
            }
            
            return matricesHTML;
        }

        function captureTGRComparisons() {
            if (!tgrComparisons || tgrComparisons.length === 0) return '';
            
            let comparisonsHTML = '<div style="margin-top: 30px; border-top: 2px solid #e0e0e0; padding-top: 20px;">';
            comparisonsHTML += '<h3 style="color: #2c3e50; margin-bottom: 20px;">TGR Statistical Comparisons</h3>';
            
            tgrComparisons.forEach((comparison, index) => {
                const significance = comparison.mannWhitney.pValue < 0.05 ? 'Significant' : 'Not significant';
                const significanceColor = comparison.mannWhitney.pValue < 0.05 ? 'linear-gradient(45deg, #22c55e, #16a34a)' : 'linear-gradient(45deg, #ef4444, #dc2626)';
                const significanceTextColor = 'white';
                
                comparisonsHTML += `
                    <div style="margin-bottom: 25px; border: 1px solid #e0e0e0; border-radius: 8px; padding: 20px; background: white;">
                        <h4 style="color: #1e3a5f; margin-bottom: 15px;">${comparison.cell1.group} r(D${comparison.cell1.dayX}→D${comparison.cell1.dayY}) vs ${comparison.cell2.group} r(D${comparison.cell2.dayX}→D${comparison.cell2.dayY})</h4>                     
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <thead>
                                <tr style="background: #edf2f7;">
                                    <th style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; color: white;">Group</th>
                                    <th style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; color: white;">N</th>
                                    <th style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; color: white;">Median</th>
                                    <th style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; color: white;">Mann-Whitney U</th>
                                    <th style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; color: white;">p-value</th>
                                    <th style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; color: white;">Cohen's d</th>
                                    <th style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; color: white;">Significance</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="padding: 12px; border: 1px solid #e0e0e0; text-align: center;">${comparison.cell1.group}</td>
                                    <td style="padding: 12px; border: 1px solid #e0e0e0; text-align: center;">${comparison.data1.length}</td>
                                    <td style="padding: 12px; border: 1px solid #e0e0e0; text-align: center;">${comparison.median1.toFixed(4)}</td>
                                    <td rowspan="2" style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; vertical-align: middle;">${comparison.mannWhitney.U.toFixed(2)}</td>
                                    <td rowspan="2" style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; vertical-align: middle;">${comparison.mannWhitney.pValue.toFixed(4)}</td>
                                    <td rowspan="2" style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; vertical-align: middle;">${Math.abs(comparison.cohensD).toFixed(3)}</td>
                                    <td rowspan="2" style="padding: 12px; border: 1px solid #e0e0e0; text-align: center; vertical-align: middle; background: ${significanceColor}; color: ${significanceTextColor}; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.3); box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${significance}</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px; border: 1px solid #e0e0e0; text-align: center;">${comparison.cell2.group}</td>
                                    <td style="padding: 12px; border: 1px solid #e0e0e0; text-align: center;">${comparison.data2.length}</td>
                                    <td style="padding: 12px; border: 1px solid #e0e0e0; text-align: center;">${comparison.median2.toFixed(4)}</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                `;
            });
            
            comparisonsHTML += '</div>';
            return comparisonsHTML;
        }

        function createReportMatrixTable(matrix, groupName = '') {
            const days = matrix.days;
            const currentRange = customColorRange || optimizedColorRange;
            const isLargeMatrix = days.length > 9;
            
            // Adjust styling for large matrices
            const fontSize = isLargeMatrix ? '0.7rem' : '0.8em';
            const maxWidth = isLargeMatrix ? '100%' : '600px';
            const tableStyle = `width: 100%; border-collapse: collapse; font-size: ${fontSize}; margin: 0 auto; font-family: 'Courier New', monospace; max-width: ${maxWidth}; ${isLargeMatrix ? 'min-width: fit-content;' : ''}`;

            // Adjust padding for large matrices
            const cellPadding = isLargeMatrix ? '4px' : '6px';
            
            let html = `<table style="${tableStyle}">`;
            html += `<thead><tr style="background: #3498db; color: white;"><th style="padding: ${cellPadding}; border: 1px solid #ddd; font-weight: bold;"></th>`;

            // Column headers (skip first day) - same as web version
            days.slice(1).forEach(day => {
                html += `<th style="padding: ${cellPadding}; border: 1px solid #ddd; font-weight: bold;">D${day}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Data rows (skip last day as it would be empty) - same as web version
            days.slice(0, -1).forEach((dayRow, i) => {
                html += `<tr><th style="padding: ${cellPadding}; border: 1px solid #ddd; background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); color: white; font-weight: bold;">D${dayRow}</th>`;
                
                days.slice(1).forEach((dayCol, j) => {
                    const actualJ = j + 1; // Adjust for sliced array
                    let cellContent = '';
                    let cellStyle = `border: 1px solid #ddd; padding: ${cellPadding}; text-align: center; font-weight: 500;`;
                    
                    if (actualJ <= i) {
                        // Empty cell for lower triangle and diagonal - same as web version
                        cellContent = '';
                        cellStyle += 'background: transparent;';
                    } else {
                        // Upper triangle with TGR values - same as web version
                        const value = matrix.values[i][actualJ];
                        cellContent = value !== null && !isNaN(value) ? value.toFixed(4) : '—';
                        
                        if (value !== null && !isNaN(value)) {
                            // Apply colors using the same function as web version
                            const bgColor = getOptimizedColorForValue(value);
                            const textColor = getContrastColor(bgColor);
                            cellStyle += `background-color: ${bgColor}; color: ${textColor};`;
                        }
                    }

                    html += `<td style="${cellStyle}">${cellContent}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        function createReportColorLegend() {
            const currentRange = customColorRange || optimizedColorRange;

            return `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 20px 0; border: 1px solid #dee2e6; page-break-inside: avoid;">
                <h4 style="color: #2c3e50; margin: 0 0 10px 0; text-align: center;">Matrix Color Scale</h4>
                
                <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin: 10px 0; flex-wrap: wrap;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: rgb(100, 200, 100); border: 1px solid #ccc; border-radius: 3px;"></div>
                        <span style="font-size: 0.9em;">Low: ${currentRange.min.toFixed(4)}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: rgb(255, 255, 0); border: 1px solid #ccc; border-radius: 3px;"></div>
                        <span style="font-size: 0.9em;">Medium</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 20px; height: 20px; background: rgb(255, 0, 100); border: 1px solid #ccc; border-radius: 3px;"></div>
                        <span style="font-size: 0.9em;">High: ${currentRange.max.toFixed(4)}</span>
                    </div>
                </div>
                
                <div style="text-align: center; font-size: 0.8em; color: #666; margin-top: 10px;">
                    <strong>Control group:</strong> ${controlGroup}
                    ${customColorRange ? ' • <strong>Custom scale</strong>' : ' • Automatic scale'}
                </div>
                
                <div style="text-align: center; font-size: 0.8em; color: #666; margin-top: 5px; font-style: italic;">
                    Colors represent growth rates r(x→y) = log(V_y/V_x)/(t_y-t_x)
                </div>
                </div>
            `;
        }

        // Función para capturar predicciones existentes
        function capturePredictions() {
            try {
                const predictionResults = document.getElementById('predictionResults');
                let hasPredictions = predictionResults && predictionResults.style.display !== 'none';
                let hasBatchPredictions = window.batchPredictionForReport;
                
                if (!hasPredictions && !hasBatchPredictions) {
                    return '';
                }

                let content = '';
                
                // Prioritize batch predictions over individual predictions to avoid duplication
                // If we have batch predictions, use them exclusively as they contain more comprehensive data
                if (hasBatchPredictions) {
                    try {
                        content += generateBatchPredictionReportHTML(window.batchPredictionForReport);
                    } catch (error) {
                        console.warn('Error capturing batch predictions:', error);
                        content += `
                            <h3>Batch Tumor Weight Predictions</h3>
                            <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #f44336; margin-bottom: 20px;">
                                <p style="color: #d32f2f;">Error loading batch predictions: ${error.message}</p>
                            </div>
                        `;
                    }
                } else if (hasPredictions) {
                    // Only capture individual predictions if no batch predictions exist
                    try {
                        // Check if the DOM content contains batch prediction data (to avoid duplication)
                        const domContent = predictionResults.innerHTML || '';
                        const isBatchData = domContent.includes('Statistical Comparison') || domContent.includes('Group Statistics');
                        
                        if (isBatchData) {
                            // If DOM contains batch data but we don't have window.batchPredictionForReport,
                            // create a simplified version to avoid showing raw HTML
                            content += `
                                <h3>Batch Tumor Weight Predictions</h3>
                                <div style="background: #fff3e0; padding: 20px; border-radius: 8px; border-left: 4px solid #f57c00; margin-bottom: 20px;">
                                    <p><strong>Note:</strong> Batch prediction results are available in the analysis panel above.</p>
                                    <p>For detailed statistics and comparisons, please refer to the main analysis section.</p>
                                </div>
                            `;
                        } else {
                            // True individual predictions
                            content += `
                                <h3>Individual Animal Predictions</h3>
                                <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; border-left: 4px solid #2196f3; margin-bottom: 20px;">
                                    ${domContent || 'No individual predictions available'}
                                </div>
                            `;
                        }
                    } catch (error) {
                        console.warn('Error capturing individual predictions:', error);
                        content += `
                            <h3>Individual Animal Predictions</h3>
                            <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #f44336; margin-bottom: 20px;">
                                <p style="color: #d32f2f;">Error loading individual predictions</p>
                            </div>
                        `;
                    }
                }
                
                return `
                    <h2>Predictions Made</h2>
                    ${content}
                `;
            } catch (error) {
                console.error('Error in capturePredictions:', error);
                return `
                    <h2>Predictions Made</h2>
                    <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #f44336; margin-bottom: 20px;">
                        <p style="color: #d32f2f;">Error loading predictions data</p>
                    </div>
                `;
            }
        }

        function generateBatchPredictionReportHTML(batchResults) {
            try {
                // Validate input parameters
                if (!batchResults || typeof batchResults !== 'object') {
                    throw new Error('Invalid batch results object');
                }
                
                const predictions = batchResults.predictions;
                const experimentalWeights = batchResults.experimentalWeights || [];
                const targetDay = batchResults.targetDay;
                
                // Validate predictions array
                if (!predictions || !Array.isArray(predictions)) {
                    throw new Error('Invalid predictions array');
                }
                
                if (predictions.length === 0) {
                    return `
                        <h3>Batch Tumor Weight Predictions</h3>
                        <div style="background: #fff3e0; padding: 20px; border-radius: 8px; border-left: 4px solid #f57c00; margin-bottom: 20px;">
                            <p style="color: #e65100;">No predictions available</p>
                        </div>
                    `;
                }
                
                // Group statistics with error handling
                const groupStats = {};
                predictions.forEach(pred => {
                    if (pred && pred.group && typeof pred.predictedWeight === 'number') {
                        if (!groupStats[pred.group]) {
                            groupStats[pred.group] = [];
                        }
                        groupStats[pred.group].push(pred.predictedWeight);
                    }
                });
                
                // Statistical comparison if available
                let comparisonHTML = '';
                if (batchResults.comparison === 'mann-whitney') {
                    try {
                        const comparisonResults = performMannWhitneyComparison(predictions);
                        if (comparisonResults && comparisonResults.comparisons && comparisonResults.comparisons.length > 0) {
                            comparisonHTML = `
                                <h4>Statistical Comparison (Mann-Whitney U)</h4>
                                <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                                    <thead>
                                        <tr style="background: #f5f5f5;">
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Comparison</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">n1</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">n2</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Median 1 (g)</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Median 2 (g)</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">U</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">p-value</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Cohen's d</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Effect Size</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${comparisonResults.comparisons.map(comp => {
                                            if (!comp || typeof comp !== 'object') return '';
                                            
                                            // Generate asterisk notation for p-value
                                            let pValueDisplay = 'N/A';
                                            let asterisks = '';
                                            if (comp.pValue && typeof comp.pValue === 'number') {
                                                if (comp.pValue < 0.001) {
                                                    asterisks = '***';
                                                } else if (comp.pValue < 0.01) {
                                                    asterisks = '**';
                                                } else if (comp.pValue < 0.05) {
                                                    asterisks = '*';
                                                } else {
                                                    asterisks = 'n.s.';
                                                }
                                                pValueDisplay = `${comp.pValue.toFixed(4)} (${asterisks})`;
                                            }
                                            
                                            return `
                                                <tr>
                                                    <td style="padding: 8px; border: 1px solid #ddd;">${comp.group1 || 'N/A'} vs ${comp.group2 || 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${comp.n1 || 0}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${comp.n2 || 0}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(comp.median1 && typeof comp.median1 === 'number') ? comp.median1.toFixed(3) : 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(comp.median2 && typeof comp.median2 === 'number') ? comp.median2.toFixed(3) : 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(comp.u && typeof comp.u === 'number') ? comp.u.toFixed(0) : 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${pValueDisplay}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(comp.cohensD && typeof comp.cohensD === 'number') ? comp.cohensD.toFixed(3) : 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${comp.effectSize || 'N/A'}</td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            `;
                        }
                    } catch (compError) {
                        console.warn('Error in statistical comparison:', compError);
                        comparisonHTML = `
                            <h4>Statistical Comparison (Mann-Whitney U)</h4>
                            <p style="color: #d32f2f;">Error generating statistical comparison</p>
                        `;
                    }
                }
                
                // Validation summary if available
                let validationHTML = '';
                if (experimentalWeights && experimentalWeights.length > 0) {
                    try {
                        const validWeights = experimentalWeights.filter(w => w && typeof w.predictionError === 'number');
                        if (validWeights.length > 0) {
                            const avgError = validWeights.reduce((sum, w) => sum + w.predictionError, 0) / validWeights.length;
                            const errorsByRange = {
                                excellent: validWeights.filter(w => w.predictionError < 10).length,
                                good: validWeights.filter(w => w.predictionError >= 10 && w.predictionError < 20).length,
                                fair: validWeights.filter(w => w.predictionError >= 20).length
                            };
                            
                            validationHTML = `
                                <h4>Prediction Validation</h4>
                                <p><strong>Animals with experimental weights:</strong> ${validWeights.length} of ${predictions.length}</p>
                                <p><strong>Average prediction error:</strong> ${avgError.toFixed(1)}%</p>
                                <p><strong>Error distribution:</strong> Excellent (&lt;10%): ${errorsByRange.excellent}, Good (10-20%): ${errorsByRange.good}, Fair (&gt;20%): ${errorsByRange.fair}</p>
                            `;
                        }
                    } catch (valError) {
                        console.warn('Error in validation summary:', valError);
                        validationHTML = `
                            <h4>Prediction Validation</h4>
                            <p style="color: #d32f2f;">Error generating validation summary</p>
                        `;
                    }
                }
                
                return `
                    <h3>Batch Tumor Weight Predictions</h3>
                    <div style="background: #fff3e0; padding: 20px; border-radius: 8px; border-left: 4px solid #f57c00; margin-bottom: 20px;">
                        <h4>Summary (Target Day: ${targetDay || 'N/A'})</h4>
                        <p><strong>Total animals predicted:</strong> ${predictions.length}</p>
                        
                        <h4>Group Statistics</h4>
                        <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                            <thead>
                                <tr style="background: #f5f5f5;">
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Group</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">n</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Median (g)</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Range (g)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.entries(groupStats).map(([group, weights]) => {
                                    if (!weights || weights.length === 0) return '';
                                    try {
                                        return `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd;">${group}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${weights.length}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${calculateMedian(weights).toFixed(3)}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${Math.min(...weights).toFixed(3)} - ${Math.max(...weights).toFixed(3)}</td>
                                            </tr>
                                        `;
                                    } catch (error) {
                                        console.warn('Error processing group stats for:', group, error);
                                        return `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd;">${group}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${weights.length}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                            </tr>
                                        `;
                                    }
                                }).join('')}
                            </tbody>
                        </table>
                        
                        ${validationHTML}
                        ${comparisonHTML}
                        
                        <h4>Individual Predictions</h4>
                        <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                            <thead>
                                <tr style="background: #f5f5f5;">
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Animal ID</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Group</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Predicted Weight (g)</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Experimental Weight (g)</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error (%)</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">R²</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${predictions.map(pred => {
                                    if (!pred || typeof pred !== 'object') return '';
                                    try {
                                        const exp = experimentalWeights ? experimentalWeights.find(e => e && e.animalId === pred.animalId) : null;
                                        return `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd;">${pred.animalId || 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${pred.group || 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(pred.predictedWeight && typeof pred.predictedWeight === 'number') ? pred.predictedWeight.toFixed(3) : 'N/A'} (Day ${pred.targetDay || 'N/A'})</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(exp && exp.experimentalWeight && typeof exp.experimentalWeight === 'number') ? exp.experimentalWeight.toFixed(3) + ' (Day ' + (exp.sacrificeDay || 'N/A') + ')' : 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(exp && exp.predictionError && typeof exp.predictionError === 'number') ? exp.predictionError.toFixed(1) + '%' : 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(pred.r2 && typeof pred.r2 === 'number') ? pred.r2.toFixed(3) : 'N/A'}</td>
                                            </tr>
                                        `;
                                    } catch (predError) {
                                        console.warn('Error processing prediction:', pred, predError);
                                        return `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd;">${pred.animalId || 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                            </tr>
                                        `;
                                    }
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            } catch (error) {
                console.error('Error in generateBatchPredictionReportHTML:', error);
                return `
                    <h3>Batch Tumor Weight Predictions</h3>
                    <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #f44336; margin-bottom: 20px;">
                        <p style="color: #d32f2f;">Error generating batch prediction report: ${error.message}</p>
                    </div>
                `;
            }
        }

        function generateStatisticalComparisonHTML() {
            const groups = Object.keys(processedData.groupStats);
            
            // Only include comparison if there are 2 or more groups with valid animals
            const validGroups = groups.filter(group => 
                processedData.groupStats[group].validAnimals.length > 1
            );
            
            if (validGroups.length < 2) {
                return null; // Don't include section if insufficient data for comparison
            }

            // Perform statistical comparisons
            const comparisons = performStatisticalComparison();

            if (comparisons.length === 0) {
                return null;
            }

            let html = `
                <div class="summary-box">
                    <h2>Statistical Comparison of Growth Rates</h2>
                    <p style="color: #4a5568; margin-bottom: 20px; font-style: italic;">
                        Pairwise comparisons using Mann-Whitney U test (non-parametric, rank-based analysis)
                    </p>
                    
                    <div style="overflow-x: auto; margin: 20px 0;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
                            <thead>
                                <tr style="background: #f7fafc; border-bottom: 2px solid #e2e8f0;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: white;">Comparison</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Group 1<br><small>(median, n)</small></th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Group 2<br><small>(median, n)</small></th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Median Diff</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">U-statistic</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Z-statistic</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">p-value</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Effect Size</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Significance</th>
                                </tr>
                            </thead>
                            <tbody>
            `;

            comparisons.forEach((comp, index) => {
                const significanceColor = comp.significant ? '#22543d' : '#4a5568';
                const significanceText = comp.significant ? 'Significant' : 'Not significant';
                const pValueText = comp.pValue < 0.001 ? '<0.001' : comp.pValue.toFixed(3);
                const asterisks = getAsteriskNotation(comp.pValue);
                const rowBg = index % 2 === 0 ? '#ffffff' : '#f8f9fa';
                const diffColor = comp.medianDiff > 0 ? '#2b6cb0' : '#c53030';
                
                html += `
                    <tr style="background: ${rowBg}; border-bottom: 1px solid #e2e8f0;">
                        <td style="padding: 12px; text-align: left; font-weight: bold; color: #1a202c;">${comp.group1} vs ${comp.group2}</td>
                        <td style="padding: 12px; text-align: center;">${comp.median1.toFixed(4)}<br><small style="color: #4a5568;">(n=${comp.n1})</small></td>
                        <td style="padding: 12px; text-align: center;">${comp.median2.toFixed(4)}<br><small style="color: #4a5568;">(n=${comp.n2})</small></td>
                        <td style="padding: 12px; text-align: center; color: ${diffColor}; font-weight: bold;">
                            ${comp.medianDiff > 0 ? '+' : ''}${comp.medianDiff.toFixed(4)}
                        </td>
                        <td style="padding: 12px; text-align: center;">${comp.UStatistic.toFixed(1)}</td>
                        <td style="padding: 12px; text-align: center;">${comp.zStatistic.toFixed(3)}</td>
                        <td style="padding: 12px; text-align: center; color: ${significanceColor}; font-weight: bold;">
                            ${pValueText}
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            ${comp.effectSize}<br>
                            <small style="color: #4a5568;">(d=${comp.cohensD.toFixed(3)})</small>
                        </td>
                        <td style="padding: 12px; text-align: center; color: ${significanceColor}; font-weight: bold;">
                            ${significanceText}
                        </td>
                    </tr>
                `;
            });

            html += `
                            </tbody>
                        </table>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: #e6fffa; border-radius: 8px; border-left: 4px solid #38b2ac;">
                        <h4 style="margin: 0 0 10px 0; color: #234e52;">Statistical Notes:</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #2d3748; font-size: 0.9rem; line-height: 1.5;">
                            <li>Two-tailed Mann-Whitney U test (non-parametric, rank-based)</li>
                            <li>Significance level: α = 0.05</li>
                            <li>Effect size (Cohen's d): Small=0.2, Medium=0.5, Large=0.8</li>
                            <li>U = Mann-Whitney U statistic, Z = standardized test statistic</li>
                            <li>Medians reported instead of means for non-parametric analysis</li>
                        </ul>
                    </div>
                </div>
            `;

            return html;
        }

        // TGR Matrix Comparison Functionality
        let selectedCells = [];
        let tgrComparisons = [];

        function selectTGRCell(cellElement) {
            const group = cellElement.dataset.group;
            const dayX = parseInt(cellElement.dataset.dayX);
            const dayY = parseInt(cellElement.dataset.dayY);
            const value = parseFloat(cellElement.dataset.value);
            
            if (isNaN(value)) return;
            
            const cellId = `${group}-${dayX}-${dayY}`;
            const existingIndex = selectedCells.findIndex(cell => cell.id === cellId);
            
            if (existingIndex !== -1) {
                // Deselect cell
                selectedCells.splice(existingIndex, 1);
                cellElement.classList.remove('tgr-selected');
                cellElement.style.border = '';
                cellElement.style.boxShadow = '';
            } else {
                // Select cell
                const cellData = {
                    id: cellId,
                    element: cellElement,
                    group: group,
                    dayX: dayX,
                    dayY: dayY,
                    value: value
                };
                selectedCells.push(cellData);
                cellElement.classList.add('tgr-selected');
                
                // If we have 2 cells selected, perform comparison
                if (selectedCells.length === 2) {
                    performTGRComparison();
                }
            }
            
            updateSelectedCellsDisplay();
        }

        function updateSelectedCellsDisplay() {
            // Update visual feedback for selected cells
            document.querySelectorAll('.tgr-selected').forEach(cell => {
                cell.style.border = '3px solid #007bff';
                cell.style.boxShadow = '0 0 15px rgba(0,123,255,0.6)';
            });
            
            // Add/remove body class to change hover behavior
            if (selectedCells.length > 0) {
                document.body.classList.add('has-selected-cell');
            } else {
                document.body.classList.remove('has-selected-cell');
            }
        }

        function performTGRComparison() {
            if (selectedCells.length !== 2) return;
            
            const cell1 = selectedCells[0];
            const cell2 = selectedCells[1];
            
            // Check if this comparison already exists
            const exists = tgrComparisons.some(comp => 
                (comp.cell1.group === cell1.group && comp.cell2.group === cell2.group && 
                 comp.cell1.dayX === cell1.dayX && comp.cell1.dayY === cell1.dayY &&
                 comp.cell2.dayX === cell2.dayX && comp.cell2.dayY === cell2.dayY) ||
                (comp.cell1.group === cell2.group && comp.cell2.group === cell1.group && 
                 comp.cell1.dayX === cell2.dayX && comp.cell1.dayY === cell2.dayY &&
                 comp.cell2.dayX === cell1.dayX && comp.cell2.dayY === cell1.dayY)
            );
            
            if (exists) {
                showNotification('This comparison already exists', 'info');
                clearCellSelection();
                return;
            }
            
            // Get individual TGR data for both cells
            const data1 = getTGRIndividualData(cell1.group, cell1.dayX, cell1.dayY);
            const data2 = getTGRIndividualData(cell2.group, cell2.dayX, cell2.dayY);
            
            if (!data1 || !data2 || data1.length === 0 || data2.length === 0) {
                showNotification('No individual data available for comparison', 'warning');
                clearCellSelection();
                return;
            }
            
            // Perform Mann-Whitney U test
            const mannWhitneyResult = mannWhitneyUTestTGR(data1, data2);
            const cohensD = calculateCohensD(data1, data2);
            
            const comparison = {
                id: Date.now(),
                cell1: cell1,
                cell2: cell2,
                data1: data1,
                data2: data2,
                mannWhitney: mannWhitneyResult,
                cohensD: cohensD,
                median1: calculateMedian(data1),
                median2: calculateMedian(data2)
            };
            
            tgrComparisons.push(comparison);
            displayTGRComparison(comparison);
            updateClearAllButtonState();
            
            // Clear selection
            clearCellSelection();
        }

        function getTGRIndividualData(group, dayX, dayY) {
            const matrix = growthMatrices[group];
            if (!matrix || !matrix.individualData) return null;
            
            const key = `${dayX}-${dayY}`;
            return matrix.individualData[key] || null;
        }

        function mannWhitneyUTestTGR(data1, data2) {
            const n1 = data1.length;
            const n2 = data2.length;
            
            // Combine and rank data
            const combined = [...data1.map(x => ({value: x, group: 1})), 
                             ...data2.map(x => ({value: x, group: 2}))];
            combined.sort((a, b) => a.value - b.value);
            
            // Assign ranks (handling ties)
            let ranks = [];
            let i = 0;
            while (i < combined.length) {
                let j = i;
                while (j < combined.length && combined[j].value === combined[i].value) {
                    j++;
                }
                const avgRank = (i + j + 1) / 2;
                for (let k = i; k < j; k++) {
                    ranks.push(avgRank);
                }
                i = j;
            }
            
            // Calculate U statistic
            let R1 = 0;
            for (let k = 0; k < combined.length; k++) {
                if (combined[k].group === 1) {
                    R1 += ranks[k];
                }
            }
            
            const U1 = R1 - (n1 * (n1 + 1)) / 2;
            const U2 = n1 * n2 - U1;
            const U = Math.min(U1, U2);
            
            // Calculate z-score and p-value for large samples
            const meanU = (n1 * n2) / 2;
            const stdU = Math.sqrt((n1 * n2 * (n1 + n2 + 1)) / 12);
            const zScore = (U - meanU) / stdU;
            const pValue = 2 * (1 - normalCDF(Math.abs(zScore)));
            
            return {
                U: U,
                zScore: zScore,
                pValue: pValue
            };
        }

        function normalCDF(x) {
            // Approximation of normal CDF
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }

        function erf(x) {
            // Approximation of error function
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;
            
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);
            
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return sign * y;
        }

        function calculateCohensD(data1, data2) {
            const mean1 = data1.reduce((a, b) => a + b, 0) / data1.length;
            const mean2 = data2.reduce((a, b) => a + b, 0) / data2.length;
            
            const var1 = data1.reduce((acc, x) => acc + Math.pow(x - mean1, 2), 0) / (data1.length - 1);
            const var2 = data2.reduce((acc, x) => acc + Math.pow(x - mean2, 2), 0) / (data2.length - 1);
            
            const pooledSD = Math.sqrt(((data1.length - 1) * var1 + (data2.length - 1) * var2) / 
                                     (data1.length + data2.length - 2));
            
            return (mean1 - mean2) / pooledSD;
        }

        function calculateMedian(data) {
            const sorted = [...data].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? 
                   (sorted[mid - 1] + sorted[mid]) / 2 : 
                   sorted[mid];
        }

        function displayTGRComparison(comparison) {
            const container = document.getElementById('tgrComparisonsContainer');
            if (!container) {
                console.error('TGR comparisons container not found');
                return;
            }
            
            const comparisonDiv = document.createElement('div');
            comparisonDiv.className = 'tgr-comparison-result';
            comparisonDiv.id = `comparison-${comparison.id}`;
            
            const significance = comparison.mannWhitney.pValue < 0.05 ? 'Significant' : 'Not significant';
            const significanceClass = comparison.mannWhitney.pValue < 0.05 ? 'significant' : 'not-significant';
            
            const significanceColor = comparison.mannWhitney.pValue < 0.05 ? '#00f2fe' : '#a0a0a0';
            const pValueText = comparison.mannWhitney.pValue < 0.001 ? '<0.001' : comparison.mannWhitney.pValue.toFixed(3);
            const asterisks = getAsteriskNotation(comparison.mannWhitney.pValue);
            const medianDiff = comparison.median1 - comparison.median2;
            const effectSizeLabel = getEffectSizeLabel(Math.abs(comparison.cohensD));
            
            comparisonDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 25px; padding-bottom: 0px; border-bottom: 1px solid #333;">
                    <h4 style="margin: 0; color: #4facfe;">${comparison.cell1.group} r(D${comparison.cell1.dayX}→D${comparison.cell1.dayY}) vs ${comparison.cell2.group} r(D${comparison.cell2.dayX}→D${comparison.cell2.dayY})</h4>
                    <button onclick="removeTGRComparison(${comparison.id})" style="background: #ff6b6b; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 16px; line-height: 1;">×</button>
                </div>
                <div style="overflow-x: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th style="text-align: left">Comparison</th>
                                <th>Group 1 (n)</th>
                                <th>Group 2 (n)</th>
                                <th>Median Diff</th>
                                <th>U-statistic</th>
                                <th>Z-statistic</th>
                                <th>p-value</th>
                                <th>Effect Size</th>
                                <th>Significance</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="font-weight: bold; text-align: left;">${comparison.cell1.group} vs ${comparison.cell2.group}</td>
                                <td>${comparison.median1.toFixed(4)} (${comparison.data1.length})</td>
                                <td>${comparison.median2.toFixed(4)} (${comparison.data2.length})</td>
                                <td style="color: ${medianDiff > 0 ? '#4facfe' : '#ff6b6b'};">
                                    ${medianDiff > 0 ? '+' : ''}${medianDiff.toFixed(4)}
                                </td>
                                <td>${comparison.mannWhitney.U.toFixed(1)}</td>
                                <td>${comparison.mannWhitney.zScore.toFixed(3)}</td>
                                <td style="color: ${significanceColor}; font-weight: bold;">
                                    ${pValueText}${asterisks ? ` (${asterisks})` : ''}
                                </td>
                                <td>
                                    ${effectSizeLabel}<br>
                                    <small style="color: #a0a0a0;">(d=${Math.abs(comparison.cohensD).toFixed(3)})</small>
                                </td>
                                <td style="color: ${significanceColor}; font-weight: bold;">
                                    ${significance}
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            `;
            
            // Insert the comparison before the statistical notes
            const statisticalNotes = document.getElementById('tgrStatisticalNotes');
            if (statisticalNotes) {
                container.insertBefore(comparisonDiv, statisticalNotes);
                // Show statistical notes if this is the first comparison
                if (tgrComparisons.length === 1) {
                    statisticalNotes.style.display = 'block';
                }
            } else {
                container.appendChild(comparisonDiv);
            }
        }

        function createTGRComparisonsContainer() {
            const existingContainer = document.getElementById('tgrComparisonsContainer');
            if (existingContainer) return existingContainer;
            
            const tgrCard = Array.from(document.querySelectorAll('.result-card')).find(card => {
                const h2 = card.querySelector('h2');
                return h2 && h2.textContent.includes('Tumor Growth Rate Matrices');
            });
            
            if (!tgrCard) {
                console.error('TGR card not found');
                return null;
            }
            
            const container = document.createElement('div');
            container.id = 'tgrComparisonsContainer';
            container.className = 'tgr-comparisons-container';
            
            const header = document.createElement('div');
            header.className = 'comparisons-header';
            header.innerHTML = `
                <h2 style="margin: 0; color: #e0e0e0;">TGR Statistical Comparisons</h2>
                <p style="color: #a0a0a0; margin: 0.5rem 0 1rem 0; font-style: italic;">
                    Pairwise comparisons of individual TGR distributions using Mann-Whitney U test
                </p>
                <div class="btn-row" style="margin-bottom: 1rem;">
                    <button class="btn compare-all" onclick="compareAllTGRIntervals()">Compare All Intervals</button>
                    <button class="btn clear-all" id="clearAllBtn" onclick="clearAllTGRComparisons()" disabled style="opacity: 0.5; cursor: not-allowed;">Clear All</button>
                    <button class="btn export-csv" onclick="exportTGRToCSV()">Export TGR Data to CSV</button>
                </div>
            `;
            
            // Create statistical notes section that will appear at the bottom
            const statisticalNotes = document.createElement('div');
            statisticalNotes.id = 'tgrStatisticalNotes';
            statisticalNotes.style.display = 'none'; // Hidden until first comparison
            statisticalNotes.innerHTML = `
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(79, 172, 254, 0.1); border-radius: 8px; border: 1px solid rgba(79, 172, 254, 0.3);">
                    <h4 style="margin: 0 0 0.5rem 0; color: #4facfe;">Statistical Notes:</h4>
                    <ul style="margin: 0; padding-left: 1.5rem; color: #a0a0a0; font-size: 0.9rem;">
                        <li>Two-tailed Mann-Whitney U test (non-parametric, rank-based)</li>
                        <li>Comparisons of individual TGR values between selected matrix cells</li>
                        <li>Significance level: α = 0.05</li>
                        <li>Effect size (Cohen's d): Small=0.2, Medium=0.5, Large=0.8</li>
                        <li>U = Mann-Whitney U statistic, Z = standardized test statistic</li>
                    </ul>
                </div>
            `;
            
            container.appendChild(header);
            container.appendChild(statisticalNotes);
            tgrCard.appendChild(container);
            
            return container;
        }

        function removeTGRComparison(comparisonId) {
            const index = tgrComparisons.findIndex(comp => comp.id === comparisonId);
            if (index !== -1) {
                tgrComparisons.splice(index, 1);
                const element = document.getElementById(`comparison-${comparisonId}`);
                if (element) element.remove();
                
                // Hide statistical notes if no comparisons remain
                if (tgrComparisons.length === 0) {
                    const statisticalNotes = document.getElementById('tgrStatisticalNotes');
                    if (statisticalNotes) {
                        statisticalNotes.style.display = 'none';
                    }
                }
                
                // Update Clear All button state
                updateClearAllButtonState();
            }
        }

        function clearCellSelection() {
            selectedCells.forEach(cell => {
                cell.element.classList.remove('tgr-selected');
                cell.element.style.border = '';
                cell.element.style.boxShadow = '';
            });
            selectedCells = [];
            document.body.classList.remove('has-selected-cell');
        }

        function compareAllTGRIntervals() {
            const groups = Object.keys(growthMatrices);
            if (groups.length < 2) {
                showNotification('Need at least 2 groups for comparison', 'warning');
                return;
            }
            
            const group1 = groups[0];
            const group2 = groups[1];
            const matrix1 = growthMatrices[group1];
            const matrix2 = growthMatrices[group2];
            
            let newComparisons = 0;
            
            Object.keys(matrix1.individualData).forEach(interval => {
                if (matrix2.individualData[interval]) {
                    const data1 = matrix1.individualData[interval];
                    const data2 = matrix2.individualData[interval];
                    
                    if (data1.length > 0 && data2.length > 0) {
                        const [dayX, dayY] = interval.split('-').map(Number);
                        
                        // Check if this comparison already exists
                        const exists = tgrComparisons.some(comp => 
                            (comp.cell1.group === group1 && comp.cell2.group === group2 && 
                             comp.cell1.dayX === dayX && comp.cell1.dayY === dayY &&
                             comp.cell2.dayX === dayX && comp.cell2.dayY === dayY) ||
                            (comp.cell1.group === group2 && comp.cell2.group === group1 && 
                             comp.cell1.dayX === dayX && comp.cell1.dayY === dayY &&
                             comp.cell2.dayX === dayX && comp.cell2.dayY === dayY)
                        );
                        
                        if (!exists) {
                            const mannWhitneyResult = mannWhitneyUTestTGR(data1, data2);
                            const cohensD = calculateCohensD(data1, data2);
                            
                            const comparison = {
                                id: Date.now() + Math.random(),
                                cell1: { group: group1, dayX: dayX, dayY: dayY },
                                cell2: { group: group2, dayX: dayX, dayY: dayY },
                                data1: data1,
                                data2: data2,
                                mannWhitney: mannWhitneyResult,
                                cohensD: cohensD,
                                median1: calculateMedian(data1),
                                median2: calculateMedian(data2)
                            };
                            
                            tgrComparisons.push(comparison);
                            displayTGRComparison(comparison);
                            newComparisons++;
                        }
                    }
                }
            });
            
            updateClearAllButtonState();
            
            if (newComparisons === 0) {
                showNotification('All intervals have already been compared', 'info');
            } else {
                showNotification(`Added ${newComparisons} new comparisons`, 'success');
            }
        }

        function updateClearAllButtonState() {
            const clearAllBtn = document.getElementById('clearAllBtn');
            if (clearAllBtn) {
                if (tgrComparisons.length > 0) {
                    clearAllBtn.disabled = false;
                    clearAllBtn.style.opacity = '1';
                    clearAllBtn.style.cursor = 'pointer';
                } else {
                    clearAllBtn.disabled = true;
                    clearAllBtn.style.opacity = '0.5';
                    clearAllBtn.style.cursor = 'not-allowed';
                }
            }
        }

        function clearAllTGRComparisons() {
            tgrComparisons = [];
            const container = document.getElementById('tgrComparisonsContainer');
            if (container) {
                const results = container.querySelectorAll('.tgr-comparison-result');
                results.forEach(result => result.remove());
            }
            // Hide statistical notes when no comparisons exist
            const statisticalNotes = document.getElementById('tgrStatisticalNotes');
            if (statisticalNotes) {
                statisticalNotes.style.display = 'none';
            }
            clearCellSelection();
            updateClearAllButtonState();
        }

        function exportTGRToCSV() {
            if (!growthMatrices || Object.keys(growthMatrices).length === 0) {
                showNotification('No TGR data available to export', 'warning');
                return;
            }

            // Create CSV content
            let csvContent = 'Animal_ID,Experimental_Group';
            
            // Get all day pairs from the first matrix to create column headers
            const firstMatrix = Object.values(growthMatrices)[0];
            const dayPairs = [];
            
            for (let i = 0; i < firstMatrix.days.length; i++) {
                for (let j = i + 1; j < firstMatrix.days.length; j++) {
                    const dayX = firstMatrix.days[i];
                    const dayY = firstMatrix.days[j];
                    dayPairs.push(`r(${dayX}-${dayY})`);
                }
            }
            
            // Add day pair columns to header
            csvContent += ',' + dayPairs.join(',') + '\n';

            // Process each experimental group
            Object.entries(growthMatrices).forEach(([groupName, matrix]) => {
                // Get animals for this group from processedData
                const groupAnimals = processedData.validAnimals.filter(animal => animal.group === groupName);
                if (!groupAnimals.length) return;

                // Process each animal in the group
                groupAnimals.forEach(animal => {
                    let row = `${animal.id},${groupName}`;
                    
                    // Calculate TGR values for each day pair for this specific animal
                    dayPairs.forEach(dayPairLabel => {
                        // Extract day numbers from label like "r(7-14)"
                        const match = dayPairLabel.match(/r\((\d+)-(\d+)\)/);
                        if (!match) {
                            row += ',';
                            return;
                        }
                        
                        const dayX = parseInt(match[1]);
                        const dayY = parseInt(match[2]);
                        
                        // Find volumes for these days
                        const dayXIndex = animal.timePoints.findIndex(day => day === dayX);
                        const dayYIndex = animal.timePoints.findIndex(day => day === dayY);
                        const volumeX = dayXIndex !== -1 ? animal.measurements[dayXIndex] : null;
                        const volumeY = dayYIndex !== -1 ? animal.measurements[dayYIndex] : null;
                        
                        if (volumeX && volumeY && volumeX > 0 && volumeY > 0) {
                            const tgr = Math.log(volumeY / volumeX) / (dayY - dayX);
                            row += ',' + tgr.toFixed(6);
                        } else {
                            row += ','; // Empty cell for missing data
                        }
                    });
                    
                    csvContent += row + '\n';
                });
            });

            // Create and download the CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'TGR_Analysis_Export.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification('TGR data exported successfully to CSV', 'success');
        }


        async function generateReport() {
            if (Object.keys(animalModels).length === 0) {
                showNotification('No analyzed data available to generate the report', 'warning');
                return;
            }

            debugLog('Generating complete HTML report...');
            showNotification('Generating complete report...', 'info');

            // Capture visual elements
            const mainChartImg = await captureChart('mainChart');
            const normalizedChartImg = await captureChart('normalizedChart');
            const matricesHTML = captureMatrices();
            const predictionsHTML = capturePredictions();

            const dataType = processedData.dataType;
            const paramLabel = dataType === 'volume' ? 'V₀' : 'BLI₀';
            const unitLabel = dataType === 'volume' ? ' mm³' : '';
            const measurementType = dataType === 'volume' ? 'Tumor Volume' : 'Bioluminescence';

            let html = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Complete Analysis Report - ViVo</title>
            <style>
                :root {
                    --primary-color: #1e3a5f;
                    --secondary-color: #2c5282;
                    --accent-color: #4299e1;
                    --success-color: #22543d;
                    --warning-color: #d69e2e;
                    --danger-color: #c53030;
                    --light-bg: #f7fafc;
                    --medium-bg: #edf2f7;
                    --dark-text: #1a202c;
                    --medium-text: #2d3748;
                    --light-text: #4a5568;
                    --border-color: #e2e8f0;
                    --shadow: 0 1px 6px rgba(30, 58, 95, 0.08);
                    --shadow-hover: 0 2px 12px rgba(30, 58, 95, 0.12);
                }

                * {
                    box-sizing: border-box;
                }

                body {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    max-width: 1200px;
                    margin: 0 auto;
                    padding: 30px 20px;
                    background: #fafbfc;
                    color: var(--dark-text);
                    line-height: 1.6;
                    min-height: 100vh;
                }

                .report-container {
                    background: white;
                    border-radius: 8px;
                    padding: 40px;
                    box-shadow: var(--shadow);
                    position: relative;
                    overflow: hidden;
                }

                .report-container::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    height: 3px;
                    background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
                }

                .header {
                    text-align: center;
                    margin-bottom: 40px;
                    padding-bottom: 30px;
                    border-bottom: 2px solid var(--medium-bg);
                }

                h1 {
                    color: var(--primary-color);
                    font-size: 2.5rem;
                    font-weight: 300;
                    margin: 0 0 15px 0;
                    letter-spacing: -0.5px;
                }

                .header-subtitle {
                    color: var(--medium-text);
                    font-size: 1.1rem;
                    font-weight: 400;
                    margin: 10px 0;
                }

                .metadata {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 15px;
                    margin: 25px 0;
                    padding: 20px;
                    background: var(--light-bg);
                    border-radius: 10px;
                    border-left: 4px solid var(--secondary-color);
                }

                .metadata-item {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .metadata-label {
                    font-weight: 600;
                    color: var(--medium-text);
                }

                .metadata-value {
                    color: var(--dark-text);
                }

                h2 {
                    color: var(--primary-color);
                    font-size: 1.8rem;
                    font-weight: 400;
                    margin: 40px 0 20px 0;
                    padding-bottom: 10px;
                    border-bottom: 2px solid var(--accent-color);
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }

                h3 {
                    color: var(--secondary-color);
                    font-size: 1.3rem;
                    font-weight: 500;
                    margin: 25px 0 15px 0;
                }

                .summary-box {
                    background: white;
                    padding: 30px;
                    border-radius: 8px;
                    margin: 25px 0;
                    box-shadow: var(--shadow);
                    border: 1px solid var(--border-color);
                }

                .stats-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                    gap: 20px;
                    margin: 25px 0;
                }

                .stat-box {
                    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
                    color: white;
                    padding: 20px;
                    border-radius: 8px;
                    text-align: center;
                    box-shadow: var(--shadow);
                    transition: transform 0.2s ease;
                }

                .stat-box:hover {
                    transform: translateY(-2px);
                }

                .stat-value {
                    font-size: 2.5em;
                    font-weight: 700;
                    margin-bottom: 8px;
                    text-shadow: 0 2px 4px rgba(0,0,0,0.2);
                }

                .stat-label {
                    font-size: 0.95em;
                    opacity: 0.9;
                    font-weight: 500;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }

                table {
                    width: 100%;
                    border-collapse: collapse;
                    margin: 25px 0;
                    background: white;
                    border-radius: 10px;
                    overflow: hidden;
                    box-shadow: var(--shadow);
                }

                th {
                    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
                    color: white;
                    padding: 18px 15px;
                    text-align: center;
                    font-weight: 600;
                    font-size: 0.9rem;
                    letter-spacing: 0.5px;
                }

                td {
                    padding: 15px;
                    text-align: center;
                    border-bottom: 1px solid var(--border-color);
                    font-weight: 500;
                }

                tr:nth-child(even) {
                    background: var(--light-bg);
                }

                tr:hover {
                    background: rgba(74, 144, 226, 0.05);
                }

                .group-section {
                    margin: 30px 0;
                    padding: 25px;
                    background: white;
                    border-radius: 8px;
                    box-shadow: var(--shadow);
                    border-left: 4px solid var(--secondary-color);
                }

                .group-section h3 {
                    background: var(--light-bg);
                    padding: 15px 20px;
                    margin: -25px -25px 20px -25px;
                    border-radius: 8px 8px 0 0;
                    border-bottom: 1px solid var(--border-color);
                }

                .warning {
                    color: var(--danger-color);
                    font-weight: 600;
                    padding: 10px 15px;
                    background: rgba(220, 53, 69, 0.1);
                    border-radius: 8px;
                    border-left: 4px solid var(--danger-color);
                }

                .success {
                    color: var(--success-color);
                    font-weight: 600;
                }

                .chart-container {
                    text-align: center;
                    margin: 40px 0;
                    padding: 30px;
                    background: white;
                    border-radius: 8px;
                    box-shadow: var(--shadow);
                    border: 1px solid var(--border-color);
                }

                .chart-container h2 {
                    margin-top: 0;
                    color: var(--primary-color);
                }

                .chart-container img {
                    max-width: 100%;
                    height: auto;
                    border-radius: 6px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                    background: transparent !important;
                    padding: 0;
                    /* Filters to improve text contrast in charts */
                    filter: contrast(1.2) brightness(1.1);
                }

                .chart-description {
                    font-style: italic;
                    color: var(--medium-text);
                    margin-top: 15px;
                    font-size: 0.95rem;
                }

                .conclusions-list {
                    list-style: none;
                    padding: 0;
                }

                .conclusions-list li {
                    padding: 12px 0;
                    padding-left: 30px;
                    position: relative;
                    border-bottom: 1px solid var(--border-color);
                }

                .conclusions-list li:before {
                    content: "→";
                    position: absolute;
                    left: 0;
                    color: var(--secondary-color);
                    font-weight: bold;
                    font-size: 1.2em;
                }

                .formula-box {
                    background: var(--light-bg);
                    padding: 20px;
                    border-radius: 10px;
                    margin: 20px 0;
                    border-left: 4px solid var(--accent-color);
                    font-family: 'Courier New', monospace;
                    text-align: center;
                    font-size: 1.1rem;
                }

                .footer {
                    margin-top: 60px;
                    padding: 30px 0;
                    border-top: 1px solid var(--border-color);
                    text-align: center;
                    color: var(--light-text);
                    background: var(--light-bg);
                    border-radius: 6px;
                    margin-left: -40px;
                    margin-right: -40px;
                    margin-bottom: -40px;
                }

                .logo {
                    font-size: 1.5rem;
                    font-weight: 700;
                    color: var(--primary-color);
                    margin-bottom: 10px;
                }

                @media print {
                    body {
                        background: white;
                        padding: 0;
                    }
                    
                    .report-container {
                        box-shadow: none;
                        padding: 20px;
                    }
                    
                    .chart-container {
                        page-break-inside: avoid;
                    }
                    
                    h2 {
                        page-break-before: auto;
                    }
                    
                    .stat-box:hover {
                        transform: none;
                    }
                }

                @media (max-width: 768px) {
                    body {
                        padding: 15px;
                    }
                    
                    .report-container {
                        padding: 20px;
                    }
                    
                    h1 {
                        font-size: 2rem;
                    }
                    
                    .stats-grid {
                        grid-template-columns: 1fr;
                    }
                    
                    .metadata {
                        grid-template-columns: 1fr;
                    }
                }

                /* TGR Comparison Styles */
                /* Selected cell style */
                .tgr-selected {
                    border: 3px solid #007bff !important;
                    box-shadow: 0 0 15px rgba(0,123,255,0.6) !important;
                }

                .tgr-comparisons-container {
                    margin-top: 20px;
                    border-top: 2px solid var(--border-color);
                    padding-top: 20px;
                }

                .comparisons-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 20px;
                    padding: 15px;
                    background: var(--light-bg);
                    border-radius: 8px;
                    border: 1px solid var(--border-color);
                }

                .comparisons-header h3 {
                    margin: 0;
                    color: var(--primary-color);
                }

                .comparison-controls {
                    display: flex;
                    gap: 10px;
                }

                .comparison-controls button {
                    padding: 0.75rem 1.5rem;
                    background: linear-gradient(45deg, #3182ce, #0099cc);
                    color: white;
                    border: none;
                    border-radius: 10px;
                    font-size: 0.9rem;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    gap: 0.5rem;
                }

                .comparison-controls button:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 5px 20px rgba(79, 172, 254, 0.4);
                }

                .comparison-controls button:active {
                    transform: translateY(0);
                }

                .tgr-comparison-result {
                    margin-bottom: 20px;
                    padding: 20px;
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 12px;
                    backdrop-filter: blur(10px);
                }




                @media (max-width: 768px) {
                    .comparisons-header {
                        flex-direction: column;
                        gap: 10px;
                    }

                    .comparison-controls {
                        width: 100%;
                        justify-content: center;
                    }

                    .comparison-stats-table {
                        font-size: 0.8em;
                    }

                    .comparison-stats-table th,
                    .comparison-stats-table td {
                        padding: 8px 4px;
                    }
                }
            </style>
        </head>
        <body>
            <div class="report-container">
                <div class="header">
                    <h1>Anticancer Efficacy Analysis Report${currentFileName ? ` - ${currentFileName}` : ''}</h1>
                    <div class="header-subtitle">ViVo • In Vivo Metrics</div>
                </div>
                
                <div class="metadata">
                    <div class="metadata-item">
                        <span class="metadata-label">Date:</span>
                        <span class="metadata-value">${new Date().toLocaleString('en-US')}</span>
                    </div>
                    <div class="metadata-item">
                        <span class="metadata-label">Measurement type:</span>
                        <span class="metadata-value">${measurementType}</span>
                    </div>
                    <div class="metadata-item">
                        <span class="metadata-label">R² threshold:</span>
                        <span class="metadata-value">${document.getElementById('r2Threshold').value}</span>
                    </div>
                </div>
                
                <div class="summary-box">
                    <h2>Executive Summary</h2>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-value">${rawData.length}</div>
                            <div class="stat-label">Total Animals</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value">${processedData.validAnimals.length}</div>
                            <div class="stat-label">Valid Animals</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value">${((processedData.validAnimals.length / rawData.length) * 100).toFixed(1)}%</div>
                            <div class="stat-label">Validity Rate</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value">${Object.keys(processedData.groupStats).length}</div>
                            <div class="stat-label">Study Groups</div>
                        </div>
                    </div>
                </div>
            `;

            // Add to report metadata
            if (outlierAnalysis) {
                html += `
                    <div class="metadata-item">
                        <span class="metadata-label">Outliers detected:</span>
                        <span class="metadata-value">${outlierAnalysis.summary.totalFlags}</span>
                    </div>
                `;
            }

            // Add charts if they exist
            if (mainChartImg) {
                html += `
                <div class="chart-container">
                    <h2>Exponential Growth Curves</h2>
                    <img src="${mainChartImg}" alt="Growth Curves Chart" />
                    <div class="chart-description">Exponential fit according to the model: y = a·e^(r·t)</div>
                </div>
            `;
            }

            if (normalizedChartImg) {
                html += `
                <div class="chart-container">
                    <h2>Normalized Growth Comparison</h2>
                    <img src="${normalizedChartImg}" alt="Normalized Growth Chart" />
                    <div class="chart-description">Normalized curves with initial value = 1 for direct comparison</div>
                </div>
            `;
            }

            html += '<h2>Detailed Analysis by Groups</h2>';

            // Add group analysis
            Object.entries(processedData.groupStats).forEach(([group, stats]) => {
                const groupAnimals = processedData.validAnimals.filter(a => a.group === group);
                const total = stats.valid + stats.invalid;

                const relErrorR = stats.avgR !== 0 && stats.seR > 0 ?
                    (stats.seR / Math.abs(stats.avgR) * 100).toFixed(1) : '0.0';
                const relErrorA = stats.avgA !== 0 && stats.seA > 0 ?
                    (stats.seA / Math.abs(stats.avgA) * 100).toFixed(1) : '0.0';

                html += `
                <div class="group-section">
                    <h3>Group: ${group}</h3>
                    <p><strong>Valid animals:</strong> <span class="success">${stats.valid}</span> of ${total} (${((stats.valid / total) * 100).toFixed(1)}%)</p>
                    ${stats.valid > 0 ? `
                    <p><strong>Average growth rate (r):</strong> ${stats.avgR.toFixed(4)} ± ${stats.seR ? stats.seR.toFixed(4) : '0.0000'} day⁻¹ (${relErrorR}%)</p>
                    <p><strong>Coefficient of determination (R²):</strong> ${stats.avgR2.toFixed(3)}</p>
                    <p><strong>Average ${paramLabel}:</strong> ${dataType === 'bli' ? stats.avgA.toExponential(2) : stats.avgA.toFixed(2)}${unitLabel} ± ${relErrorA}%</p>
                    
                    <table>
                        <thead>
                            <tr>
                                <th style="text-align: left;">Animal ID</th>
                                <th>${paramLabel} (${unitLabel})</th>
                                <th>r (day⁻¹)</th>
                                <th>R²</th>
                                <th>T₁/₂ (days)</th>
                            </tr>
                        </thead>
                        <tbody>
                    ` : '<div class="warning">No valid animals in this group for statistical analysis</div>'}
            `;

                if (stats.valid > 0) {
                    groupAnimals.forEach(animal => {
                        const doublingTime = (animal.model.r && animal.model.r > 0) ? Math.log(2) / animal.model.r : Infinity;
                        const a0Value = dataType === 'bli' ?
                            animal.model.a.toExponential(2) :
                            animal.model.a.toFixed(2);

                        html += `
                            <tr>
                                <td style="text-align: left;">${animal.id}</td>
                                <td>${a0Value}</td>
                                <td>${animal.model.r.toFixed(4)}</td>
                                <td>${animal.model.r2.toFixed(3)}</td>
                                <td>${doublingTime.toFixed(1)}</td>
                            </tr>
                `;
                    });

                    html += `
                        </tbody>
                    </table>
                `;
                }

                html += `
                </div>
            `;
            });

            // Add statistical comparison section
            const statisticalComparisonHTML = generateStatisticalComparisonHTML();
            if (statisticalComparisonHTML) {
                html += statisticalComparisonHTML;
            }

            // Add matrices if they exist
            if (matricesHTML) {
                html += matricesHTML;
            }

            // Add predictions if they exist
            if (predictionsHTML) {
                html += predictionsHTML;
            }

            // Add conclusions
            html += `
                <h2>Conclusions and Statistical Analysis</h2>
                <div class="summary-box">
                    <p>The exponential regression analysis has successfully processed <strong>${processedData.validAnimals.length}</strong> specimens with statistically significant fit (R² ≥ ${document.getElementById('r2Threshold').value}).</p>
                    
                    ${processedData.invalidAnimals.length > 0 ? `
                    <div class="warning">
                        <strong>Analysis Exclusions:</strong> ${processedData.invalidAnimals.length} specimens were discarded due to insufficient fit.
                    </div>
                    <p><strong>Possible causes of exclusion:</strong></p>
                    <ul class="conclusions-list">
                        <li>Incomplete data or inconsistencies in measurements</li>
                        <li>Atypical or non-exponential response to applied treatment</li>
                        <li>Excessive experimental variability or systematic errors</li>
                        <li>Mortality events or premature sacrifice</li>
                    </ul>
                    ` : ''}
                    
                    <div class="formula-box">
                        <strong>Applied Mathematical Model:</strong><br>
                        y = ${paramLabel} × e^(r × t)
                    </div>
                    
                    <p><strong>Parameter definitions:</strong></p>
                    <ul class="conclusions-list">
                        <li><strong>y:</strong> ${measurementType} at time t</li>
                        <li><strong>${paramLabel}:</strong> Initial ${measurementType}${unitLabel}</li>
                        <li><strong>r:</strong> Specific growth rate (day⁻¹)</li>
                        <li><strong>t:</strong> Elapsed time (days)</li>
                        <li><strong>T₁/₂:</strong> Doubling time = ln(2)/r</li>
                    </ul>
                    
                    <h3>Statistical Methodology</h3>
                    <p>Relative errors are calculated using the formula: <strong>(σ / √n) / μ × 100%</strong></p>
                    <p>Where σ is the standard deviation, n is the sample size, and μ is the group mean.</p>
                    
                    <p><em>The analysis ensures statistical robustness through cross-validation and strict exclusion criteria to ensure the reliability of the obtained results.</em></p>
                </div>
                
                <div class="footer">
                    <div class="logo">ViVo Analytics Platform</div>
                    <p>Statistical Analysis System for Oncological Research</p>
                    <p>© ${new Date().getFullYear()} - Report generated automatically</p>
                </div>
            </div>
        </body>
        </html>
            `;

            // Download report
            const blob = new Blob([html], { type: 'text/html;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            // Create filename: ViVo_DatasetName_YYYY-MM-DD.html
            const today = new Date().toISOString().slice(0, 10);
            const datasetName = currentFileName ? `_${currentFileName}` : '';
            link.download = `ViVo${datasetName}_${today}.html`;
            link.click();

            showNotification('Complete report generated successfully', 'success');
            debugLog('Complete report generated and downloaded');
        }

        function exportEnhancedCSV() {
            if (Object.keys(animalModels).length === 0) {
                showNotification('No analyzed data available for export', 'warning');
                return;
            }

            debugLog('Exporting enhanced CSV...');

            const dataType = processedData.dataType;
            const paramLabel = dataType === 'volume' ? 'V0' : 'BLI0';

            // Create enhanced data with original columns plus new ones
            const enhancedData = rawData.map(row => {
                const animalId = row.Animal || row.ID || '';
                const newRow = { ...row };

                if (animalModels[animalId]) {
                    const model = animalModels[animalId].model;
                    newRow.R2 = model.r2.toFixed(4);
                    newRow[paramLabel] = dataType === 'bli' ?
                        model.a.toExponential(3) :
                        model.a.toFixed(3);
                    newRow.r = model.r.toFixed(6);
                    newRow.DuplicationTime = (model.r && model.r > 0) ? (Math.log(2) / model.r).toFixed(2) : 'Infinity';
                    newRow.Valid = 'YES';
                } else {
                    newRow.R2 = '';
                    newRow[paramLabel] = '';
                    newRow.r = '';
                    newRow.DuplicationTime = '';
                    newRow.Valid = 'NO';
                }

                return newRow;
            });

            // Convert to CSV using PapaParse
            const csv = Papa.unparse(enhancedData);

            // Create and download file
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `enhanced_results_${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();

            showNotification('CSV exported successfully', 'success');
            debugLog('CSV exported with', enhancedData.length, 'rows');
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function () {
            debugLog('DOM loaded, setting up event listeners...');

            const fileInput = document.getElementById('fileInput');
            const fileLabel = document.getElementById('fileLabel');
            
            if (fileInput) {
                fileInput.addEventListener('change', handleFileSelect);
                debugLog('File event listener configured');
                
                // Add drag and drop functionality to main file input
                if (fileLabel) {
                    fileLabel.addEventListener('dragover', function(e) {
                        e.preventDefault();
                        this.style.borderColor = 'rgba(79, 172, 254, 1)';
                        this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(0, 153, 204, 0.3))';
                    });
                    
                    fileLabel.addEventListener('dragleave', function(e) {
                        e.preventDefault();
                        this.style.borderColor = 'rgba(79, 172, 254, 0.5)';
                        this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1))';
                    });
                    
                    fileLabel.addEventListener('drop', function(e) {
                        e.preventDefault();
                        this.style.borderColor = 'rgba(79, 172, 254, 0.5)';
                        this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1))';
                        
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            fileInput.files = files;
                            fileInput.dispatchEvent(new Event('change'));
                        }
                    });
                }
            } else {
                debugError('File input not found');
            }

            // Configure outlier selector
            document.getElementById('outlierConfig').addEventListener('change', updateOutlierConfig);

            // Check libraries after a brief delay
            setTimeout(() => {
                if (debugMode) checkLibraries();
                showNotification('ViVo initialized successfully', 'success');
            }, 1000);
        });
        
        debugLog('ViVo initialized');
    </script>
</body>
</html>
