<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ViVo: In Vivo Metrics</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/tutorial-styles.css">
    <link rel="stylesheet" href="css/scientific-wizard.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

    <script src="js/core/AppState.js"></script>
    <script src="js/core/FastMath.js"></script>
    <script src="js/core/MathUtils.js"></script>
    <script src="js/core/DOMCache.js"></script>
    <script src="js/core/NotificationService.js"></script>
    <script src="js/core/EventManager.js"></script>
    <script src="js/core/ModalSystem.js"></script>
    <script src="js/core/SystemIntegrator.js"></script>
    <script src="js/core/WorkerManager.js"></script>
    <script src="js/core/WorkerUtility.js"></script>
    <script src="js/core/ChartPoolManager.js"></script>
    <script src="js/core/AppUtilities.js"></script>
    <script src="js/core/UIManager.js"></script>
    <script src="js/core/AnalysisController.js"></script>
    <script src="js/core/FormChangeHandler.js"></script>
    <script src="js/core/ApplicationController.js"></script>
    <script src="js/IntelligentOutlierDetector.js"></script>
    <script src="js/ModelHomogeneityEvaluator.js"></script>

    <script src="js/services/ChartService.js"></script>
    <script src="js/services/ReportGenerator.js"></script>
    <script src="js/services/ExportManager.js"></script>
    <script src="js/services/TGRMatricesService.js"></script>
    <script src="js/services/PredictionService.js"></script>
    <script src="js/services/ScientificWizardService.js"></script>
    <script src="js/services/TutorialSystem.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
    .control-label { color: #4facfe; font-weight: 600; margin-bottom: 0.5rem; display: block; }
    .file-input-wrapper { position: relative; display: inline-block; width: 100%; }
    .file-input-hidden { position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
    .file-input-label { display: flex; align-items: center; justify-content: center; padding: 1.5rem; background: linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1)); border: 2px dashed rgba(79, 172, 254, 0.5); border-radius: 12px; color: #e0e0e0; cursor: pointer; transition: all 0.3s ease; min-height: 80px; text-align: center; font-size: 1rem; }
    .file-hint { color: #a0a0a0; padding-left: 5px; margin-top: 2px; }
    .file-info { margin: 8px 0 0 0; color: #a0a0a0; font-size: 0.9rem; line-height: 1.4; }
    .file-structure { margin: 0 0 8px 0; }
    .templates-title { margin: 0; }
    .templates-list { margin: 4px 0 0 20px; padding: 0; }
    .template-link { color: #4facfe; text-decoration: underline; cursor: pointer; }
    .config-help { color: #a0a0a0; font-size: 0.85rem; margin-top: 5px; display: block; }
    .logo-size { width: 256px; height: 256px; }
    .welcome-hidden { display: none; }
    .analysis-height { height: 44px; }
    .icon-style { font-size: 24px; color: #ffffff; margin-right: 5px; }
    .lord-icon-size { width: 36px; height: 36px; }
    .section-title { margin-bottom: 10px; margin-top: 20px; font-weight: 400; }
    .casual-text { margin-bottom: 10px; }
    .outlier-stat-value { color: #2196f3; }
    .outlier-stat-critical { color: #f44336; }
    .outlier-stat-high { color: #ff9800; }
    .outlier-stat-remaining { color: #4caf50; }
    .config-badge { background: rgba(76, 175, 80, 0.2); padding: 5px 10px; border-radius: 15px; color: #4caf50; font-weight: 500; font-size: 0.9rem; }
    .dual-analysis-section { background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; margin: 15px 0; }
    .dual-analysis-title { margin: 0 0 15px 0; color: #4facfe; }
    .cyclic-btn-style { background: linear-gradient(45deg, #4facfe, #00f2fe); margin-right: 10px; }
    .filtering-info { background: rgba(33, 150, 243, 0.1); padding: 12px; border-radius: 8px; margin: 10px 0; font-size: 0.9rem; }
    .filtering-impact { background: rgba(255, 193, 7, 0.2); padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107; }
    .center-text { text-align: center; }
    .margin-15 { margin: 15px 0; }
    .margin-20 { margin: 20px 0; }
    .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1rem 0; }
    .stat-card { padding: 1rem; border-radius: 10px; text-align: center; }
    .stat-card-blue { background: rgba(79, 172, 254, 0.2); }
    .stat-card-cyan { background: rgba(0, 242, 254, 0.2); }
    .stat-card-pink { background: rgba(250, 112, 154, 0.2); }
    .stat-card-yellow { background: rgba(254, 225, 64, 0.2); }
    .stat-value { font-size: 2rem; font-weight: bold; }
    .stat-value-blue { color: #4facfe; }
    .stat-value-cyan { color: #00f2fe; }
    .stat-value-pink { color: #fa709a; }
    .stat-value-yellow { color: #fee140; }
    .stat-label { color: #a0a0a0; }
    .groups-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; }
    .group-card { background: rgba(255, 255, 255, 0.08); padding: 1.5rem; border-radius: 15px; }
    .group-name { font-weight: 600; color: #00f2fe; margin-bottom: 0.5rem; font-size: 1.1rem; }
    .group-count { font-size: 1.5rem; font-weight: 700; color: #4facfe; }
    .group-validity { color: #a0a0a0; font-size: 1.05rem; margin-bottom: .85rem; }
    .group-stats { font-size: 1.0rem; line-height: 1.5; }
    .overflow-auto { overflow-x: auto; }
    .table-header { text-align: left; }
    .table-cell-left { text-align: left; }
    .comparison-notes { margin-top: 1rem; padding: 1rem; background: rgba(79, 172, 254, 0.1); border-radius: 8px; border: 1px solid rgba(79, 172, 254, 0.3); }
    .notes-title { margin: 0 0 0.5rem 0; color: #4facfe; }
    .notes-list { margin: 0; padding-left: 1.5rem; color: #a0a0a0; font-size: 0.9rem; }
    </style>
</head>

<body>
    <div class="container">
        <div class="top-bar">
            <button class="about-btn" onclick="modalManager.show('about')" title="About ViVo">
                <i class="info-icon">i</i>
            </button>
        </div>
        
        <header>
            <div class="logo-container">
                <img src="ViVo.png" alt="ViVo Logo" class="logo-size">
            </div>
        </header>


        <!-- Welcome Banner for First-Time Users -->
        <div id="welcomeBanner" class="welcome-banner welcome-hidden">
            <button class="welcome-close" onclick="hideWelcomeBanner()" title="Close Welcome Banner">×</button>
            <div class="welcome-content">
                <p>New to ViVo? We have tools to help you get started quickly and configure optimal settings for your study.</p>
                <div class="welcome-actions">
                    <button class="welcome-btn tutorial" onclick="hideWelcomeBanner(); setTimeout(() => startTutorial(), 300);">
                        Interactive Tutorial
                        <small>5-minute guided tour</small>
                    </button>
                    <button class="welcome-btn wizard" onclick="scientificWizard.start(); hideWelcomeBanner();">
                        Configuration Assistant
                        <small>Get optimal configuration</small>
                    </button>
                </div>
                <div class="welcome-dismiss">
                    <span class="welcome-dismiss-text" onclick="dismissWelcomeBannerPermanently()" title="Hide this banner permanently">
                        Do not show this banner again
                    </span>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <div class="control-group">
                <label for="fileInput" class="control-label">CSV Data File</label>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".csv,.txt" class="file-input-hidden" />
                    <div class="file-input-label" id="fileLabel">
                        Drag your CSV file here or click to select
                        <br><small class="file-hint">Accepted formats: .csv, .txt</small>
                    </div>
                </div>
                <div class="file-info">
                    <p class="file-structure"><strong>Required structure:</strong> <i>Animal</i>, <i>Group</i>, Day columns (<i>0</i>, <i>2</i>, <i>4</i>, <i>7</i>, <i>10</i>...), <i>Tumor_Weight</i> (optional)</p>
                    <p class="templates-title"><strong>Templates available:</strong></p>
                    <ul class="templates-list">
                        <li><strong><a href="Datasets/ViVo_basic_dataset_TEMPLATE.csv" download="basic_dataset_template.csv" class="template-link">Basic</a>:</strong> BLI data format (C1, C2, C3, T1, T2, T3...)</li>
                        <li><strong><a href="Datasets/ViVo_dataset_with_weights_TEMPLATE.csv" download="dataset_with_weights_template.csv" class="template-link">With Weights</a>:</strong> BLI + Tumor_Weight column for auto-detection</li>
                    </ul>
                </div>
                
                <h3 class="section-title"><strong>Configure Analysis Parameters:</strong></h3>
                <div class="wizard-context-placement">
                    <button class="wizard-context-btn" id="contextWizardBtn" onclick="scientificWizard.start()" 
                            title="Launch configuration wizard to optimize analysis parameters for your study">
                        <span class="wizard-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
                                <path fill="#cf5135" d="M259.1 73.5C262.1 58.7 275.2 48 290.4 48L350.2 48C365.4 48 378.5 58.7 381.5 73.5L396 143.5C410.1 149.5 423.3 157.2 435.3 166.3L503.1 143.8C517.5 139 533.3 145 540.9 158.2L570.8 210C578.4 223.2 575.7 239.8 564.3 249.9L511 297.3C511.9 304.7 512.3 312.3 512.3 320C512.3 327.7 511.8 335.3 511 342.7L564.4 390.2C575.8 400.3 578.4 417 570.9 430.1L541 481.9C533.4 495 517.6 501.1 503.2 496.3L435.4 473.8C423.3 482.9 410.1 490.5 396.1 496.6L381.7 566.5C378.6 581.4 365.5 592 350.4 592L290.6 592C275.4 592 262.3 581.3 259.3 566.5L244.9 496.6C230.8 490.6 217.7 482.9 205.6 473.8L137.5 496.3C123.1 501.1 107.3 495.1 99.7 481.9L69.8 430.1C62.2 416.9 64.9 400.3 76.3 390.2L129.7 342.7C128.8 335.3 128.4 327.7 128.4 320C128.4 312.3 128.9 304.7 129.7 297.3L76.3 249.8C64.9 239.7 62.3 223 69.8 209.9L99.7 158.1C107.3 144.9 123.1 138.9 137.5 143.7L205.3 166.2C217.4 157.1 230.6 149.5 244.6 143.4L259.1 73.5zM320.3 400C364.5 399.8 400.2 363.9 400 319.7C399.8 275.5 363.9 239.8 319.7 240C275.5 240.2 239.8 276.1 240 320.3C240.2 364.5 276.1 400.2 320.3 400z"/>
                            </svg>
                        </span>
                        <div class="wizard-text">
                            <span class="wizard-title">Configuration Assistant</span>
                            <span class="wizard-subtitle">Optimize analysis parameters for your study type</span>
                        </div>
                        <span class="wizard-arrow">→</span>
                    </button>
                    <small class="wizard-context-note">
                        Configure study-specific parameters automatically based on experimental design
                    </small>
                </div>
            </div>
            <p class="casual-text">Or maybe you prefer to mess around with <strong>Analysis Parameters</strong>:</p>
            <div class="control-group">
                <label for="dataType">
                    Data Type
                </label>
                <select id="dataType">
                    <option value="volume">Tumor Volume (mm³)</option>
                    <option value="bli">BLI (Bioluminescence)</option>
                </select>
                <small class="config-help">
                    Different measurement types have different expected variability levels.
                </small>
            </div>

            <div class="control-group">
                <label for="r2Threshold">
                    R² Threshold (fit quality)
                </label>
                <input type="number" id="r2Threshold" step="0.01" min="0" max="1" value="0.8" />
                <small class="config-help">
                    Animals with poor growth curve fits (R² below threshold) are excluded from analysis.
                </small>
            </div>

            <div class="control-group">
                <label for="outlierConfig">
                    Outlier Detection Configuration
                </label>
                <select id="outlierConfig">
                    <option value="auto" selected>Auto (adjusts to sample size)</option>
                    <option value="ultraConservative">Ultra-Conservative (pilot studies, n=5-8)</option>
                    <option value="conservative">Conservative (standard studies, n=8-12)</option>
                    <option value="moderate">Moderate (large studies, n&gt;12)</option>
                </select>
                <small class="config-help">
                    Auto mode automatically adjusts sensitivity based on loaded sample size.
                </small>
            </div>

            <div class="control-group">
                <label for="outlierFiltering">
                    Anomaly Filtering Level
                </label>
                <select id="outlierFiltering">
                    <option value="critical">Critical Only (default)</option>
                    <option value="criticalAndHigh" selected>Critical + High (recommended)</option>
                    <option value="all">All Anomalies (very strict)</option>
                </select>
                <small class="config-help">
                    Determines which level of anomalies are automatically excluded from analysis.
                </small>
            </div>

            <!-- Primary workflow actions -->
            <div class="primary-actions">
                <button class="btn analysis-height" onclick="analyzeData()" title="Load and analyze your dataset to generate comprehensive results">
                    <script src="https://cdn.lordicon.com/lordicon.js"></script>
                        <lord-icon
                            src="https://cdn.lordicon.com/lbeordmv.json"
                            trigger="loop"
                            delay="2000"
                            colors="primary:#ffffff"
                            class="lord-icon-size">
                        </lord-icon>
                    Analyze Data
                </button>
                <button class="btn help-btn prominent" onclick="modalManager.show('help')" title="Get help, view tutorial, and access user manual">
                    <i class="fa-solid fa-book fa-bounce icon-style"></i>
                    Help & Tutorial
                </button>
            </div>

            <!-- Analysis tools - available after data analysis -->
            <div class="analysis-tools">
                <button class="btn secondary" id="exportBtn" onclick="exportManager.export('enhanced')" disabled 
                        title="Export analysis results to CSV format (available after analysis)"
                        data-disabled-reason="Complete analysis first">
                    Export CSV
                </button>
                <button class="btn tertiary" id="predictionsBtn" onclick="togglePredictionForm()" disabled 
                        title="Generate predictions based on analysis results (available after analysis)"
                        data-disabled-reason="Complete analysis first">
                    Predictions
                </button>
                <button class="btn quaternary" id="tgrBtn" onclick="generateGrowthMatrices()" disabled 
                        title="Generate Tumor Growth Rate matrices (available after analysis)"
                        data-disabled-reason="Complete analysis first">
                    TGR Matrices
                </button>
                <button class="btn secondary" id="reportBtn" onclick="generateReport()" disabled 
                        title="Generate comprehensive PDF report (available after analysis)"
                        data-disabled-reason="Complete analysis first">
                    Generate Report
                </button>
            </div>
        </div>

        <div id="results" class="results-section"></div>
    </div>

    <script>
        // Core modules and utilities are now loaded from separate files
        // Legacy compatibility is maintained automatically
        const debounce = AppUtilities.debounce;
        const throttle = AppUtilities.throttle;
        const states = OUTLIER_STATES;


        
        function resetFileLabel(fileLabel) {
            if (!fileLabel) return;
            
            fileLabel.innerHTML = `
                Drag your CSV file here or click to select
                <br><small style="color: #a0a0a0; margin-top: 8px;">Accepted formats: .csv, .txt</small>
            `;
            fileLabel.style.borderColor = 'rgba(79, 172, 254, 0.5)';
            fileLabel.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1))';
        }


        function checkLibraries() {
            const results = {
                Papa: typeof Papa !== 'undefined',
                Plotly: typeof Plotly !== 'undefined'
            };
            
            if (results.Papa && results.Plotly) {
                showNotification('All libraries are loaded', 'success');
            } else {
                showNotification('Missing libraries to load', 'error');
            }
        }

        // Function to clear all results and reset the application state
        function clearAllResults() {
            
            // Don't clear data if we're in tutorial mode - preserve tutorial data
            if (tutorialMode) {
                // Only clear results, not the raw data
                processedData = {};
                animalModels = {};
                dayColumns = [];
                globalMin = Infinity;
                globalMax = -Infinity;
                
                // Reset homogeneity evaluation flags even in tutorial mode
                homogeneityEvaluating = false;
                if (homogeneityDebounceTimeout) {
                    clearTimeout(homogeneityDebounceTimeout);
                    homogeneityDebounceTimeout = null;
                }
                return;
            }
            
            // Clear all data variables (normal mode)
            rawData = [];
            AppState.rawData = [];
            processedData = {};
            animalModels = {};
            dayColumns = [];
            globalMin = Infinity;
            globalMax = -Infinity;
            window.normalizedChartData = null;
            outlierAnalysis = null;
            if (AppState) {
                AppState.outlierAnalysis = null;
            }
            currentFileName = '';
            
            // Reset homogeneity evaluation flags to allow modal to appear on new dataset
            homogeneityEvaluating = false;
            if (homogeneityDebounceTimeout) {
                clearTimeout(homogeneityDebounceTimeout);
                homogeneityDebounceTimeout = null;
            }
            
            // Reset outlier detection
            if (outlierDetector) {
                outlierDetector.reset();
            }
            useFilteredData = false;
            usePointFiltering = false;
            currentState = 0;
            
            // Clear all visual results from DOM
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) {
                // Remove all result cards
                const resultCards = resultsDiv.querySelectorAll('.result-card');
                resultCards.forEach(card => card.remove());
                
                // Remove any remaining matrix containers
                const matrixContainers = resultsDiv.querySelectorAll('.matrices-container, .matrix-group');
                matrixContainers.forEach(container => container.remove());
                
                // Clear any remaining content
                resultsDiv.innerHTML = '';
            }
            
            // Reset file label
            const fileLabel = document.getElementById('fileLabel');
            if (fileLabel) {
                fileLabel.textContent = 'No file selected';
                fileLabel.classList.remove('file-loaded');
            }
            
            // Clear any Plotly charts if they exist
            const plotlyCharts = ['mainChart', 'normalizedChart'];
            plotlyCharts.forEach(chartId => {
                const chartElement = document.getElementById(chartId);
                if (chartElement) {
                    // Use ChartPoolManager only - no fallbacks
                    if (AppState?.chartPoolManager?.purgeChart) {
                        AppState.chartPoolManager.purgeChart(chartId);
                    }
                }
            });
            
            // Clear any other canvas elements if they exist
            const chartElements = document.querySelectorAll('canvas');
            chartElements.forEach(canvas => {
                const context = canvas.getContext('2d');
                if (context) {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                }
            });
            
        }


        let homogeneityEvaluating = false;
        let homogeneityDebounceTimeout = null;

        function evaluateAndShowHomogeneity() {
            // Clear previous debounce timeout
            if (homogeneityDebounceTimeout) {
                clearTimeout(homogeneityDebounceTimeout);
            }
            
            // Debounce the evaluation to prevent rapid successive calls
            homogeneityDebounceTimeout = setTimeout(() => {
                evaluateHomogeneityInternal();
            }, 300);
        }

        function evaluateHomogeneityInternal() {
            try {
                
                // Prevent multiple simultaneous evaluations
                if (homogeneityEvaluating) {
                    return;
                }
                homogeneityEvaluating = true;
                
                // Show loading state
                showHomogeneityLoadingState();
                
                // Check if data is loaded (special handling for tutorial mode)
                let currentRawData;
                
                if (tutorialMode) {
                    // In tutorial mode, try multiple sources for data
                    currentRawData = AppState.rawData || window.rawData || rawData;
                } else {
                    currentRawData = AppState.rawData.length > 0 ? AppState.rawData : rawData;
                }
                
                
                if (!currentRawData || currentRawData.length === 0) {
                    hideHomogeneityLoadingState();
                    showNotification('Please load a CSV file first', 'warning');
                    homogeneityEvaluating = false;
                    return;
                }
                
                // Parse animals from raw data
                const parsed = parseAnimalData(currentRawData);
                const animals = parsed.animals;
                
                if (animals.length < 2) {
                    hideHomogeneityLoadingState();
                    showNotification('Insufficient data for homogeneity evaluation', 'warning');
                    homogeneityEvaluating = false;
                    return;
                }
                
                // Initialize homogeneity evaluator if needed
                if (!AppState.homogeneityEvaluator) {
                    AppState.homogeneityEvaluator = new ModelHomogeneityEvaluator();
                }
                
                // Run model homogeneity evaluation using the module
                const homogeneityResults = AppState.homogeneityEvaluator.evaluate(animals);
                
                // Store initial results for later comparison
                AppState.initialHomogeneityResults = homogeneityResults;
                
                // Hide loading state and show modal with results
                hideHomogeneityLoadingState();
                showHomogeneityModal(homogeneityResults);
                
                // Reset flag after successful completion
                homogeneityEvaluating = false;
                
            } catch (error) {
                hideHomogeneityLoadingState();
                showNotification('Error evaluating homogeneity: ' + error.message, 'error');
                homogeneityEvaluating = false;
            }
        }

        // Loading state functions
        function showHomogeneityLoadingState() {
            // Remove any existing loader
            hideHomogeneityLoadingState();
            
            const loader = document.createElement('div');
            loader.id = 'homogeneityLoader';
            loader.className = 'homogeneity-loading-overlay';
            loader.innerHTML = `
                <div class="loading-modal">
                    <div class="loading-content">
                        <div class="spinner"></div>
                        <h3>Evaluating Model Homogeneity</h3>
                        <p>Analyzing baseline variability across groups...</p>
                    </div>
                </div>
            `;
            
            document.body.appendChild(loader);
            
            // Add animation
            setTimeout(() => {
                loader.classList.add('show');
            }, 10);
        }

        function hideHomogeneityLoadingState() {
            const loader = document.getElementById('homogeneityLoader');
            if (loader) {
                loader.classList.add('hide');
                setTimeout(() => loader.remove(), 300);
            }
        }

        // Homogeneity modal functionality - now handled by ModelHomogeneityEvaluator.js
        // Global functions are automatically provided by ModelHomogeneityEvaluator.js



        // About modal functionality - now handled by UIManager
        // Global functions are automatically provided by UIManager.js


        // Data Review modal functionality - now handled by UIManager.js
        // Global functions are automatically provided by UIManager.js




        // Reevaluate homogeneity with current dataset configuration
        // Legacy function - now delegates to optimized functions
        function reevaluateHomogeneity(dataToEvaluate, datasetType) {
            if (!dataToEvaluate?.length) {
                return null;
            }
            
            try {
                return createHomogeneityComparison(dataToEvaluate, datasetType);
            } catch (error) {
                return null;
            }
        }

        function calculateHomogeneityImprovement(initial, current) {
            // Validate inputs
            if (!initial?.overallAssessment || !current?.overallAssessment) {
                return {
                    cvChange: 0,
                    cvReduction: 0,
                    statusChange: 'UNKNOWN → UNKNOWN',
                    animalChange: 0,
                    qualityImproved: false,
                    qualityDegraded: false
                };
            }
            
            const initialCV = parseFloat(initial.overallAssessment.averageCV) || 0;
            const currentCV = parseFloat(current.overallAssessment.averageCV) || 0;
            const initialQuality = initial.overallAssessment.quality || 'insufficient';
            const currentQuality = current.overallAssessment.quality || 'insufficient';
            
            const initialScore = getQualityScore(initialQuality);
            const currentScore = getQualityScore(currentQuality);
            
            return {
                cvChange: currentCV - initialCV,
                cvReduction: initialCV - currentCV,
                statusChange: `${initialQuality.toUpperCase()} → ${currentQuality.toUpperCase()}`,
                animalChange: (current.totalAnimals || 0) - (initial.totalAnimals || 0),
                qualityImproved: currentScore > initialScore,
                qualityDegraded: currentScore < initialScore
            };
        }

        function getQualityScore(quality) {
            const scores = { excellent: 4, good: 3, fair: 2, poor: 1, insufficient: 0 };
            return scores[quality] || 0;
        }

        // Cache and debouncing for performance
        let homogeneityUpdateTimer = null;
        let lastHomogeneityState = null;
        
        function displayHomogeneityComparison(comparison) {
            if (!comparison) {
                return;
            }
            
            // Create a simple hash of the current state to avoid unnecessary updates
            const currentState = createStateHash(comparison);
            if (currentState === lastHomogeneityState) {
                return; // No changes, skip update
            }
            
            // Clear previous timer
            if (homogeneityUpdateTimer) {
                clearTimeout(homogeneityUpdateTimer);
            }
            
            // Debounce updates to prevent flickering during rapid filter changes
            homogeneityUpdateTimer = setTimeout(() => {
                updateHomogeneityPanel(comparison);
                lastHomogeneityState = currentState;
            }, 100);
        }

        // Create a simple hash to detect state changes
        function createStateHash(comparison) {
            const initial = comparison.initial?.overallAssessment;
            const current = comparison.current?.overallAssessment;
            return `${initial?.averageCV}_${initial?.quality}_${current?.averageCV}_${current?.quality}_${comparison.dataset}_${comparison.initial?.totalAnimals}_${comparison.current?.totalAnimals}`;
        }

        function updateHomogeneityPanel(comparison) {
            // Remove existing comparison panel efficiently
            removeHomogeneityPanel();
            
            // Create comparison panel with validation
            const panel = document.createElement('div');
            panel.id = 'homogeneityComparison';
            panel.className = 'result-card homogeneity-comparison-panel';
            
            // Handle both new format (original vs filtered) and legacy format
            let initial, current, improvement, datasetLabel;
            
            if (comparison.original && comparison.filtered) {
                // New format: original vs filtered data
                initial = comparison.original?.overallAssessment;
                current = comparison.filtered?.overallAssessment;
                improvement = comparison.improvement;
                datasetLabel = getDatasetLabel(comparison.dataset) || 'Filtered Data';
            } else if (comparison.initial && comparison.current) {
                // Legacy format: maintain backward compatibility
                initial = comparison.initial?.overallAssessment;
                current = comparison.current?.overallAssessment;
                improvement = comparison.improvement;
                datasetLabel = getDatasetLabel(comparison.dataset) || 'Processed Data';
            } else {
                return;
            }
            
            if (!initial || !current) {
                return;
            }
            
            // Determine status colors with fallbacks
            const initialColor = getQualityColor(initial.quality) || '#6c757d';
            const currentColor = getQualityColor(current.quality) || '#6c757d';
            
            // Create proper homogeneity comparison content
            panel.innerHTML = `
                <h2>Model Homogeneity Comparison</h2>
                <div class="homogeneity-comparison-content">
                    <div class="comparison-row">
                        <div class="comparison-item">
                            <div class="comparison-label">Initial Assessment (Raw Data)</div>
                            <div class="comparison-value">
                                <div class="cv-value">${initial.averageCV}%</div>
                                <div class="quality-badge-small" style="background-color: ${initialColor};">
                                    ${initial.quality.toUpperCase()}
                                </div>
                                <div class="comparison-detail">${comparison.original?.totalAnimals || comparison.initial?.totalAnimals} animals</div>
                            </div>
                        </div>
                        <div class="comparison-arrow">→</div>
                        <div class="comparison-item">
                            <div class="comparison-label">Final Assessment (${datasetLabel})</div>
                            <div class="comparison-value">
                                <div class="cv-value">${current.averageCV}%</div>
                                <div class="quality-badge-small" style="background-color: ${currentColor};">
                                    ${current.quality.toUpperCase()}
                                </div>
                                <div class="comparison-detail">${comparison.filtered?.totalAnimals || comparison.current?.totalAnimals} animals</div>
                            </div>
                        </div>
                    </div>
                    <div class="improvement-summary">
                        <div class="improvement-item">
                            <div class="improvement-label">CV Reduction</div>
                            <div class="improvement-value ${improvement.cvReduction >= 0 ? 'positive' : 'negative'}">
                                ${improvement.cvReduction >= 0 ? '+' : ''}${improvement.cvReduction.toFixed(1)}%
                            </div>
                        </div>
                        <div class="improvement-item">
                            <div class="improvement-label">Quality Change</div>
                            <div class="improvement-value ${improvement.qualityImproved ? 'positive' : (improvement.qualityDegraded ? 'negative' : '')}">
                                ${initial.quality} → ${current.quality}
                            </div>
                        </div>
                        <div class="improvement-item">
                            <div class="improvement-label">Animals Removed</div>
                            <div class="improvement-value">
                                ${comparison.initial.totalAnimals - comparison.current.totalAnimals}
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.1); text-align: center;">
                        <button class="btn quaternary" onclick="evaluateAndShowHomogeneity()" style="background: linear-gradient(45deg, #20c997, #28a745);">
                            Test Homogeneity
                        </button>
                    </div>
                </div>
            `;
            
            // Insert panel after outlier analysis
            const outlierCard = document.getElementById('outlierCard');
            if (outlierCard) {
                outlierCard.parentNode.insertBefore(panel, outlierCard.nextSibling);
            } else {
                // Fallback: add to results section
                const resultsSection = document.getElementById('results');
                if (resultsSection) {
                    // Insert at the very beginning of results section
                    resultsSection.insertBefore(panel, resultsSection.firstChild);
                }
            }
        }

        function getQualityColor(quality) {
            const colors = {
                excellent: '#28a745',
                good: '#20c997', 
                fair: '#ffc107',
                poor: '#dc3545',
                insufficient: '#6c757d'
            };
            return colors[quality] || '#6c757d';
        }

        function getDatasetLabel(datasetType) {
            const labels = {
                'all': 'All Data + R² Filter',
                'filtered': 'Filtered Animals + R² Filter', 
                'points': 'Filtered Points + R² Filter',
                'validAnimals': 'R² Filtered'
            };
            return labels[datasetType] || 'Processed Data';
        }

        function updateHomogeneityComparisonForCurrentState() {
            // Early validation using AppState references
            if (!AppState.initialHomogeneityResults || !AppState.homogeneityEvaluator || !processedData?.validAnimals?.length) {
                Logger.warn('Missing data for homogeneity panel - removing panel');
                removeHomogeneityPanel();
                return;
            }
            
            try {
                // Get current filtering configuration and source data
                const r2Threshold = parseFloat(document.getElementById('r2Threshold')?.value) || 0.8;
                const { datasetType, sourceAnimals } = getSourceAnimalsByFilterType();
                
                // Apply R² threshold filter
                const finalAnimals = applyR2FilterToAnimals(sourceAnimals, r2Threshold);
                
                if (finalAnimals.length === 0) {
                    Logger.warn('No animals passed R² filter - removing homogeneity panel');
                    removeHomogeneityPanel();
                    return;
                }
                
                // Create and display homogeneity comparison
                const comparison = createHomogeneityComparison(finalAnimals, datasetType);
                if (comparison) {
                    displayHomogeneityComparison(comparison);
                } else {
                    Logger.warn('Failed to create homogeneity comparison');
                    removeHomogeneityPanel();
                }
                
            } catch (error) {
                Logger.error('Error updating homogeneity comparison:', error);
                removeHomogeneityPanel();
            }
        }

        // Get source animals based on current cyclic button filter state
        function getSourceAnimalsByFilterType() {
            const outlierAnalysis = AppState.outlierAnalysis;
            
            // Use AppState variables for consistency with cyclic button state
            const currentUsePointFiltering = AppState.usePointFiltering || usePointFiltering;
            const currentUseFilteredData = AppState.useFilteredData || useFilteredData;
            
            // Fallback to processedData if outlierAnalysis is not available
            if (!outlierAnalysis && processedData?.validAnimals?.length > 0) {
                Logger.log('Using processedData.validAnimals as fallback for homogeneity analysis');
                return {
                    datasetType: currentUsePointFiltering ? 'points' : 
                               currentUseFilteredData ? 'filtered' : 'all',
                    sourceAnimals: processedData.validAnimals
                };
            }
            
            if (currentUsePointFiltering) {
                return {
                    datasetType: 'points',
                    sourceAnimals: outlierAnalysis?.pointFilteringAnalysis?.animals || 
                                  outlierAnalysis?.dualAnalysis?.complete?.animals ||
                                  processedData?.validAnimals ||
                                  AppState.rawData || []
                };
            } else if (currentUseFilteredData) {
                return {
                    datasetType: 'filtered', 
                    sourceAnimals: outlierAnalysis?.dualAnalysis?.filtered?.animals || 
                                  outlierAnalysis?.dualAnalysis?.complete?.animals ||
                                  processedData?.validAnimals ||
                                  AppState.rawData || []
                };
            } else {
                // "All data" mode - use complete dataset with robust fallbacks
                return {
                    datasetType: 'all',
                    sourceAnimals: outlierAnalysis?.dualAnalysis?.complete?.animals 
                        || outlierAnalysis?.animals
                        || processedData?.validAnimals
                        || AppState.rawData 
                        || []
                };
            }
        }

        // Optimized R² filtering with model caching
        function applyR2FilterToAnimals(animals, threshold) {
            const validAnimals = [];
            
            for (const animal of animals) {
                // Skip animals without sufficient data
                if (!animal?.timePoints?.length || !animal?.measurements?.length || animal.timePoints.length < 3) {
                    continue;
                }
                
                // Reuse existing model or calculate new one
                let model = animal.model;
                if (!model) {
                    try {
                        model = fitExponentialModel(animal.timePoints, animal.measurements);
                    } catch (error) {
                        continue;
                    }
                }
                
                // Apply R² threshold
                if (model?.r2 >= threshold) {
                    validAnimals.push({
                        id: animal.id,
                        group: animal.group,
                        timePoints: [...animal.timePoints], // Defensive copy
                        measurements: [...animal.measurements], // Defensive copy
                        model: model
                    });
                }
            }
            
            return validAnimals;
        }

        // Streamlined homogeneity comparison creation
        function createHomogeneityComparison(animals, datasetType) {
            try {
                const currentResults = AppState.homogeneityEvaluator.evaluate(animals);
                return {
                    initial: AppState.initialHomogeneityResults,
                    current: currentResults,
                    dataset: datasetType,
                    improvement: calculateHomogeneityImprovement(AppState.initialHomogeneityResults, currentResults)
                };
            } catch (error) {
                return null;
            }
        }

        // Utility function to remove homogeneity panel
        function removeHomogeneityPanel() {
            const panel = document.getElementById('homogeneityComparison');
            if (panel) {
                panel.remove();
            }
        }

        // Reset homogeneity system cache (call when loading new dataset)
        function resetHomogeneityCache() {
            lastHomogeneityState = null;
            if (homogeneityUpdateTimer) {
                clearTimeout(homogeneityUpdateTimer);
                homogeneityUpdateTimer = null;
            }
            removeHomogeneityPanel();
        }
        // ===== END MODEL HOMOGENEITY EVALUATION SYSTEM =====

        function handleFileSelect(e) {
            const file = e.target.files[0];
            const fileLabel = document.getElementById('fileLabel');
            
            // Skip file handling if we're in tutorial mode
            if (tutorialMode) {
                return;
            }
            
            // Enhanced validation
            if (!file) {
                Logger.log('No file selected');
                resetFileLabel(fileLabel);
                return;
            }

            // File validation
            const validationResult = validateFile(file);
            if (!validationResult.isValid) {
                Logger.error('File validation failed:', validationResult.errors);
                showNotification(validationResult.errors.join('; '), 'error');
                resetFileLabel(fileLabel);
                return;
            }

            Logger.log('File selected and validated:', {
                name: file.name,
                size: `${(file.size / 1024 / 1024).toFixed(2)} MB`,
                type: file.type || 'text/csv',
                lastModified: new Date(file.lastModified).toLocaleDateString()
            });

            // Clear all previous results and data when loading new dataset
            clearAllResults();

            // Store filename for use in reports
            currentFileName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension

            // Show loading state
            fileLabel.innerHTML = `
                📄 ${file.name} (Loading...)
                <br><small style="color: #a0a0a0; margin-top: 8px;">Processing file...</small>
            `;
            fileLabel.style.borderColor = 'rgba(79, 172, 254, 0.8)';
            fileLabel.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.2), rgba(0, 153, 204, 0.2))';
            fileLabel.classList.add('file-loaded');

            if (typeof Papa === 'undefined') {
                showNotification('Error: PapaParse is not loaded', 'error');
                return;
            }

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function (results) {

                    if (results.errors && results.errors.length > 0) {
                        showNotification(`Warning: ${results.errors.length} errors in CSV`, 'warning');
                    }

                    rawData = results.data.filter(row => row && Object.keys(row).length > 0);
                    
                    // Store Tumor_Weight detection status for later use
                    window.hasTumorWeightColumn = rawData.length > 0 && rawData[0] && rawData[0].hasOwnProperty('Tumor_Weight');
                    
                    // Update prediction service with tumor weight status
                    if (AppState.predictionService) {
                        AppState.predictionService.setTumorWeightStatus(window.hasTumorWeightColumn);
                    }

                    if (rawData.length === 0) {
                        const fileLabel = document.getElementById('fileLabel');
                        fileLabel.innerHTML = `
                            ${file.name} (Empty or invalid)
                            <br><small style="color: #ff6b6b; padding-left: 5px; margin-top: 2px;">No valid data found</small>
                        `;
                        fileLabel.style.borderColor = 'rgba(255, 107, 107, 0.8)';
                        fileLabel.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(220, 53, 69, 0.1))';
                        showNotification('CSV file is empty or has no valid data', 'error');
                        return;
                    }

                    // Success state
                    const fileLabel = document.getElementById('fileLabel');
                    fileLabel.innerHTML = `
                        ${file.name} loaded successfully
                        <br><small style="color: #84D288; padding-left: 5px; margin-top: 2px;">${rawData.length} data rows processed</small>
                    `;
                    fileLabel.style.borderColor = 'rgba(132, 210, 136, 0.8)';
                    fileLabel.style.background = 'linear-gradient(135deg, rgba(132, 210, 136, 0.1), rgba(40, 167, 69, 0.1))';
                    showNotification(`File loaded: ${rawData.length} rows processed`, 'success');

                    // Auto-adjust outlier configuration based on sample size
                    const configSelect = document.getElementById('outlierConfig');
                    if (rawData.length < 5) {
                        configSelect.value = 'ultraConservative';
                    } else if (rawData.length <= 10) {
                        configSelect.value = 'conservative';
                    } else {
                        configSelect.value = 'moderate';
                    }
                    // [NEW] Evaluate baseline homogeneity before proceeding
                    evaluateAndShowHomogeneity();
                    
                    // Update contextual wizard button state
                    updateContextualWizardState('data-loaded');
                },
                error: function (error) {
                    const fileLabel = document.getElementById('fileLabel');
                    fileLabel.innerHTML = `
                        ❌ ${file.name} (Error)
                        <br><small style="color: #ff6b6b; margin-top: 8px;">Failed to load file</small>
                    `;
                    fileLabel.style.borderColor = 'rgba(255, 107, 107, 0.8)';
                    fileLabel.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(220, 53, 69, 0.1))';
                    showNotification('Error loading file: ' + error.message, 'error');
                }
            });
        }


        //OUTLIERS
        function initializeOutlierDetector() {
            const totalAnimals = rawData.length;
            const configSelect = document.getElementById('outlierConfig');
            const userConfig = configSelect.value;

            let config;
            if (userConfig === 'auto') {
                if (totalAnimals < 5) {
                    config = 'ultraConservative';
                } else if (totalAnimals <= 10) {
                    config = 'conservative';
                } else {
                    config = 'moderate';
                }

                // Update the select to show the auto-selected configuration
                const autoText = `Auto → ${OUTLIER_CONFIGS[config].name}`;
                const autoOption = configSelect.querySelector('option[value="auto"]');
                if (autoOption) {
                    autoOption.textContent = autoText;
                }

            } else {
                // User manual configuration
                config = userConfig;
            }

            AppState.outlierDetector = new IntelligentOutlierDetector(config);
            window.outlierDetector = AppState.outlierDetector;
            outlierDetector = AppState.outlierDetector;
            return AppState.outlierDetector;
        }

        function parseAnimalData(rawData) {
            const dayCols = Object.keys(rawData[0])
                .filter(k => !isNaN(parseFloat(k)))
                .map(Number)
                .sort((a, b) => a - b);

            const animals = rawData.map((row, i) => {
                const id = row.Animal || row.ID || `Animal_${i + 1}`;
                const group = row.Group || row.Grupo || 'No group';
                const tp = [], ms = [];
                dayCols.forEach(day => {
                    const val = parseFloat(row[day]);
                    if (!isNaN(val) && val > 0) {
                        tp.push(day);
                        ms.push(val);
                    }
                });
                if (tp.length >= 3) {
                    // Calculate exponential model
                    const model = fitExponentialModel(tp, ms);
                    return { id, group, timePoints: tp, measurements: ms, model };
                }
                return null;
            }).filter(Boolean);

            return { animals, dayCols };
        }


        let outlierPanelDisplaying = false;

        function displayOutlierPanel() {
            
            const outlierAnalysis = AppState.outlierAnalysis || window.getOutlierAnalysis?.() || window.outlierAnalysis;
            if (!outlierAnalysis) {
                return;
            }
            
            // Prevent multiple simultaneous displays
            if (outlierPanelDisplaying) {
                return;
            }
            outlierPanelDisplaying = true;

            const resultsDiv = document.getElementById('results');

            // Remove existing panel
            const existingPanel = document.getElementById('outlierCard');
            if (existingPanel) {
                existingPanel.remove();
            }

            const card = document.createElement('div');
            card.className = 'result-card intelligent-outlier-analysis-card';
            card.id = 'outlierCard';

            const summary = outlierAnalysis.summary;
            const dualAnalysis = outlierAnalysis.dualAnalysis;

            let html = `
                <h2>Intelligent Outlier Analysis</h2>
<div class="outlier-panel">
    <div class="outlier-summary">
        <div class="outlier-stat">
            <div class="outlier-stat-value">${summary.totalFlags}</div>
            <div class="outlier-stat-label">Detected Anomalies</div>
        </div>
        <div class="outlier-stat">
            <div class="outlier-stat-value outlier-stat-critical">${summary.severityCounts.critical}</div>
            <div class="outlier-stat-label">Critical</div>
        </div>
        <div class="outlier-stat">
            <div class="outlier-stat-value outlier-stat-high">${summary.severityCounts.high}</div>
            <div class="outlier-stat-label">High</div>
        </div>
        <div class="outlier-stat">
            <div class="outlier-stat-value outlier-stat-remaining">${dualAnalysis.filtered.count}</div>
            <div class="outlier-stat-label">Animals Post-Filter</div>
        </div>
    </div>
    
    <div class="center-text margin-15">
        <span class="config-badge">
            ${summary.configUsed}
        </span>
    </div>
</div>

<div class="dual-analysis-section">
    <h3 class="dual-analysis-title">Dual Analysis: Complete vs Filtered Data</h3>
    
    <div class="dual-analysis">
        <div class="analysis-box complete-analysis">
            <h4>All Data</h4>
            <p>Animals: <strong>${dualAnalysis.complete.count}</strong></p>
            <p>Measurements: <strong>${dualAnalysis.complete.totalMeasurements}</strong></p>
        </div>
        <div class="analysis-box filtered-analysis">
            <h4>Filtered Animals</h4>
            <p>Animals: <strong>${dualAnalysis.filtered.count}</strong></p>
            <p>Measurements: <strong>${dualAnalysis.filtered.totalMeasurements}</strong></p>
            <p>Excluded: <strong>${dualAnalysis.impact.animalsExcluded} animals</strong></p>
        </div>
        <div class="analysis-box points-filtered-analysis">
            <h4>Filtered Points</h4>
            <p>Animals: <strong>${outlierAnalysis.pointFilteringAnalysis.animals.length}</strong></p>
            <p>Measurements: <strong>${outlierAnalysis.pointFilteringAnalysis.totalPointsFiltered}</strong></p>
            <p>Excluded: <strong>${outlierAnalysis.pointFilteringAnalysis.excludedPoints} points</strong></p>
        </div>
    </div>
         
    <div class="center-text margin-20">
        <button
            id="cyclicBtn"
            class="btn cyclic-btn-style"
            onclick="cycleThroughStates()"
        >
            All Data
        </button>
        <button
            class="btn secondary"
            onclick="showOutlierDetails()"
        >
            View Details
        </button>
    </div>

    <div class="filtering-info">
        <strong>Point Filtering:</strong> Excludes problematic individual measurements without removing complete animals from analysis.
        <br><strong>Animal Filtering:</strong> Excludes complete animals that do not meet quality criteria.
    </div>
    
    ${dualAnalysis.impact.animalsExcluded > 0 || dualAnalysis.impact.measurementsExcluded > 0 ? `
    <div class="filtering-impact">
        <strong>Filtering Impact:</strong><br>
        ${dualAnalysis.impact.animalsExcluded > 0 ? `• ${dualAnalysis.impact.animalsExcluded} excluded animals<br>` : ''}
        ${dualAnalysis.impact.measurementsExcluded > 0 ? `• ${dualAnalysis.impact.measurementsExcluded} problematic measurements<br>` : ''}
    </div>
    ` : ''}
</div>
            `;

                // Specific recommendations
            if (outlierAnalysis.specificRecommendations && outlierAnalysis.specificRecommendations.length > 0) {
                html += '<div style="margin: 15px 0;"><h3 style="color: #4facfe;">Specific Recommendations</h3>';

                outlierAnalysis.specificRecommendations.forEach((rec, index) => {
                    let bgColor, borderColor, icon;

                    switch (rec.type) {
                        case 'warning':
                            bgColor = 'rgba(255, 193, 7, 0.1)';
                            borderColor = '#ffc107';
                            icon = '⚠️';
                            break;
                        case 'info':
                            bgColor = 'rgba(33, 150, 243, 0.1)';
                            borderColor = '#2196f3';
                            icon = 'ℹ️';
                            break;
                        default:
                            bgColor = 'rgba(76, 175, 80, 0.1)';
                            borderColor = '#4caf50';
                            icon = '✅';
                    }

                    html += `
                        <div style="background: ${bgColor}; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid ${borderColor};">
                            <div style="display: flex; align-items: flex-start; gap: 10px;">
                                <span style="font-size: 1.2rem;">${icon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; margin-bottom: 5px; color: ${borderColor};">
                                        ${rec.title} (${rec.category})
                                    </div>
                                    <div style="margin-bottom: 8px; font-size: 0.95rem;">
                                        ${rec.message}
                                    </div>
                                    <div style="font-style: italic; color: white; font-size: 0.95rem; background: rgba(255,255,255,0.1); padding: 8px; border-radius: 4px;">
                                        <strong>Recommendation:</strong> ${rec.recommendation}
                                    </div>
                                    ${rec.affectedAnimals && rec.affectedAnimals.length > 0 ? `
                                        <div style="margin-top: 8px; font-size: 0.95rem; color: #f8f8f8;">
                                            <strong>Affected animals:</strong> ${rec.affectedAnimals.slice(0, 5).join(', ')}${rec.affectedAnimals.length > 5 ? ` (+${rec.affectedAnimals.length - 5} more)` : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            if (outlierAnalysis.recommendations.length > 0) {
                html += '<div style="margin: 15px 0;"><h3 style="color: #4facfe;">Recommendations</h3>';
                outlierAnalysis.recommendations.forEach(rec => {
                    const bgColor = rec.type === 'success' ? 'rgba(76, 175, 80, 0.1)' :
                        rec.type === 'warning' ? 'rgba(255, 193, 7, 0.1)' :
                            'rgba(33, 150, 243, 0.1)';
                    const borderColor = rec.type === 'success' ? '#4caf50' :
                        rec.type === 'warning' ? '#ffc107' : '#2196f3';

                    html += `
                        <div style="background: ${bgColor}; padding: 12px; border-radius: 8px; margin: 8px 0; border-left: 4px solid ${borderColor};">
                            <strong>${rec.title}:</strong> ${rec.message}
                        </div>
                    `;
                });
                html += '</div>';
            }

            card.innerHTML = html;

            // Insert at the beginning of results
            resultsDiv.insertBefore(card, resultsDiv.firstChild);
            
            // Reset flag after successful completion
            outlierPanelDisplaying = false;
        }

        function showOutlierDetails() {
            const outlierAnalysis = AppState.outlierAnalysis || window.getOutlierAnalysis?.() || window.outlierAnalysis;
            if (!outlierAnalysis) {
                return;
            }

            // Use new ModalManager system
            window.modalManager.show('outlier', { outlierAnalysis });
        }


        // REMOVED: Legacy createOutlierModalElement function
        // Outlier modal now handled by ModalManager system
        // Use window.modalManager.show('outlier', data) instead

        // Helper function to get real flags from IntelligentOutlierDetector analysis
        function generateAnimalFlags(animal) {
            const outlierAnalysis = AppState.outlierAnalysis || window.getOutlierAnalysis?.() || window.outlierAnalysis;
            
            if (!outlierAnalysis || !outlierAnalysis.flags) {
                return [];
            }

            // Get real flags from the IntelligentOutlierDetector for this animal
            const animalFlags = outlierAnalysis.flags.filter(flag => flag.animalId === animal.id);
            
            // Convert real flags to display format with proper metadata
            const displayFlags = animalFlags.map(flag => {
                const flagType = FLAG_TYPES[flag.type] || { 
                    name: flag.type, 
                    color: '#6c757d', 
                    severity: 'low' 
                };
                
                return {
                    type: flag.type,
                    name: flagType.name,
                    color: flagType.color,
                    day: flag.day,
                    value: flag.value,
                    description: flag.message || `${flagType.name} detected`,
                    severity: flagType.severity
                };
            });

            return displayFlags;
        }

        // Helper function to generate HTML for flag details
        function generateFlagDetailsHTML(flags, animal) {
            if (flags.length === 0) {
                return '<div style="color: #6c757d; font-style: italic;">No specific flags detected</div>';
            }

            return flags.map(flag => {
                const dayDisplay = flag.day !== null ? `Day ${flag.day}` : '-';
                const valueDisplay = flag.value !== null ? 
                    (typeof flag.value === 'number' ? 
                        (flag.value >= 1000 ? flag.value.toExponential(2) : flag.value.toFixed(2)) : 
                        flag.value) : '-';
                
                // Get severity color
                const severityColors = {
                    'critical': '#dc3545',
                    'high': '#fd7e14', 
                    'medium': '#ffc107',
                    'low': '#6c757d'
                };
                const severityColor = severityColors[flag.severity] || '#6c757d';

                return `
                    <div style="background: white; padding: 12px; border-radius: 8px; border-left: 4px solid ${flag.color}; margin-bottom: 8px;">
                        <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 12px; align-items: center;">
                            <div>
                                <span style="background: ${flag.color}; color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: 500;">
                                    ${flag.name}
                                </span>
                            </div>
                            <div style="text-align: center;">
                                <span style="background: ${severityColor}; color: white; padding: 3px 8px; border-radius: 8px; font-size: 0.75rem; font-weight: 500; text-transform: uppercase;">
                                    ${flag.severity}
                                </span>
                            </div>
                            <div style="text-align: center; font-weight: 500; color: #495057; background: rgba(0,123,255,0.1); padding: 4px 8px; border-radius: 6px;">
                                ${dayDisplay}
                            </div>
                            <div style="text-align: center; font-family: monospace; font-weight: 500; color: #495057; background: rgba(40,167,69,0.1); padding: 4px 8px; border-radius: 6px;">
                                ${valueDisplay}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Function to toggle animal details
        function toggleAnimalDetails(animalId) {
            const detailsRow = document.getElementById(`details-${animalId}`);
            const expandIcon = document.getElementById(`expand-icon-${animalId}`);
            
            if (detailsRow && expandIcon) {
                const isVisible = detailsRow.style.display !== 'none';
                
                if (isVisible) {
                    detailsRow.style.display = 'none';
                    expandIcon.textContent = '▶';
                    expandIcon.style.transform = 'rotate(0deg)';
                } else {
                    detailsRow.style.display = 'table-row';
                    expandIcon.textContent = '▼';
                    expandIcon.style.transform = 'rotate(90deg)';
                }
            }
        }

        // Outlier modal management consolidated - handled by ModalManager and createOutlierModalElement()

        // exportOutlierReport() - REMOVED: Use exportManager.export('outlier') instead

        // updateOutlierConfig() - REMOVED: Now handled by FormChangeHandler

        function updateOutlierFiltering() {
            const filteringSelect = document.getElementById('outlierFiltering');
            const selectedFiltering = filteringSelect.value;

            // Skip notifications if called from wizard
            if (window.suppressOutlierNotification) {
                return;
            }

            // Update filtering configuration
            if (AppState.outlierDetector) {
                try {
                    if (typeof AppState.outlierDetector.setFilteringLevel === 'function') {
                        AppState.outlierDetector.setFilteringLevel(selectedFiltering);
                    } else if (typeof AppState.outlierDetector.updateFilteringLevel === 'function') {
                        AppState.outlierDetector.updateFilteringLevel(selectedFiltering);
                    } else {
                        // Store the setting for future use
                        AppState.outlierDetector.filteringLevel = selectedFiltering;
                        Logger.log(`Outlier filtering level set to: ${selectedFiltering}`);
                    }
                } catch (error) {
                    Logger.warn('Could not update outlier detector filtering level:', error.message);
                }
            }

            const filteringLabels = {
                'critical': 'Critical Only',
                'criticalAndHigh': 'Critical + High',
                'all': 'All Anomalies'
            };

            showNotification(`Filtering level updated: ${filteringLabels[selectedFiltering]}`, 'info');
            
            // Update homogeneity panel if analysis has been performed
            updateHomogeneityComparisonForCurrentState();
        }
        //********

        //UI functions
        function cycleThroughStates() {
            const button = document.getElementById('cyclicBtn');

            // Advance to next state
            currentState = (currentState + 1) % states.length;

            // Update button (static text)
            const state = states[currentState];
            button.innerHTML = state.text;
            button.style.cssText = state.style + " margin-right: 10px;";

            // Execute corresponding action
            state.action();

            // Update active box
            setTimeout(() => updateActiveAnalysisBox(), 100);
            
            // Update homogeneity panel to reflect new dataset state
            setTimeout(() => updateHomogeneityComparisonForCurrentState(), 150);
        }

        function updateActiveAnalysisBox() {
            // Remove 'active' class from all boxes
            document.querySelectorAll('.analysis-box').forEach(box => {
                box.classList.remove('active');
            });

            // Determine which box should be active based on currentState
            let activeBoxClass;
            switch (currentState) {
                case 0:
                    activeBoxClass = '.complete-analysis';
                    break;
                case 1:
                    activeBoxClass = '.filtered-analysis';
                    break;
                case 2:
                    activeBoxClass = '.points-filtered-analysis';
                    break;
                default:
                    activeBoxClass = '.complete-analysis';
            }

            // Add 'active' class to corresponding box
            const activeBox = document.querySelector(activeBoxClass);
            if (activeBox) {
                activeBox.classList.add('active');
            }
        }

        function initializeActiveBox() {
            // Set initial box as active (state 0 by default)
            updateActiveAnalysisBox();
        }

        function getStateText(stateIndex) {
            if (!AppState.outlierAnalysis) {
                // Default texts when no analysis is available
                const defaultTexts = [
                    "All data",
                    "Filtered animals",
                    "Filtered points"
                ];
                return defaultTexts[stateIndex];
            }

            // Texts with counters when analysis is available
            switch (stateIndex) {
                case 0:
                    const totalAnimals = outlierAnalysis.dualAnalysis.complete.count;
                    const totalPoints = outlierAnalysis.dualAnalysis.complete.totalMeasurements;
                    return `All data (${totalAnimals} animals, ${totalPoints} points)`;

                case 1:
                    const excludedAnimals = outlierAnalysis.dualAnalysis.impact.animalsExcluded;
                    const remainingAnimals = outlierAnalysis.dualAnalysis.filtered.count;
                    const remainingPoints = outlierAnalysis.dualAnalysis.filtered.totalMeasurements;
                    return `Filtered animals (-${excludedAnimals} animals | ${remainingAnimals} remaining, ${remainingPoints} points)`;

                case 2:
                    // Ensure point analysis exists
                    if (!outlierAnalysis.pointFilteringAnalysis) {
                        outlierAnalysis.pointFilteringAnalysis = outlierDetector.performPointFilteringAnalysis(
                            outlierAnalysis.dualAnalysis.complete.animals
                        );
                    }
                    const excludedPoints = outlierAnalysis.pointFilteringAnalysis.excludedPoints;
                    const remainingPointsFiltered = outlierAnalysis.pointFilteringAnalysis.totalPointsFiltered;
                    const totalAnimalsInPoints = outlierAnalysis.pointFilteringAnalysis.animals.length;
                    return `Filtered points (-${excludedPoints} points | ${totalAnimalsInPoints} animals, ${remainingPointsFiltered} points)`;

                default:
                    return "Unknown state";
            }
        }

        function reprocessDataWithOutlierSelection(selectedAnimals) {
            // Reset variables
            animalModels = {};
            processedData = {
                validAnimals: [],
                invalidAnimals: [],
                groupStats: {},
                dataType: processedData.dataType
            };

            const threshold = parseFloat(document.getElementById('r2Threshold').value);

            // Process selected animals
            let validCount = 0;
            let invalidCount = 0;

            selectedAnimals.forEach(animal => {
                if (animal.timePoints.length >= 3) {
                    const model = fitExponentialModel(animal.timePoints, animal.measurements);
                    const animalData = {
                        id: animal.id,
                        group: animal.group,
                        timePoints: animal.timePoints,
                        measurements: animal.measurements,
                        model: model,
                        dataType: processedData.dataType
                    };

                    if (model.r2 >= threshold) {
                        animalModels[animal.id] = animalData;
                        processedData.validAnimals.push(animalData);
                        validCount++;
                    } else {
                        processedData.invalidAnimals.push(animalData);
                        invalidCount++;
                    }
                }
            });

            // Recalculate group statistics
            calculateGroupStats();

            // Update visualization
            updateResultsAfterOutlierProcessing();

            // Update homogeneity comparison with current dataset (after content regeneration)
            updateHomogeneityComparisonForCurrentState();
        }

        function updateResultsAfterOutlierProcessing() {
            // Remove previous results (except outlier and homogeneity panels)
            const resultsDiv = document.getElementById('results');
            const existingCards = resultsDiv.querySelectorAll('.result-card:not(#outlierCard):not(#homogeneityComparison)');
            existingCards.forEach(card => card.remove());

            // Regenerar resultados
            if (processedData.validAnimals.length > 0) {
                createSummaryCard();
                createGroupStatsCard();
                createParameterTable();
                createStatisticalComparisonCard();
                createMainChart();
                createNormalizedGrowthChart();
            }
        }
        //**********************

        // Function to show data preview
        function showDataPreview() {
            if (rawData.length === 0) {
                showNotification('No data loaded to display', 'warning');
                return;
            }

            const resultsDiv = document.getElementById('results');

            let previewCard = document.getElementById('previewCard');
            if (!previewCard) {
                previewCard = document.createElement('div');
                previewCard.id = 'previewCard';
                previewCard.className = 'result-card';
                resultsDiv.appendChild(previewCard);
            }

            const columns = Object.keys(rawData[0]);
            const preview = rawData.slice(0, 5);

            let html = '<h2>Loaded Data Preview</h2>';
            html += `<p><strong>Total rows:</strong> ${rawData.length}</p>`;
            html += `<p><strong>Total columns:</strong> ${columns.length}</p>`;
            html += '<h3>First 5 rows:</h3>';
            html += '<table><thead><tr>';

            columns.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '</tr></thead><tbody>';

            preview.forEach((row, idx) => {
                html += `<tr>`;
                columns.forEach(col => {
                    html += `<td>${row[col] || ''}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';

            previewCard.innerHTML = html;
            showNotification('Data preview displayed', 'success');
        }

        // Function to perform data analysis with Web Worker (if available)
        async function analyzeDataWithWorker(animalsToAnalyze, options = {}) {
            const workerManager = AppState.workerManager;
            
            // Fallback to main thread if worker not available
            if (!workerManager || !workerManager.getStatus().ready) {
                Logger.warn('Worker not available, using main thread');
                return analyzeDataMainThread(animalsToAnalyze, options);
            }

            try {
                // Set up progress callback
                let progressNotificationShown = false;
                workerManager.setProgressCallback((progress) => {
                    if (!progressNotificationShown && progress.overallProgress > 10) {
                        showNotification(`Processing animals: ${progress.overallProgress}% complete`, 'info');
                        progressNotificationShown = true;
                    }
                    
                    // Update progress in debug panel if available
                    const debugConsole = document.getElementById('debugConsole');
                    if (debugConsole) {
                        debugConsole.innerHTML += `<div>Batch ${progress.batchIndex + 1}/${progress.totalBatches}: ${progress.batchProgress}% (Overall: ${progress.overallProgress}%)</div>`;
                        debugConsole.scrollTop = debugConsole.scrollHeight;
                    }
                });

                Logger.log(`🚀 Starting Web Worker analysis of ${animalsToAnalyze.length} animals`);
                const startTime = performance.now();

                const result = await workerManager.analyzeAnimals(animalsToAnalyze, {
                    batchSize: options.batchSize || 50,
                    timeout: options.timeout || 60000
                });

                const processingTime = performance.now() - startTime;
                Logger.log(`✅ Worker analysis completed in ${processingTime.toFixed(2)}ms`);
                
                showNotification(`Analysis completed: ${result.stats.validModels}/${result.stats.totalAnimals} valid models`, 'success');
                
                return result.animals;

            } catch (error) {
                Logger.error('❌ Worker analysis failed:', error);
                showNotification('Worker analysis failed, falling back to main thread', 'warning');
                
                // Fallback to main thread
                return analyzeDataMainThread(animalsToAnalyze, options);
            }
        }

        // Original main thread analysis (backup)
        function analyzeDataMainThread(animalsToAnalyze, options = {}) {
            Logger.log(`Using main thread analysis for ${animalsToAnalyze.length} animals`);
            
            const results = [];
            const startTime = performance.now();
            
            animalsToAnalyze.forEach((animal, index) => {
                if (animal.timePoints.length >= 3) {
                    const model = fitExponentialModel(animal.timePoints, animal.measurements);
                    
                    results.push({
                        ...animal,
                        model: model,
                        metrics: {
                            finalValue: animal.measurements[animal.measurements.length - 1],
                            initialValue: animal.measurements[0],
                            growthRatio: animal.measurements[animal.measurements.length - 1] / animal.measurements[0],
                            maxValue: Math.max(...animal.measurements),
                            minValue: Math.min(...animal.measurements.filter(v => v > 0))
                        }
                    });
                }
                
                // Progress notification for main thread
                if (index > 0 && index % 100 === 0) {
                    const progress = Math.round((index / animalsToAnalyze.length) * 100);
                    showNotification(`Processing: ${progress}% complete`, 'info');
                }
            });
            
            const processingTime = performance.now() - startTime;
            Logger.log(`Main thread analysis completed in ${processingTime.toFixed(2)}ms`);
            
            return results;
        }

        // Function for complete data analysis (OPTIMIZED) - Now using AnalysisController
        async function analyzeData() {
            try {
                
                const results = await analysisController.analyzeData(rawData);
                
                if (results) {
                    // Display results (homogeneity comparison will be handled inside displayResults)
                    displayResults();
                    
                    // Show outliers panel
                    displayOutlierPanel();
                    initializeActiveBox();
                }
            } catch (error) {
                Logger.error('❌ Analysis failed:', error);
                showNotification('Analysis failed. Please try again.', 'error');
            }
        }

        function fitExponentialModel(x, y) {
            try {
                const validPoints = [];
                const validX = [];
                const validY = [];
                
                for (let i = 0; i < x.length; i++) {
                    if (y[i] > 0 && !isNaN(y[i]) && !isNaN(x[i])) {
                        validX.push(x[i]);
                        validY.push(Math.log(y[i]));
                        validPoints.push({ x: x[i], y: y[i] });
                    }
                }

                if (validPoints.length < 3) {
                    return {
                        a: 1,
                        r: 0, // r is the growth rate
                        r2: 0,
                        validPoints: validPoints.length,
                        equation: 'Insufficient data',
                        error: 'Less than 3 valid points'
                    };
                }

                // Linear regression on log-transformed data: ln(y) = ln(a) + bx
                const n = validX.length;
                const sumX = validX.reduce((a, b) => a + b, 0);
                const sumY = validY.reduce((a, b) => a + b, 0);
                const sumXY = validX.reduce((sum, x, i) => sum + x * validY[i], 0);
                const sumX2 = validX.reduce((sum, x) => sum + x * x, 0);

                const b = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const lnA = (sumY - b * sumX) / n;
                const a = Math.exp(lnA);

                // Calculate R²
                const yMean = sumY / n;
                let ssRes = 0;
                let ssTot = 0;

                for (let i = 0; i < validX.length; i++) {
                    const predicted = lnA + b * validX[i];
                    ssRes += Math.pow(validY[i] - predicted, 2);
                    ssTot += Math.pow(validY[i] - yMean, 2);
                }

                const r2 = Math.max(0, 1 - (ssRes / ssTot));

                return {
                    a: isFinite(a) ? a : 1,
                    r: isFinite(b) ? b : 0, // r is the growth rate (was b in linear regression)
                    r2: isFinite(r2) ? r2 : 0,
                    validPoints: validPoints.length,
                    equation: `y = ${a.toFixed(2)} × e^(${isFinite(b) ? b.toFixed(4) : '0.0000'}×t)`,
                    error: null
                };

            } catch (error) {
                return {
                    a: 1,
                    r: 0, // r is the growth rate
                    r2: 0,
                    validPoints: 0,
                    equation: 'Error in calculation',
                    error: error.message
                };
            }
        }

        // Function to calculate group statistics
        function calculateGroupStats() {
            const startTime = performance.now();
            processedData.groupStats = {};
            
            // Pre-allocate group stats objects
            const allAnimals = [...processedData.validAnimals, ...processedData.invalidAnimals];
            const groupsMap = new Map();
            
            // Single pass to initialize groups and count animals
            for (const animal of allAnimals) {
                const groupName = animal.group;
                let groupStats = groupsMap.get(groupName);
                
                if (!groupStats) {
                    groupStats = {
                        valid: 0,
                        invalid: 0,
                        validAnimals: [],
                        avgR: 0,
                        avgR2: 0,
                        avgA: 0,
                        stdR: 0,
                        stdA: 0,
                        seR: 0,
                        seA: 0
                    };
                    groupsMap.set(groupName, groupStats);
                    processedData.groupStats[groupName] = groupStats;
                }
            }

            // Count valid animals and prepare for stats calculation
            for (const animal of processedData.validAnimals) {
                const stats = groupsMap.get(animal.group);
                stats.valid++;
                stats.validAnimals.push(animal);
            }

            // Count invalid animals
            for (const animal of processedData.invalidAnimals) {
                const stats = groupsMap.get(animal.group);
                stats.invalid++;
            }

            // Calculate statistics efficiently
            for (const [group, stats] of groupsMap) {
                const validInGroup = stats.validAnimals;

                if (validInGroup.length > 0) {
                    let sumR = 0, sumR2 = 0, sumA = 0;
                    
                    // Single pass for averages
                    for (const animal of validInGroup) {
                        sumR += animal.model.r;
                        sumR2 += animal.model.r2;
                        sumA += animal.model.a;
                    }
                    
                    const n = validInGroup.length;
                    stats.avgR = sumR / n;
                    stats.avgR2 = sumR2 / n;
                    stats.avgA = sumA / n;

                    // Standard deviations and standard errors - optimized calculation
                    if (n > 1) {
                        let sumSqR = 0, sumSqA = 0;
                        
                        // Single pass for variance calculation
                        for (const animal of validInGroup) {
                            const devR = animal.model.r - stats.avgR;
                            const devA = animal.model.a - stats.avgA;
                            sumSqR += devR * devR;
                            sumSqA += devA * devA;
                        }
                        
                        stats.stdR = Math.sqrt(sumSqR / (n - 1));
                        stats.stdA = Math.sqrt(sumSqA / (n - 1));
                        
                        const sqrtN = Math.sqrt(n);
                        stats.seR = stats.stdR / sqrtN;
                        stats.seA = stats.stdA / sqrtN;
                    } else {
                        stats.stdR = 0;
                        stats.stdA = 0;
                        stats.seR = 0;
                        stats.seA = 0;
                    }
                }
            }

            const endTime = performance.now();
            Logger.log(`Group statistics calculated in ${(endTime - startTime).toFixed(2)}ms`, { 
                groups: groupsMap.size, 
                totalAnimals: allAnimals.length 
            });
        }

        // Statistical comparison functions for r values
        function performStatisticalComparison() {
            const groups = Object.keys(processedData.groupStats);
            const comparisons = [];

            // Perform pairwise comparisons between all groups
            for (let i = 0; i < groups.length; i++) {
                for (let j = i + 1; j < groups.length; j++) {
                    const group1 = groups[i];
                    const group2 = groups[j];
                    const stats1 = processedData.groupStats[group1];
                    const stats2 = processedData.groupStats[group2];

                    // Only compare groups with valid animals
                    if (stats1.validAnimals.length > 1 && stats2.validAnimals.length > 1) {
                        const comparison = compareGroups(group1, group2, stats1, stats2);
                        comparisons.push(comparison);
                    }
                }
            }

            return comparisons;
        }

        function compareGroups(group1Name, group2Name, stats1, stats2) {
            // Extract r values for each group
            const rValues1 = stats1.validAnimals.map(animal => animal.model.r);
            const rValues2 = stats2.validAnimals.map(animal => animal.model.r);

            // Perform Mann-Whitney U test
            const mannWhitneyResult = MathUtils.mannWhitneyUTest(rValues1, rValues2);

            // Calculate Cohen's d effect size
            const pooledStd = Math.sqrt(((rValues1.length - 1) * Math.pow(stats1.stdR, 2) + (rValues2.length - 1) * Math.pow(stats2.stdR, 2)) / (rValues1.length + rValues2.length - 2));
            const cohensD = Math.abs(stats1.avgR - stats2.avgR) / pooledStd;

            // Calculate median values for better representation of non-parametric data
            const median1 = MathUtils.calculateMedian(rValues1);
            const median2 = MathUtils.calculateMedian(rValues2);
            const medianDiff = median1 - median2;

            return {
                group1: group1Name,
                group2: group2Name,
                n1: rValues1.length,
                n2: rValues2.length,
                mean1: stats1.avgR,
                mean2: stats2.avgR,
                median1: median1,
                median2: median2,
                std1: stats1.stdR,
                std2: stats2.stdR,
                meanDiff: stats1.avgR - stats2.avgR,
                medianDiff: medianDiff,
                UStatistic: mannWhitneyResult.U,
                zStatistic: mannWhitneyResult.z,
                pValue: mannWhitneyResult.p,
                cohensD: cohensD,
                effectSize: MathUtils.getEffectSizeLabel(cohensD),
                significant: mannWhitneyResult.p < 0.05
            };
        }

        // Wrapper functions removed - use MathUtils directly for better maintainability

        // erf wrapper removed - use MathUtils.erf() directly

        // getEffectSizeLabel wrapper removed - use MathUtils.getEffectSizeLabel() directly

        // getEffectSizeLabelR wrapper removed - use MathUtils.getEffectSizeLabelR() directly

        // getAsteriskNotation wrapper removed - use MathUtils.getAsteriskNotation() directly

        // Function to show results
        function displayResults() {
            const resultsDiv = document.getElementById('results');

            // Limpiar resultados previos (excepto debug info)
            resultsDiv.innerHTML = '';

            const outlierAnalysis = AppState.outlierAnalysis || window.getOutlierAnalysis?.() || window.outlierAnalysis;
            if (outlierAnalysis) {
                displayOutlierPanel();
                initializeActiveBox();
            } else {
            }

            // Summary statistics
            createSummaryCard();

            // Group statistics
            createGroupStatsCard();

            // Parameter table
            if (processedData.validAnimals.length > 0) {
                createParameterTable();
            }

            // Statistical comparison of r values
            createStatisticalComparisonCard();

            createMainChart();
            createNormalizedGrowthChart();

            // Reevaluate homogeneity with final dataset (R² filtered) after all content
            if (initialHomogeneityResults && processedData.validAnimals.length > 0) {
                const homogeneityComparison = reevaluateHomogeneity(processedData.validAnimals, 'validAnimals');
                if (homogeneityComparison) {
                    displayHomogeneityComparison(homogeneityComparison);
                }
            }
        }

        // Function to create summary card
        function createSummaryCard() {
            const card = document.createElement('div');
            card.className = 'result-card';

            const totalAnimals = processedData.validAnimals.length + processedData.invalidAnimals.length;
            const validPercentage = totalAnimals > 0 ? (processedData.validAnimals.length / totalAnimals * 100).toFixed(1) : 0;

            card.innerHTML = `
                <h2>Analysis Summary</h2>
                <div class="summary-grid">
                    <div class="stat-card stat-card-blue">
                        <div class="stat-value stat-value-blue">${totalAnimals}</div>
                        <div class="stat-label">Total Animals</div>
                    </div>
                    <div class="stat-card stat-card-cyan">
                        <div class="stat-value stat-value-cyan">${processedData.validAnimals.length}</div>
                        <div class="stat-label">Valid Animals</div>
                    </div>
                    <div class="stat-card stat-card-pink">
                        <div class="stat-value stat-value-pink">${validPercentage}%</div>
                        <div class="stat-label">Validity Rate</div>
                    </div>
                    <div class="stat-card stat-card-yellow">
                        <div class="stat-value stat-value-yellow">${Object.keys(processedData.groupStats).length}</div>
                        <div class="stat-label">Detected Groups</div>
                    </div>
                </div>
            `;

            document.getElementById('results').appendChild(card);
        }

        // Function to create group statistics card
        function createGroupStatsCard() {
            const card = document.createElement('div');
            card.className = 'result-card';

            const dataType = processedData.dataType;
            const paramLabel = dataType === 'volume' ? 'V₀' : 'BLI₀';
            const unitLabel = dataType === 'volume' ? ' mm³' : '';

            let html = '<h2>Group Statistics</h2>';
            html += '<div class="groups-grid">';

            Object.entries(processedData.groupStats).forEach(([group, stats]) => {
                const total = stats.valid + stats.invalid;
                const validPercentage = total > 0 ? (stats.valid / total * 100).toFixed(1) : 0;

                // Calculate relative errors (standard error/mean * 100)
                const relErrorR = stats.avgR !== 0 && stats.seR > 0 ?
                    (stats.seR / Math.abs(stats.avgR) * 100).toFixed(1) : '0.0';
                const relErrorA = stats.avgA !== 0 && stats.seA > 0 ?
                    (stats.seA / Math.abs(stats.avgA) * 100).toFixed(1) : '0.0';

                const avgAValue = dataType === 'bli' ?
                    stats.avgA.toExponential(2) :
                    stats.avgA.toFixed(2);

                html += `
                    <div class="group-card">
                        <div class="group-name">${group}</div>
                        <div class="group-count">${stats.valid}/${total}</div>
                        <div class="group-validity">Valid (${validPercentage}%)</div>
                        ${stats.valid > 0 ? `
                            <div class="group-stats">
                                <div>r: ${stats.avgR.toFixed(4)} ± ${relErrorR}%</div>
                                <div>R²: ${stats.avgR2.toFixed(4)}</div>
                                <div>${paramLabel}: ${avgAValue}${unitLabel} ± ${relErrorA}%</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            html += '</div>';
            card.innerHTML = html;

            document.getElementById('results').appendChild(card);
        }

        // Function to create parameters table
        function createParameterTable() {
            const card = document.createElement('div');
            card.className = 'result-card';

            const dataType = processedData.dataType;
            const paramLabel = dataType === 'volume' ? 'V₀' : 'BLI₀';
            const unitLabel = dataType === 'volume' ? 'mm³' : '';

            let html = '<h2>Exponential Model Parameters</h2>';
            html += `
            <div class="overflow-auto">
                <table>
                    <thead>
                        <tr>
                            <th style="text-align: left;">Animal ID</th>
                            <th>Group</th>
                            <th>${paramLabel}${unitLabel ? ` (${unitLabel})` : ''}</th>
                            <th>r (day⁻¹)</th>
                            <th>R²</th>
                            <th>Doubling time (days)</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            processedData.validAnimals.forEach((animal, index) => {
                const doublingTime = (animal.model.r && animal.model.r > 0) ? Math.log(2) / animal.model.r : Infinity;
                const a0Value = dataType === 'bli' ?
                    animal.model.a.toExponential(3) :
                    animal.model.a.toFixed(2);

                html += `
                    <tr>
                        <td style="text-align: left;">${animal.id}</td>
                        <td>${animal.group}</td>
                        <td>${a0Value}</td>
                        <td>${animal.model.r.toFixed(4)}</td>
                        <td>${animal.model.r2.toFixed(3)}</td>
                        <td>${doublingTime.toFixed(1)}</td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            card.innerHTML = html;

            document.getElementById('results').appendChild(card);
        }

        // Function to create statistical comparison card
        function createStatisticalComparisonCard() {
            const groups = Object.keys(processedData.groupStats);
            
            // Only show comparison if there are 2 or more groups with valid animals
            const validGroups = groups.filter(group => 
                processedData.groupStats[group].validAnimals.length > 1
            );
            
            if (validGroups.length < 2) {
                return; // Don't show card if insufficient data for comparison
            }

            const card = document.createElement('div');
            card.className = 'result-card statistical-comparison-card';

            let html = `
                <h2>Statistical Comparison of Growth Rates (<i>r</i> values)</h2>
                <p style="color: #a0a0a0; margin-bottom: 1rem;">Pairwise comparisons using Mann-Whitney U test</p>
            `;

            // Perform statistical comparisons
            const comparisons = performStatisticalComparison();

            if (comparisons.length === 0) {
                html += '<p style="color: #ffa500;">No valid comparisons possible with current data.</p>';
            } else {
                html += `
                    <div style="overflow-x: auto;">
                        <table>
                            <thead>
                                <tr>
                                    <th style="text-align: left">Comparison</th>
                                    <th>Group 1 (n)</th>
                                    <th>Group 2 (n)</th>
                                    <th>Median Diff</th>
                                    <th>U-statistic</th>
                                    <th>Z-statistic</th>
                                    <th>p-value</th>
                                    <th>Effect Size</th>
                                    <th>Significance</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                comparisons.forEach(comp => {
                    const significanceColor = comp.significant ? '#00f2fe' : '#a0a0a0';
                    const significanceText = comp.significant ? 'Significant' : 'Not significant';
                    const pValueText = comp.pValue < 0.001 ? '<0.001' : comp.pValue.toFixed(3);
                    const asterisks = MathUtils.getAsteriskNotation(comp.pValue);
                    
                    html += `
                        <tr>
                            <td style="font-weight: bold; text-align: left;">${comp.group1} vs ${comp.group2}</td>
                            <td>${comp.median1.toFixed(4)} (${comp.n1})</td>
                            <td>${comp.median2.toFixed(4)} (${comp.n2})</td>
                            <td style="color: ${comp.medianDiff > 0 ? '#4facfe' : '#ff6b6b'};">
                                ${comp.medianDiff > 0 ? '+' : ''}${comp.medianDiff.toFixed(4)}
                            </td>
                            <td>${comp.UStatistic.toFixed(1)}</td>
                            <td>${comp.zStatistic.toFixed(3)}</td>
                            <td style="color: ${significanceColor}; font-weight: bold;">
                            ${pValueText}${asterisks ? ` (${asterisks})` : ''}
                            </td>
                            </td>
                            <td>
                                ${comp.effectSize}<br>
                                <small style="color: #a0a0a0;">(d=${comp.cohensD.toFixed(3)})</small>
                            </td>
                            <td style="color: ${significanceColor}; font-weight: bold;">
                                ${significanceText}
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                    <div style="margin-top: 1rem; padding: 1rem; background: rgba(79, 172, 254, 0.1); border-radius: 8px; border: 1px solid rgba(79, 172, 254, 0.3);">
                        <h4 style="margin: 0 0 0.5rem 0; color: #4facfe;">Statistical Notes:</h4>
                        <ul style="margin: 0; padding-left: 1.5rem; color: #a0a0a0; font-size: 0.9rem;">
                            <li>Two-tailed Mann-Whitney U test (non-parametric, rank-based)</li>
                            <li>Significance level: α = 0.05</li>
                            <li>Effect size (Cohen's d): Small=0.2, Medium=0.5, Large=0.8</li>
                            <li>U = Mann-Whitney U statistic, Z = standardized test statistic</li>
                            <li>Medians reported instead of means for non-parametric analysis</li>
                        </ul>
                    </div>
                `;
            }

            card.innerHTML = html;
            document.getElementById('results').appendChild(card);
        }

        // Function to create main chart
        async function createMainChart() {
            try {
                // Create UI elements
                AppState.chartService.createMainChartUI();
                
                // Transform data and create chart using modern API
                const { modernData, dayColumns, options } = AppState.chartService._adaptLegacyData(processedData);
                await AppState.chartService.createMainChart(modernData, dayColumns, options);
                
                Logger.log('Main chart created successfully using modern API');
            } catch (error) {
                Logger.error('Error creating main chart:', error);
                throw error;
            }
        }

        // Function to create normalized growth chart (without table)
        async function createNormalizedGrowthChart() {
            try {
                // Create UI elements
                AppState.chartService.createNormalizedChartUI();
                
                // Transform data and create chart using modern API
                const normalizedData = AppState.chartService._createNormalizedDataFromLegacy(processedData);
                await AppState.chartService.createNormalizedGrowthChart(normalizedData);
                
                Logger.log('Normalized chart created successfully using modern API');
            } catch (error) {
                Logger.error('Error creating normalized chart:', error);
                throw error;
            }
        }


        // Wrapper function for backward compatibility
        function toggleNormalizedScale() {
            if (AppState.chartService && typeof AppState.chartService.toggleNormalizedScale === 'function') {
                const toggle = document.getElementById('scaleToggle');
                const useLogScale = toggle ? toggle.checked : false;
                AppState.chartService.toggleNormalizedScale(useLogScale);
            } else {
                Logger.warn('ChartService not available for scale toggle');
            }
        }


















        // Function to capture existing predictions
        function capturePredictions() {
            try {
                const predictionResults = document.getElementById('predictionResults');
                let hasPredictions = predictionResults && predictionResults.style.display !== 'none';
                let hasBatchPredictions = window.batchPredictionForReport;
                
                if (!hasPredictions && !hasBatchPredictions) {
                    return '';
                }

                let content = '';
                
                // Prioritize batch predictions over individual predictions to avoid duplication
                // If we have batch predictions, use them exclusively as they contain more comprehensive data
                if (hasBatchPredictions) {
                    try {
                        content += generateBatchPredictionReportHTML(window.batchPredictionForReport);
                    } catch (error) {
                        content += `
                            <h3>Batch Tumor Weight Predictions</h3>
                            <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #f44336; margin-bottom: 20px;">
                                <p style="color: #d32f2f;">Error loading batch predictions: ${error.message}</p>
                            </div>
                        `;
                    }
                } else if (hasPredictions) {
                    // Only capture individual predictions if no batch predictions exist
                    try {
                        // Check if the DOM content contains batch prediction data (to avoid duplication)
                        const domContent = predictionResults.innerHTML || '';
                        const isBatchData = domContent.includes('Statistical Comparison') || domContent.includes('Group Statistics');
                        
                        if (isBatchData) {
                            // If DOM contains batch data but we don't have window.batchPredictionForReport,
                            // create a simplified version to avoid showing raw HTML
                            content += `
                                <h3>Batch Tumor Weight Predictions</h3>
                                <div style="background: #fff3e0; padding: 20px; border-radius: 8px; border-left: 4px solid #f57c00; margin-bottom: 20px;">
                                    <p><strong>Note:</strong> Batch prediction results are available in the analysis panel above.</p>
                                    <p>For detailed statistics and comparisons, please refer to the main analysis section.</p>
                                </div>
                            `;
                        } else {
                            // True individual predictions
                            content += `
                                <h3>Individual Animal Predictions</h3>
                                <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; border-left: 4px solid #2196f3; margin-bottom: 20px;">
                                    ${domContent || 'No individual predictions available'}
                                </div>
                            `;
                        }
                    } catch (error) {
                        content += `
                            <h3>Individual Animal Predictions</h3>
                            <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #f44336; margin-bottom: 20px;">
                                <p style="color: #d32f2f;">Error loading individual predictions</p>
                            </div>
                        `;
                    }
                }
                
                return `
                    <h2>Predictions Made</h2>
                    ${content}
                `;
            } catch (error) {
                return `
                    <h2>Predictions Made</h2>
                    <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #f44336; margin-bottom: 20px;">
                        <p style="color: #d32f2f;">Error loading predictions data</p>
                    </div>
                `;
            }
        }

        function generateBatchPredictionReportHTML(batchResults) {
            try {
                // Validate input parameters
                if (!batchResults || typeof batchResults !== 'object') {
                    throw new Error('Invalid batch results object');
                }
                
                const predictions = batchResults.predictions;
                const experimentalWeights = batchResults.experimentalWeights || [];
                const targetDay = batchResults.targetDay;
                
                // Validate predictions array
                if (!predictions || !Array.isArray(predictions)) {
                    throw new Error('Invalid predictions array');
                }
                
                if (predictions.length === 0) {
                    return `
                        <h3>Batch Tumor Weight Predictions</h3>
                        <div style="background: #fff3e0; padding: 20px; border-radius: 8px; border-left: 4px solid #f57c00; margin-bottom: 20px;">
                            <p style="color: #e65100;">No predictions available</p>
                        </div>
                    `;
                }
                
                // Group statistics with error handling
                const groupStats = {};
                predictions.forEach(pred => {
                    if (pred && pred.group && typeof pred.predictedWeight === 'number') {
                        if (!groupStats[pred.group]) {
                            groupStats[pred.group] = [];
                        }
                        groupStats[pred.group].push(pred.predictedWeight);
                    }
                });
                
                // Statistical comparison if available
                let comparisonHTML = '';
                if (batchResults.comparison === 'mann-whitney') {
                    try {
                        const comparisonResults = performMannWhitneyComparison(predictions);
                        if (comparisonResults && comparisonResults.comparisons && comparisonResults.comparisons.length > 0) {
                            comparisonHTML = `
                                <h4>Statistical Comparison (Mann-Whitney U)</h4>
                                <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                                    <thead>
                                        <tr style="background: #f5f5f5;">
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Comparison</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">n1</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">n2</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Median 1 (g)</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Median 2 (g)</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">U</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">p-value</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Cohen's d</th>
                                            <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Effect Size</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${comparisonResults.comparisons.map(comp => {
                                            if (!comp || typeof comp !== 'object') return '';
                                            
                                            // Generate asterisk notation for p-value
                                            let pValueDisplay = 'N/A';
                                            let asterisks = '';
                                            if (comp.pValue && typeof comp.pValue === 'number') {
                                                if (comp.pValue < 0.001) {
                                                    asterisks = '***';
                                                } else if (comp.pValue < 0.01) {
                                                    asterisks = '**';
                                                } else if (comp.pValue < 0.05) {
                                                    asterisks = '*';
                                                } else {
                                                    asterisks = 'n.s.';
                                                }
                                                pValueDisplay = `${comp.pValue.toFixed(4)} (${asterisks})`;
                                            }
                                            
                                            return `
                                                <tr>
                                                    <td style="padding: 8px; border: 1px solid #ddd;">${comp.group1 || 'N/A'} vs ${comp.group2 || 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${comp.n1 || 0}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${comp.n2 || 0}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(comp.median1 && typeof comp.median1 === 'number') ? comp.median1.toFixed(3) : 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(comp.median2 && typeof comp.median2 === 'number') ? comp.median2.toFixed(3) : 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(comp.u && typeof comp.u === 'number') ? comp.u.toFixed(0) : 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${pValueDisplay}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(comp.cohensD && typeof comp.cohensD === 'number') ? comp.cohensD.toFixed(3) : 'N/A'}</td>
                                                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${comp.effectSize || 'N/A'}</td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            `;
                        }
                    } catch (compError) {
                        comparisonHTML = `
                            <h4>Statistical Comparison (Mann-Whitney U)</h4>
                            <p style="color: #d32f2f;">Error generating statistical comparison</p>
                        `;
                    }
                }
                
                // Validation summary if available
                let validationHTML = '';
                if (experimentalWeights && experimentalWeights.length > 0) {
                    try {
                        const validWeights = experimentalWeights.filter(w => w && typeof w.predictionError === 'number');
                        if (validWeights.length > 0) {
                            const avgError = validWeights.reduce((sum, w) => sum + w.predictionError, 0) / validWeights.length;
                            const errorsByRange = {
                                excellent: validWeights.filter(w => w.predictionError < 10).length,
                                good: validWeights.filter(w => w.predictionError >= 10 && w.predictionError < 20).length,
                                fair: validWeights.filter(w => w.predictionError >= 20).length
                            };
                            
                            validationHTML = `
                                <h4>Prediction Validation</h4>
                                <p><strong>Animals with experimental weights:</strong> ${validWeights.length} of ${predictions.length}</p>
                                <p><strong>Average prediction error:</strong> ${avgError.toFixed(1)}%</p>
                                <p><strong>Error distribution:</strong> Excellent (&lt;10%): ${errorsByRange.excellent}, Good (10-20%): ${errorsByRange.good}, Fair (&gt;20%): ${errorsByRange.fair}</p>
                            `;
                        }
                    } catch (valError) {
                        validationHTML = `
                            <h4>Prediction Validation</h4>
                            <p style="color: #d32f2f;">Error generating validation summary</p>
                        `;
                    }
                }
                
                return `
                    <h3>Batch Tumor Weight Predictions</h3>
                    <div style="background: #fff3e0; padding: 20px; border-radius: 8px; border-left: 4px solid #f57c00; margin-bottom: 20px;">
                        <h4>Summary (Target Day: ${targetDay || 'N/A'})</h4>
                        <p><strong>Total animals predicted:</strong> ${predictions.length}</p>
                        
                        <h4>Group Statistics</h4>
                        <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                            <thead>
                                <tr style="background: #f5f5f5;">
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Group</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">n</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Median (g)</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Range (g)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${Object.entries(groupStats).map(([group, weights]) => {
                                    if (!weights || weights.length === 0) return '';
                                    try {
                                        return `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd;">${group}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${weights.length}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${MathUtils.calculateMedian(weights).toFixed(3)}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${Math.min(...weights).toFixed(3)} - ${Math.max(...weights).toFixed(3)}</td>
                                            </tr>
                                        `;
                                    } catch (error) {
                                        return `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd;">${group}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${weights.length}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                            </tr>
                                        `;
                                    }
                                }).join('')}
                            </tbody>
                        </table>
                        
                        ${validationHTML}
                        ${comparisonHTML}
                        
                        <h4>Individual Predictions</h4>
                        <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                            <thead>
                                <tr style="background: #f5f5f5;">
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">Animal ID</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Group</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Predicted Weight (g)</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Experimental Weight (g)</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error (%)</th>
                                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;">R²</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${predictions.map(pred => {
                                    if (!pred || typeof pred !== 'object') return '';
                                    try {
                                        const exp = experimentalWeights ? experimentalWeights.find(e => e && e.animalId === pred.animalId) : null;
                                        return `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd;">${pred.animalId || 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${pred.group || 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(pred.predictedWeight && typeof pred.predictedWeight === 'number') ? pred.predictedWeight.toFixed(3) : 'N/A'} (Day ${pred.targetDay || 'N/A'})</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(exp && exp.experimentalWeight && typeof exp.experimentalWeight === 'number') ? exp.experimentalWeight.toFixed(3) + ' (Day ' + (exp.sacrificeDay || 'N/A') + ')' : 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(exp && exp.predictionError && typeof exp.predictionError === 'number') ? exp.predictionError.toFixed(1) + '%' : 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${(pred.r2 && typeof pred.r2 === 'number') ? pred.r2.toFixed(3) : 'N/A'}</td>
                                            </tr>
                                        `;
                                    } catch (predError) {
                                        return `
                                            <tr>
                                                <td style="padding: 8px; border: 1px solid #ddd;">${pred.animalId || 'N/A'}</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                                <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">Error</td>
                                            </tr>
                                        `;
                                    }
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            } catch (error) {
                return `
                    <h3>Batch Tumor Weight Predictions</h3>
                    <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #f44336; margin-bottom: 20px;">
                        <p style="color: #d32f2f;">Error generating batch prediction report: ${error.message}</p>
                    </div>
                `;
            }
        }

        function generateStatisticalComparisonHTML() {
            const groups = Object.keys(processedData.groupStats);
            
            // Only include comparison if there are 2 or more groups with valid animals
            const validGroups = groups.filter(group => 
                processedData.groupStats[group].validAnimals.length > 1
            );
            
            if (validGroups.length < 2) {
                return null; // Don't include section if insufficient data for comparison
            }

            // Perform statistical comparisons
            const comparisons = performStatisticalComparison();

            if (comparisons.length === 0) {
                return null;
            }

            let html = `
                <div class="summary-box">
                    <h2>Statistical Comparison of Growth Rates</h2>
                    <p style="color: #4a5568; margin-bottom: 20px; font-style: italic;">
                        Pairwise comparisons using Mann-Whitney U test (non-parametric, rank-based analysis)
                    </p>
                    
                    <div style="overflow-x: auto; margin: 20px 0;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
                            <thead>
                                <tr style="background: #f7fafc; border-bottom: 2px solid #e2e8f0;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600; color: white;">Comparison</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Group 1<br><small>(median, n)</small></th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Group 2<br><small>(median, n)</small></th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Median Diff</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">U-statistic</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Z-statistic</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">p-value</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Effect Size</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; color: white;">Significance</th>
                                </tr>
                            </thead>
                            <tbody>
            `;

            comparisons.forEach((comp, index) => {
                const significanceColor = comp.significant ? '#22543d' : '#4a5568';
                const significanceText = comp.significant ? 'Significant' : 'Not significant';
                const pValueText = comp.pValue < 0.001 ? '<0.001' : comp.pValue.toFixed(3);
                const asterisks = MathUtils.getAsteriskNotation(comp.pValue);
                const rowBg = index % 2 === 0 ? '#ffffff' : '#f8f9fa';
                const diffColor = comp.medianDiff > 0 ? '#2b6cb0' : '#c53030';
                
                html += `
                    <tr style="background: ${rowBg}; border-bottom: 1px solid #e2e8f0;">
                        <td style="padding: 12px; text-align: left; font-weight: bold; color: #1a202c;">${comp.group1} vs ${comp.group2}</td>
                        <td style="padding: 12px; text-align: center;">${comp.median1.toFixed(4)}<br><small style="color: #4a5568;">(n=${comp.n1})</small></td>
                        <td style="padding: 12px; text-align: center;">${comp.median2.toFixed(4)}<br><small style="color: #4a5568;">(n=${comp.n2})</small></td>
                        <td style="padding: 12px; text-align: center; color: ${diffColor}; font-weight: bold;">
                            ${comp.medianDiff > 0 ? '+' : ''}${comp.medianDiff.toFixed(4)}
                        </td>
                        <td style="padding: 12px; text-align: center;">${comp.UStatistic.toFixed(1)}</td>
                        <td style="padding: 12px; text-align: center;">${comp.zStatistic.toFixed(3)}</td>
                        <td style="padding: 12px; text-align: center; color: ${significanceColor}; font-weight: bold;">
                            ${pValueText}
                        </td>
                        <td style="padding: 12px; text-align: center;">
                            ${comp.effectSize}<br>
                            <small style="color: #4a5568;">(d=${comp.cohensD.toFixed(3)})</small>
                        </td>
                        <td style="padding: 12px; text-align: center; color: ${significanceColor}; font-weight: bold;">
                            ${significanceText}
                        </td>
                    </tr>
                `;
            });

            html += `
                            </tbody>
                        </table>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: #e6fffa; border-radius: 8px; border-left: 4px solid #38b2ac;">
                        <h4 style="margin: 0 0 10px 0; color: #234e52;">Statistical Notes:</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #2d3748; font-size: 0.9rem; line-height: 1.5;">
                            <li>Two-tailed Mann-Whitney U test (non-parametric, rank-based)</li>
                            <li>Significance level: α = 0.05</li>
                            <li>Effect size (Cohen's d): Small=0.2, Medium=0.5, Large=0.8</li>
                            <li>U = Mann-Whitney U statistic, Z = standardized test statistic</li>
                            <li>Medians reported instead of means for non-parametric analysis</li>
                        </ul>
                    </div>
                </div>
            `;

            return html;
        }



        async function generateReport() {
            try {
                if (!AppState.reportGenerator) {
                    showNotification('ReportGenerator not initialized', 'error');
                    return;
                }
                
                showNotification('Generating complete report...', 'info');
                const success = await AppState.reportGenerator.generateCompleteHTMLReport();
                
                if (success) {
                    showNotification('Complete report generated successfully', 'success');
                } else {
                    Logger.warn('Report generation failed via ReportGenerator');
                }
            } catch (error) {
                Logger.error('Error in generateReport:', error);
                showNotification('Report generation failed: ' + error.message, 'error');
            }
        }


        // exportEnhancedCSV() - REMOVED: Use exportManager.export('enhanced') instead

        // Event listeners
        document.addEventListener('DOMContentLoaded', function () {

            const fileInput = document.getElementById('fileInput');
            const fileLabel = document.getElementById('fileLabel');
            
            if (fileInput) {
                // File change listener is already set up in setupEventListeners() with proper debouncing
                
                // Add drag and drop functionality to main file input
                if (fileLabel) {
                    fileLabel.addEventListener('dragover', function(e) {
                        e.preventDefault();
                        this.style.borderColor = 'rgba(79, 172, 254, 1)';
                        this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.3), rgba(0, 153, 204, 0.3))';
                    });
                    
                    fileLabel.addEventListener('dragleave', function(e) {
                        e.preventDefault();
                        this.style.borderColor = 'rgba(79, 172, 254, 0.5)';
                        this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1))';
                    });
                    
                    fileLabel.addEventListener('drop', function(e) {
                        e.preventDefault();
                        this.style.borderColor = 'rgba(79, 172, 254, 0.5)';
                        this.style.background = 'linear-gradient(135deg, rgba(79, 172, 254, 0.1), rgba(0, 153, 204, 0.1))';
                        
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            fileInput.files = files;
                            fileInput.dispatchEvent(new Event('change'));
                        }
                    });
                }
            } else {
            }

            // Configure outlier selector
            // outlierConfig change handler now managed by FormChangeHandler
            
            // outlierFiltering change handler now managed by FormChangeHandler (if needed)
            
            // Configure R² threshold selector
            const r2ThresholdInput = document.getElementById('r2Threshold');
            if (r2ThresholdInput) {
                r2ThresholdInput.addEventListener('input', function() {
                    // Debounce to avoid excessive updates
                    clearTimeout(this.updateTimeout);
                    this.updateTimeout = setTimeout(() => {
                        updateHomogeneityComparisonForCurrentState();
                    }, 500);
                });
            }

            // Check libraries after a brief delay
            setTimeout(() => {
                if (Logger.isDebugMode()) checkLibraries();
                showNotification('ViVo initialized successfully', 'success');
            }, 1000);
        });

        // Enable buttons after analysis is completed
        function enablePostAnalysisButtons() {
            const buttons = ['exportBtn', 'predictionsBtn', 'tgrBtn', 'reportBtn'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.disabled = false;
                    // Remove disabled tooltip attribute
                    btn.removeAttribute('data-disabled-reason');
                }
            });
            
            // Add visual indication that analysis tools are now available
            const analysisToolsContainer = document.querySelector('.analysis-tools');
            if (analysisToolsContainer) {
                analysisToolsContainer.classList.add('analysis-complete');
            }
            
            // Update contextual wizard button state after analysis
            updateContextualWizardState('analysis-complete');
        }

        // Help modal functionality - now handled by UIManager
        // Global functions are automatically provided by UIManager.js

        // Close all modals and banners before starting tutorial
        function closeAllModalsAndBanners() {
            // Close all modals using ModalManager
            if (window.modalManager) {
                window.modalManager.hideAll();
            }
            
            // Close welcome banner if visible
            const welcomeBanner = document.getElementById('welcomeBanner');
            if (welcomeBanner && welcomeBanner.style.display !== 'none') {
                hideWelcomeBanner();
            }
        }

        // Welcome banner management
        function showWelcomeBanner(force = false) {
            const banner = document.getElementById('welcomeBanner');
            if (banner && (force || !localStorage.getItem('vivoWelcomeDismissed'))) {
                banner.style.display = 'block';
                banner.classList.add('welcome-banner-show');
            }
        }

        function hideWelcomeBanner() {
            const banner = document.getElementById('welcomeBanner');
            if (banner) {
                banner.classList.add('welcome-banner-hide');
                setTimeout(() => {
                    banner.style.display = 'none';
                    banner.classList.remove('welcome-banner-show', 'welcome-banner-hide');
                }, 300);
                // Note: We don't set any localStorage here - banner will show again next time
            }
        }

        function dismissWelcomeBannerPermanently() {
            const banner = document.getElementById('welcomeBanner');
            if (banner) {
                banner.classList.add('welcome-banner-hide');
                setTimeout(() => {
                    banner.style.display = 'none';
                    banner.classList.remove('welcome-banner-show', 'welcome-banner-hide');
                }, 300);
                // Set localStorage to permanently dismiss the banner
                localStorage.setItem('vivoWelcomeDismissed', 'true');
            }
        }

        // Check URL parameters for getting started
        function checkURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const showGettingStarted = urlParams.get('getting-started');
            const showHelp = urlParams.get('help');
            const startWizard = urlParams.get('wizard');
            const startTutorial = urlParams.get('tutorial');

            if (showGettingStarted === 'true' || showGettingStarted === '1') {
                setTimeout(() => showWelcomeBanner(true), 500);
            } else if (showHelp === 'true' || showHelp === '1') {
                setTimeout(() => modalManager.show('help'), 500);
            } else if (startWizard === 'true' || startWizard === '1') {
                setTimeout(() => scientificWizard.start(), 500);
            } else if (startTutorial === 'true' || startTutorial === '1') {
                setTimeout(() => startTutorial(), 500);
            }
        }

        // Generate shareable URLs for different actions
        function getShareableURL(action) {
            const baseURL = window.location.origin + window.location.pathname;
            const params = new URLSearchParams();
            
            switch(action) {
                case 'getting-started':
                    params.set('getting-started', 'true');
                    break;
                case 'wizard':
                    params.set('wizard', 'true');
                    break;
                case 'tutorial':
                    params.set('tutorial', 'true');
                    break;
                case 'help':
                    params.set('help', 'true');
                    break;
                default:
                    return baseURL;
            }
            
            return `${baseURL}?${params.toString()}`;
        }

        // Copy URL to clipboard (for future use)
        function copyShareableURL(action) {
            const url = getShareableURL(action);
            if (typeof navigator !== 'undefined' && navigator.clipboard) {
                navigator.clipboard.writeText(url).then(() => {
                    showNotification(`URL copied to clipboard: ${action}`, 'success', 3000);
                }).catch(() => {
                    showNotification(`URL: ${url}`, 'info', 8000);
                });
            } else {
                showNotification(`URL: ${url}`, 'info', 8000);
            }
        }

        // Contextual wizard button state management
        function updateContextualWizardState(state) {
            const contextWizardBtn = document.getElementById('contextWizardBtn');
            if (!contextWizardBtn) return;
            
            const wizardTitle = contextWizardBtn.querySelector('.wizard-title');
            const wizardSubtitle = contextWizardBtn.querySelector('.wizard-subtitle');
            
            switch(state) {
                case 'data-loaded':
                    contextWizardBtn.classList.add('data-loaded');
                    if (wizardTitle) {
                        wizardTitle.textContent = 'Configure Analysis Parameters';
                    }
                    if (wizardSubtitle) {
                        wizardSubtitle.textContent = 'Optimize settings based on your loaded dataset';
                    }
                    break;
                case 'analysis-complete':
                    contextWizardBtn.classList.remove('data-loaded');
                    contextWizardBtn.classList.add('analysis-complete');
                    if (wizardTitle) {
                        wizardTitle.textContent = 'Reconfigure Parameters';
                    }
                    if (wizardSubtitle) {
                        wizardSubtitle.textContent = 'Adjust settings for alternative analysis approach';
                    }
                    break;
                case 'reset':
                    contextWizardBtn.classList.remove('data-loaded', 'analysis-complete');
                    if (wizardTitle) {
                        wizardTitle.textContent = 'Configuration Assistant';
                    }
                    if (wizardSubtitle) {
                        wizardSubtitle.textContent = 'Optimize analysis parameters for your study type';
                    }
                    break;
            }
        }

        // Welcome banner logic will be handled in main DOMContentLoaded below


        function isElementVisible(el) {
            const rect = el.getBoundingClientRect();
            const windowHeight = window.innerHeight || document.documentElement.clientHeight;
            const windowWidth = window.innerWidth || document.documentElement.clientWidth;
            
            // Element is visible if at least 30% of it is in viewport
            const verticalVisible = Math.max(0, Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0));
            const horizontalVisible = Math.max(0, Math.min(rect.right, windowWidth) - Math.max(rect.left, 0));
            
            const elementArea = rect.height * rect.width;
            const visibleArea = verticalVisible * horizontalVisible;
            
            return elementArea > 0 && (visibleArea / elementArea) >= 0.3;
        }

        
        // Initialize application when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize logger first
            Logger.init();
            
            // Then initialize the app
            App.init().then(() => {
                // Initialize TGR Matrices Service
                const tgrService = new TGRMatricesService();
                tgrService.init({
                    showNotification: showNotification,
                });
                
                // After app initialization, handle welcome banner and URL parameters
                checkURLParameters();
                
                // Show welcome banner by default unless user has explicitly dismissed it
                // Only skip if there are specific URL parameters that would override it
                const urlParams = new URLSearchParams(window.location.search);
                const hasOverrideParams = urlParams.has('wizard') || urlParams.has('tutorial') || urlParams.has('help');
                
                if (!hasOverrideParams) {
                    showWelcomeBanner();
                }
            }).catch(error => {
            });
        });

    
    </script>
    
    <!-- GitHub Issues Footer -->
    <div style="position: fixed; bottom: 10px; right: 10px; z-index: 1000;">
        <button onclick="window.modalManager.show('github-issues')" 
                style="background: linear-gradient(45deg, #4facfe, #00f2fe); color: white; border: none; padding: 12px 16px; border-radius: 50px; cursor: pointer; box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3); transition: all 0.3s ease; font-weight: 600; font-size: 14px;"
                onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(79, 172, 254, 0.4)'"
                onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 15px rgba(79, 172, 254, 0.3)'"
                title="Open GitHub Issues Panel">
            <i class="fab fa-github" style="margin-right: 8px;"></i>Report
        </button>
    </div>
    
    <!-- System Bootstrap - Initialize Core Managers -->
    <script src="js/core/system-bootstrap.js"></script>
    <script src="js/services/GitHubIssuesService.js"></script>
</body>

</html>
